<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chris Eidhof </title>
    <link>http://chris.eidhof.nl/index.xml</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2017</rights>
    <updated>2017-01-12 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>Types vs TDD</title>
          <link>http://chris.eidhof.nl/post/types-vs-tdd/</link>
          <pubDate>Thu, 12 Jan 2017 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/types-vs-tdd/</guid>
          <description>&lt;p&gt;This morning, I read &lt;a href=&#34;http://blog.cleancoder.com/uncle-bob/2017/01/11/TheDarkPath.html&#34;&gt;an article&lt;/a&gt; against static typing. To be more precise: it argues against static typing in the way Swift/Kotlin implement it. I don&amp;rsquo;t know anything about Kotlin, so I&amp;rsquo;ll try to relate everything to Swift.  The main point of the article is that too much static typing is a bad thing. I agree: although my definition of &amp;ldquo;too much&amp;rdquo; is very different.&lt;/p&gt;

&lt;p&gt;The main point of critique is that we can&amp;rsquo;t possibly keep adding features to a language to solve actual problems, because we would end up with too many features. Instead, we should solve everything by writing tests. I don&amp;rsquo;t think it&amp;rsquo;s an either/or situation at all: we can have a solid type system and write &amp;ldquo;manual&amp;rdquo; tests.&lt;/p&gt;

&lt;p&gt;A type checker actually does testing for you. It&amp;rsquo;s not a replacement for TDD, but it allows you to completely get rid of a whole bunch of tests. For example, if you define a method &lt;code&gt;foo&lt;/code&gt; that returns an &lt;code&gt;Int&lt;/code&gt;, you can be sure it will only return &lt;code&gt;Int&lt;/code&gt;s. Not &lt;code&gt;String&lt;/code&gt;s, not &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, not anything else. No need to write a test.&lt;/p&gt;

&lt;p&gt;The article argues that specifying a type such as &lt;code&gt;Int&lt;/code&gt; is very inflexible: what if you ever wanted to change &lt;code&gt;foo&lt;/code&gt; to return an optional?  According to the article, you have to know this before you write the system. (And if I interpret the article correctly, it argues that TDD would solve this).&lt;/p&gt;

&lt;p&gt;I agree on at least one thing: at some point, code is going to change. However, I couldn&amp;rsquo;t disagree more on the statement that typing makes this hard.&lt;/p&gt;

&lt;p&gt;In Swift, once you change &lt;code&gt;foo&lt;/code&gt; to return an &lt;code&gt;Int?&lt;/code&gt;, the compiler will now show an error for each time you call &lt;code&gt;foo&lt;/code&gt;. This makes it &lt;em&gt;easy&lt;/em&gt; to make that change, because until you have reviewed every single call to &lt;code&gt;foo&lt;/code&gt;, the program simply won&amp;rsquo;t compile. I think of the compile errors as a todo-list, not as a &lt;a href=&#34;https://twitter.com/unclebobmartin/status/819262224686546945&#34;&gt;speed bump&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When you make changes (small or large ones), it&amp;rsquo;s good to have a system in place that checks whether your code still works. With many kinds of changes, the compiler can do this automatically. You don&amp;rsquo;t have to write tests for that.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t get me wrong: types are not a silver bullet. You still need to test your code. But wouldn&amp;rsquo;t you rather test interesting parts, and leave the boring stuff to the compiler?&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Protocol Oriented Programming is Not a Silver Bullet</title>
          <link>http://chris.eidhof.nl/post/protocol-oriented-programming/</link>
          <pubDate>Thu, 24 Nov 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/protocol-oriented-programming/</guid>
          <description>

&lt;p&gt;In Swift, protocol-oriented programming is in fashion. There&amp;rsquo;s a lot of Swift code out there that&amp;rsquo;s &amp;ldquo;protocol-oriented&amp;rdquo;, some open-source libraries even state it as a feature. I think protocols are heavily overused in Swift, and oftentimes the problem at hand can be solved in a much simpler way. In short: don&amp;rsquo;t be dogmatic about using (or avoiding) protocols.&lt;/p&gt;

&lt;p&gt;One of the most influential sessions at WWDC 2015 was called &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2015/408/&#34;&gt;Protocol-Oriented Programming in Swift&lt;/a&gt;. It shows (among other things) that you can replace a class hierarchy (that is, a superclass and some subclasses) with a protocol-oriented solution (that is, a protocol and some types that conform to the protocol). The protocol-oriented solution is simpler, and more flexible. For example, a class can only have a single superclass, yet a type can conform to many protocols.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the problem they solved in the WWDC talk. A series of drawing commands needed to be rendered as a graphic, as well as logged to the console. By putting the drawing commands in a protocol, any code that describes a drawing could be phrased in terms of the protocol&amp;rsquo;s methods. Protocol extensions allow you to define new drawing functionality in terms of the protocol&amp;rsquo;s base functionality, and every type that conforms gets the new functionality for free.&lt;/p&gt;

&lt;p&gt;In the example above, protocols solve the problem of sharing code between multiple types. In Swift&amp;rsquo;s Standard Library, protocols are heavily used for collections, and they solve exactly the same problem. Because &lt;code&gt;dropFirst&lt;/code&gt; is defined on the &lt;code&gt;Collection&lt;/code&gt; type, all the collection types get this for free! At the same time, there are so many collection-related protocols and types, that it can be hard to find things. That&amp;rsquo;s one drawback of protocols, yet the advantages easily outweigh the disadvantages in the case of the Standard Library.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s work our way through an example. Here, we have a Webservice class. It loads entities from the network using &lt;code&gt;URLSession&lt;/code&gt;. (It doesn&amp;rsquo;t actually load things, but you get the idea):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Webservice {
    func loadUser() -&amp;gt; User? {
        let json = self.load(URL(string: &amp;quot;/users/current&amp;quot;)!)
        return User(json: json)
    }
    
    func loadEpisode() -&amp;gt; Episode? {
        let json = self.load(URL(string: &amp;quot;/episodes/latest&amp;quot;)!)
        return Episode(json: json)
    }
    
    private func load(_ url: URL) -&amp;gt; [AnyHashable:Any] {
        URLSession.shared.dataTask(with: url)
        // etc.
        return [:] // should come from the server
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above is short and works fine. There is no problem, until we want to test &lt;code&gt;loadUser&lt;/code&gt; and &lt;code&gt;loadEpisode&lt;/code&gt;. Now we either have to stub &lt;code&gt;load&lt;/code&gt;, or pass in a mock &lt;code&gt;URLSession&lt;/code&gt; using dependency injection. We could also define a protocol that &lt;code&gt;URLSession&lt;/code&gt; conforms to and then pass in a test instance. However, in this case, the solution is much simpler: we can pull the changing parts out of the &lt;code&gt;Webservice&lt;/code&gt; and into a struct (we also cover this in &lt;a href=&#34;https://talk.objc.io/episodes/S01E01-networking&#34;&gt;Swift Talk Episode 1&lt;/a&gt; and in &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Resource&amp;lt;A&amp;gt; {
    let url: URL
    let parse: ([AnyHashable:Any]) -&amp;gt; A
}

class Webservice {
    let user = Resource&amp;lt;User&amp;gt;(url: URL(string: &amp;quot;/users/current&amp;quot;)!, parse: User.init)
    let episode = Resource&amp;lt;Episode&amp;gt;(url: URL(string: &amp;quot;/episodes/latest&amp;quot;)!, parse: Episode.init)
    
    private func load&amp;lt;A&amp;gt;(resource: Resource&amp;lt;A&amp;gt;) -&amp;gt; A {
        URLSession.shared.dataTask(with: resource.url)
        // load asynchronously, parse the JSON, etc. For the sake of the example, we directly return an empty result.
        let json: [AnyHashable:Any] = [:] // should come from the server
        return resource.parse(json)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can test &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;episode&lt;/code&gt; without having to mock anything: they&amp;rsquo;re simple struct values. We still have to test &lt;code&gt;load&lt;/code&gt;, but that&amp;rsquo;s only one method (instead of for each resource). Now let&amp;rsquo;s add some protocols.&lt;/p&gt;

&lt;p&gt;Instead of the &lt;code&gt;parse&lt;/code&gt; function, we could create a protocol for types that can be initialized from JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol FromJSON {
    init(json: [AnyHashable:Any])
}

struct Resource&amp;lt;A: FromJSON&amp;gt; {
    let url: URL
}

class Webservice {
    let user = Resource&amp;lt;User&amp;gt;(url: URL(string: &amp;quot;/users/current&amp;quot;)!)
    let episode = Resource&amp;lt;Episode&amp;gt;(url: URL(string: &amp;quot;/episodes/latest&amp;quot;)!)
    
    private func load&amp;lt;A&amp;gt;(resource: Resource&amp;lt;A&amp;gt;) -&amp;gt; A {
        URLSession.shared.dataTask(with: resource.url)
        // load asynchronously, parse the JSON, etc. For the sake of the example, we directly return an empty result.
        let json: [AnyHashable:Any] = [:] // should come from the server
        return A(json: json)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above might look simpler, but it&amp;rsquo;s also way less flexible. For example, how would you define a resource that has an array of &lt;code&gt;User&lt;/code&gt; values? (In the protocol-oriented example above, that&amp;rsquo;s not yet possible, and we&amp;rsquo;ll have to wait for Swift 4 or 5 until this is expressible). The protocol makes things simpler, but I think it doesn&amp;rsquo;t pay for itself, because it dramatically decreases the ways in which we can create a &lt;code&gt;Resource&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Instead of having the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;episode&lt;/code&gt; as &lt;code&gt;Resource&lt;/code&gt; values, we could also make &lt;code&gt;Resource&lt;/code&gt; a protocol and have &lt;code&gt;UserResource&lt;/code&gt; and &lt;code&gt;EpisodeResource&lt;/code&gt; structs. This seems to be a popular thing to do, because having a type instead of a value &amp;ldquo;just feels right&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Resource {
    associatedtype Result
    var url: URL { get }
    func parse(json: [AnyHashable:Any]) -&amp;gt; Result
}

struct UserResource: Resource {
    let url = URL(string: &amp;quot;/users/current&amp;quot;)!
    func parse(json: [AnyHashable : Any]) -&amp;gt; User {
        return User(json: json)
    }
}

struct EpisodeResource: Resource {
    let url = URL(string: &amp;quot;/episodes/latest&amp;quot;)!
    func parse(json: [AnyHashable : Any]) -&amp;gt; Episode {
        return Episode(json: json)
    }
}

class Webservice {
    private func load&amp;lt;R: Resource&amp;gt;(resource: R) -&amp;gt; R.Result {
        URLSession.shared.dataTask(with: resource.url)
        // load asynchronously, parse the JSON, etc. For the sake of the example, we directly return an empty result.
        let json: [AnyHashable:Any] = [:]
        return resource.parse(json: json)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if we look at it critically, what did we really gain? The code became longer, more complex and less direct. And because of the associated type, we&amp;rsquo;ll probably end up defining an &lt;code&gt;AnyResource&lt;/code&gt; eventually. Is there any benefit to having an &lt;code&gt;EpisodeResource&lt;/code&gt; struct instead of an &lt;code&gt;episodeResource&lt;/code&gt; value? They are both global definitions. For the struct, the name starts with an uppercase letter, and for the value, a lowercase letter. Other than that, there really isn&amp;rsquo;t any advantage. You can both namespace them (for autocompletion). So in this case, having a value is definitely simpler and shorter.&lt;/p&gt;

&lt;p&gt;There are many other examples I&amp;rsquo;ve seen in code around the internet. For example, I&amp;rsquo;ve seen a protocol like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol URLStringConvertible {
    var urlString: String { get }
}

// Somewhere later

func sendRequest(urlString: URLStringConvertible, method: ...) {
    let string = urlString.urlString
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What does this buy you? Why not simply remove the protocol and pass in the &lt;code&gt;urlString&lt;/code&gt; directly? Much simpler. Or a protocol with a single method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol RequestAdapter {
    func adapt(_ urlRequest: URLRequest) throws -&amp;gt; URLRequest
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A bit more controversial: why not simply remove the protocol, and pass in a function somewhere? Much simpler. (Unless your protocol is a class-only protocol and you want a weak reference it).&lt;/p&gt;

&lt;p&gt;I can keep showing examples, but I hope the point is clear. Often, there are simpler choices. More abstractly, protocols are just one way to achieve polymorphic code. There are many other ways: subclassing, generics, values, functions, and so on. Values (e.g. a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;URLStringConvertible&lt;/code&gt;) are the simplest way. Functions (e.g. &lt;code&gt;adapt&lt;/code&gt; instead of &lt;code&gt;RequestAdapter&lt;/code&gt;) are a bit more complex than values, but are still simple. Generics (without any constraints) are simpler than protocols. And to be complete, protocols are often simpler than class hierarchies.&lt;/p&gt;

&lt;p&gt;A useful heuristic might be to think about whether your protocol models data or behavior. For data, a struct is probably easier. For complex behavior (e.g. a delegate with multiple methods), a protocol is often easier. (The standard library&amp;rsquo;s collection protocols are a bit special: they don&amp;rsquo;t really describe data, but rather, they describe data manipulation.)&lt;/p&gt;

&lt;p&gt;That said, protocols can be very useful. But don&amp;rsquo;t start with a protocol just for the sake of protocol-oriented programming. Start by looking at your problem, and try to solve it in the simplest way possible. Let the problem drive the solution, not the other way around. Protocol-oriented programming isn&amp;rsquo;t inherently good or bad. Just like any other technique (functional programming, OO, dependency injection, subclassing) it can be used to solve a problem, and we should try to pick the right tool for the job. Sometimes that&amp;rsquo;s a protocol, but often, there&amp;rsquo;s a simpler way.&lt;/p&gt;

&lt;h3 id=&#34;more&#34;&gt;More&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thedotpost.com/2016/01/rob-napier-beyond-crusty-real-world-protocols&#34;&gt;http://www.thedotpost.com/2016/01/rob-napier-beyond-crusty-real-world-protocols&lt;/a&gt; (video)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.gamedev.net/page/resources/_/technical/game-programming/haskell-game-object-design-or-how-functions-can-get-you-apples-r3204&#34;&gt;http://www.gamedev.net/page/resources/_/technical/game-programming/haskell-game-object-design-or-how-functions-can-get-you-apples-r3204&lt;/a&gt; (Haskell)&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
      
    
      
        <item>
          <title>On Burnout</title>
          <link>http://chris.eidhof.nl/post/burnout/</link>
          <pubDate>Thu, 27 Oct 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/burnout/</guid>
          <description>&lt;p&gt;I&amp;rsquo;ve seen a number of blogposts and talks recently that talk about depression, burn-out, and other mental problems.  One post recommended reading a book. Another one recommended talking to friends and family. These things might help, but I doubt that they actually solve the root cause (looking back, they definitely didn&amp;rsquo;t solve my problems, at best suppress them).&lt;/p&gt;

&lt;p&gt;I recommend something different. If you have a mental issue, go see a professional. Take it seriously.  I know there&amp;rsquo;s a stigma attached to this, let&amp;rsquo;s try to break through that.&lt;/p&gt;

&lt;p&gt;If your leg is broken, you&amp;rsquo;d probably go to the hospital. With mental issues, you often don&amp;rsquo;t visually see that something is wrong. It might feel harder to justify seeing a professional. Some people are functioning very well while suffering from mental problems. For example, I can often turn my suppressed anger into productivity (alas, the anger still gets suppressed).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s scary to take that step. I started seeing a therapist about a year and a half ago, to deal with my depression. It&amp;rsquo;s been one the best things I&amp;rsquo;ve ever done for myself. If you&amp;rsquo;re suffering from a mental issue, consider doing the same.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Type Erasers in Swift</title>
          <link>http://chris.eidhof.nl/post/type-erasers-in-swift/</link>
          <pubDate>Thu, 20 Oct 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/type-erasers-in-swift/</guid>
          <description>&lt;p&gt;The following post is an excerpt from our book &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;. We just updated it to Swift 3, so this is a great time to buy it.&lt;/p&gt;

&lt;p&gt;Sometimes, we can use a protocol as a standalone type. However, with a protocol like &lt;code&gt;IteratorProtocol&lt;/code&gt;, this isn&amp;rsquo;t (yet) possible, because it has an associated type. The compile error says: &amp;ldquo;Protocol &amp;lsquo;IteratorProtocol&amp;rsquo; can only be used as a generic constraint because it has Self or associated type requirements.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct ConstantIterator: IteratorProtocol {
    mutating func next() -&amp;gt; Int? {
        return 1
    }
}

let iterator: IteratorProtocol = ConstantIterator() // Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a way, &lt;code&gt;IteratorProtocol&lt;/code&gt; used as a type is incomplete; we&amp;rsquo;d have to specify the associated type as well in order for this to be meaningful.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Swift Core Team has stated that they want to support &lt;em&gt;generalized existentials&lt;/em&gt;. This feature would allow for using protocols with associated types as standalone values, and it would also eliminate the need to write type erasers. For more information about what to expect in the future, see the &lt;a href=&#34;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160229/011666.html&#34;&gt;Swift Generics Manifesto&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a future version of Swift, we might be able to solve this by saying something like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let iterator: Any&amp;lt;IteratorProtocol where .Element == Int&amp;gt; = ConstantIterator()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currently, we can&amp;rsquo;t yet express this. We can, however, use &lt;code&gt;IteratorProtocol&lt;/code&gt; as a constraint for a generic parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func nextInt&amp;lt;I: IteratorProtocol&amp;gt;(iterator: inout I) -&amp;gt; Int?
    where I.Element == Int {
        return iterator.next()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, we can store an iterator in a class or struct. The limitation is the same, in that we can only use it as a generic constraint, and not as a standalone type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class IteratorStore&amp;lt;I: IteratorProtocol&amp;gt; where I.Element == Int {
    var iterator: I

    init(iterator: I) {
        self.iterator = iterator
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but it has a drawback: the specific type of the stored iterator &amp;ldquo;leaks out&amp;rdquo; through the generic parameter. In the current type system, we can&amp;rsquo;t express &amp;ldquo;any iterator, as long as the element type is &lt;code&gt;Int&lt;/code&gt;.&amp;rdquo; This is a problem if you want to, for example, put multiple &lt;code&gt;IteratorStore&lt;/code&gt;s into an array. All elements in an array must have the same type, and that includes any generic parameters; it&amp;rsquo;s not possible to create an array that can store both &lt;code&gt;IteratorStore&amp;lt;ConstantIterator&amp;gt;&lt;/code&gt; and &lt;code&gt;IteratorStore&amp;lt;FibsIterator&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Luckily, there are two ways around this — one is easy, the other one more efficient (but hacky). The process of removing a specific type (such as the iterator) is called &lt;em&gt;type erasure&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In the easy solution, we implement a wrapper class. Instead of storing the iterator directly, the class stores the iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; function. To do this, we must first copy the &lt;code&gt;iterator&lt;/code&gt; parameter to a &lt;code&gt;var&lt;/code&gt; variable so that we&amp;rsquo;re allowed to call its &lt;code&gt;next&lt;/code&gt; method (which is &lt;code&gt;mutating&lt;/code&gt;). We then wrap the call to &lt;code&gt;next()&lt;/code&gt; in a closure expression and assign that closure to a property. We used a class to signal that &lt;code&gt;IntIterator&lt;/code&gt; has reference semantics:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class IntIterator {
    var nextImpl: () -&amp;gt; Int?

    init&amp;lt;I: IteratorProtocol&amp;gt;(_ iterator: I) where I.Element == Int {
        var iteratorCopy = iterator
        self.nextImpl = { iteratorCopy.next() }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in our &lt;code&gt;IntIterator&lt;/code&gt;, the specific type of the iterator (e.g. &lt;code&gt;ConstantIterator&lt;/code&gt;) is only specified when creating a value. After that, the specific type is hidden, captured by the closure. We can create an &lt;code&gt;IntIterator&lt;/code&gt; with any kind of iterator, as long as the elements are integers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var iter = IntIterator(ConstantIterator())
iter = IntIterator([1,2,3].makeIterator())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above allows us to specify the associated type constraints (e.g. &lt;code&gt;iter&lt;/code&gt; contains an iterator with &lt;code&gt;Int&lt;/code&gt; elements) using Swift&amp;rsquo;s current type system. Our &lt;code&gt;IntIterator&lt;/code&gt; can also easily conform to the &lt;code&gt;IteratorProtocol&lt;/code&gt; (and the inferred associated type is &lt;code&gt;Int&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension IntIterator: IteratorProtocol {
    func next() -&amp;gt; Int? {
        return nextImpl()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, by abstracting over &lt;code&gt;Int&lt;/code&gt; and adding a generic parameter, we can change &lt;code&gt;IntIterator&lt;/code&gt; to work just like &lt;code&gt;AnyIterator&lt;/code&gt; does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class AnyIterator&amp;lt;A&amp;gt;: IteratorProtocol {
    var nextImpl: () -&amp;gt; A?

    init&amp;lt;I: IteratorProtocol&amp;gt;(_ iterator: I) where I.Element == A {
        var iteratorCopy = iterator
        self.nextImpl = { iteratorCopy.next() }
    }

    func next() -&amp;gt; A? {
        return nextImpl()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The specific iterator type (&lt;code&gt;I&lt;/code&gt;) is only specified in the initializer, and after that, it&amp;rsquo;s &amp;ldquo;erased.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;From this refactoring, we can come up with a simple algorithm for creating a type eraser. First, we create a struct or class named &lt;code&gt;AnyProtocolName&lt;/code&gt;. Then, for each associated type, we add a generic parameter. Finally, for each method, we store the implementation in a property on &lt;code&gt;AnyProtocolName&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For a simple protocol like &lt;code&gt;IteratorProtocol&lt;/code&gt;, this only takes a few lines of code, but for more complex protocols (such as &lt;code&gt;Sequence&lt;/code&gt;), this is quite a lot of work. Even worse, the size of the object or struct will increase linearly with each protocol method (because a new closure is added for each method).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The standard library takes a different approach to erasing types. We start by creating a simple class that conforms to &lt;code&gt;IteratorProtocol&lt;/code&gt;. Its generic type is the &lt;code&gt;Element&lt;/code&gt; of the iterator, and the implementation will simply crash:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class IteratorBox&amp;lt;A&amp;gt;: IteratorProtocol {
    func next() -&amp;gt; A? {
        fatalError(&amp;quot;This method is abstract.&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we create another class, &lt;code&gt;IteratorBoxHelper&lt;/code&gt;, which is also generic. Here, the generic parameter is the specific iterator type (for example, &lt;code&gt;ConstantIterator&lt;/code&gt;). The &lt;code&gt;next&lt;/code&gt; method simply forwards to the &lt;code&gt;next&lt;/code&gt; method of the underlying iterator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift-example&#34;&gt;class IteratorBoxHelper&amp;lt;I: IteratorProtocol&amp;gt; {
    var iterator: I
    init(iterator: I) {
        self.iterator = iterator
    }

    func next() -&amp;gt; I.Element? {
        return iterator.next()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now for the hacky part. We change &lt;code&gt;IteratorBoxHelper&lt;/code&gt; so that it&amp;rsquo;s a subclass of &lt;code&gt;IteratorBox&lt;/code&gt;, and the two generic parameters are constrained in such a way that &lt;code&gt;IteratorBox&lt;/code&gt; gets &lt;code&gt;I&lt;/code&gt;&amp;rsquo;s element as the generic parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class IteratorBoxHelper&amp;lt;I: IteratorProtocol&amp;gt;: IteratorBox&amp;lt;I.Element&amp;gt; {
    var iterator: I
    init(_ iterator: I) {
        self.iterator = iterator
    }

    override func next() -&amp;gt; I.Element? {
        return iterator.next()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to create a value of &lt;code&gt;IteratorBoxHelper&lt;/code&gt; and use it as an &lt;code&gt;IteratorBox&lt;/code&gt;, effectively erasing the type of &lt;code&gt;I&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let iter: IteratorBox&amp;lt;Int&amp;gt; = IteratorBoxHelper(ConstantIterator())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the standard library, the &lt;code&gt;IteratorBox&lt;/code&gt; and &lt;code&gt;IteratorBoxHelper&lt;/code&gt; are then made private, and yet another wrapper (&lt;code&gt;AnyIterator&lt;/code&gt;) makes sure that these implementation details are hidden from the public interface.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In my (limited) testing, I found that the struct version of &lt;code&gt;AnyIterator&lt;/code&gt; was about 10% faster (I&amp;rsquo;m not exactly sure why, probably because of less indirection). I &lt;a href=&#34;https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160905/002852.html&#34;&gt;started a topic&lt;/a&gt; on the swift-dev mailing list, but I&amp;rsquo;m not sure if anyone is taking it and making the change. If anyone reading this feels like proposing that change (and thoroughly testing performance), go ahead!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Sort Descriptors in Swift</title>
          <link>http://chris.eidhof.nl/post/sort-descriptors-in-swift/</link>
          <pubDate>Mon, 29 Aug 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/sort-descriptors-in-swift/</guid>
          <description>

&lt;p&gt;Just last week, someone asked me &amp;ldquo;in what respect does Swift fall short of the
dynamic features of Objective-C&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;Dynamic programming means a lot of different
things to different people, and I think they meant runtime programming. In this
post, we&amp;rsquo;ll look at replacing Objective-C&amp;rsquo;s runtime programming with
Swift&amp;rsquo;s functions.&lt;/p&gt;

&lt;p&gt;This post is an excerpt from the Functions chapter in &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced
Swift&lt;/a&gt;, which we&amp;rsquo;re currently
rewriting (and making very good progress).  The text below was originally written by &lt;a href=&#34;https://twitter.com/airspeedswift&#34;&gt;Airspeed
Velocity&lt;/a&gt;. I took his text and code, updated
everything for Swift 3 and made some heavy edits. Thanks to &lt;a href=&#34;https://twitter.com/olebegemann&#34;&gt;Ole Begemann&lt;/a&gt; for reading through a draft of this.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In the chapter on &lt;a href=&#34;#collections&#34;&gt;collections&lt;/a&gt;, we talked about parametrizing
behavior by passing functions as arguments. Let&amp;rsquo;s look at another example of
this: sorting.&lt;/p&gt;

&lt;p&gt;If you want to sort an array in Objective-C using Foundation, you are met with a
long list of different options. These provide a lot of flexibility and power,
but at the cost of complexity — even the simplest probably needs a trip to the
documentation to know how to use it.&lt;/p&gt;

&lt;p&gt;Sorting collections in Swift is simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var myArray = [3, 1, 2]
myArray.sorted() // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are really four sort methods: &lt;code&gt;sorted(by:)&lt;/code&gt; and &lt;code&gt;sort(by:)&lt;/code&gt;, times two for
the overloads that default to sorting comparable things in ascending order. But
the overloading means that when you want the simplest case, &lt;code&gt;sorted()&lt;/code&gt; is all
you need. If you want to sort in a different order, just supply a function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myArray.sorted(by: &amp;gt;) // [3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also supply a function if your elements don&amp;rsquo;t conform to &lt;code&gt;Equatable&lt;/code&gt; but
&lt;em&gt;do&lt;/em&gt; have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator, like tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var numberStrings = [(2, &amp;quot;two&amp;quot;), (1, &amp;quot;one&amp;quot;), (3, &amp;quot;three&amp;quot;)]
numberStrings.sort(by: &amp;lt;)
numberStrings // [(1, &amp;quot;one&amp;quot;), (2, &amp;quot;two&amp;quot;), (3, &amp;quot;three&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, you can supply a more complicated function if you want to sort by some
arbitrary calculated criteria:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let animals = [&amp;quot;elephant&amp;quot;, &amp;quot;zebra&amp;quot;, &amp;quot;dog&amp;quot;]
let sortedAnimals = animals.sorted { lhs, rhs in
    let l = lhs.characters.reversed()
    let r = rhs.characters.reversed()
    return l.lexicographicallyPrecedes(r)
}
sortedAnimals // [&amp;quot;zebra&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;elephant&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is this last ability — the ability to use any comparison function to sort a
collection — that makes the Swift sort so powerful, and makes this one function
able to replicate much (if not all) of the functionality of the various
different sorting methods in Foundation.&lt;/p&gt;

&lt;p&gt;To demonstrate this, let&amp;rsquo;s take a complex example inspired by the &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/SortDescriptors/Articles/Creating.html&#34;&gt;Sort
Descriptor Programming
Topics&lt;/a&gt;.
The &lt;code&gt;sortedArray(using:)&lt;/code&gt; method on &lt;code&gt;NSArray&lt;/code&gt; is very flexible and a great
example of the power of Objective-C&amp;rsquo;s dynamic nature. Support for selectors and
dynamic dispatch is still there in Swift, but the Swift standard library favors
a more function-based approach instead. Later on, we&amp;rsquo;ll show a few techniques
where functions as arguments, and treating functions as data, can be used to get
the same dynamic effects.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by defining a &lt;code&gt;Person&lt;/code&gt; object. Because we want to show how
Objective-C&amp;rsquo;s powerful runtime system works, we&amp;rsquo;ll have to make it an &lt;code&gt;NSObject&lt;/code&gt;
subclass (in pure Swift, a struct might have been a better choice):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class Person: NSObject {
    var first: String
    var last: String
    var yearOfBirth: Int
    init(first: String, last: String, yearOfBirth: Int) {
        self.first = first
        self.last = last
        self.yearOfBirth = yearOfBirth
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also define an array of people, with different names and birth years:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let people = [
    Person(first: &amp;quot;Jo&amp;quot;, last: &amp;quot;Smith&amp;quot;, yearOfBirth: 1970),
    Person(first: &amp;quot;Joe&amp;quot;, last: &amp;quot;Smith&amp;quot;, yearOfBirth: 1970),
    Person(first: &amp;quot;Joe&amp;quot;, last: &amp;quot;Smyth&amp;quot;, yearOfBirth: 1970),
    Person(first: &amp;quot;Joanne&amp;quot;, last: &amp;quot;smith&amp;quot;, yearOfBirth: 1985),
    Person(first: &amp;quot;Joanne&amp;quot;, last: &amp;quot;smith&amp;quot;, yearOfBirth: 1970),
    Person(first: &amp;quot;Robert&amp;quot;, last: &amp;quot;Jones&amp;quot;, yearOfBirth: 1970),
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to sort this array first by last name, then by first name, and finally
by birth year. We want to do this case insensitively and using the user&amp;rsquo;s
locale. An &lt;code&gt;NSSortDescriptor&lt;/code&gt; object describes how to order objects, and we can
use them to express the individual sorting criteria.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let lastDescriptor = NSSortDescriptor(key: &amp;quot;last&amp;quot;, ascending: true,
  selector: #selector(NSString.localizedCaseInsensitiveCompare(_:)))
let firstDescriptor = NSSortDescriptor(key: &amp;quot;first&amp;quot;, ascending: true, 
  selector: #selector(NSString.localizedCaseInsensitiveCompare(_:)))
let yearDescriptor = NSSortDescriptor(key: &amp;quot;yearOfBirth&amp;quot;, ascending: true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To sort the array, we can use the &lt;code&gt;sortedArray(using:)&lt;/code&gt; method on &lt;code&gt;NSArray&lt;/code&gt;.
This takes a list of sort descriptors. To determine the order of two elements,
it starts by using the first sort descriptor, and uses that result. However, if
two elements are equal according to the first descriptor, it uses the second
descriptor, and so on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;(people as NSArray).sortedArray(using: [lastDescriptor, firstDescriptor, yearDescriptor]) 
// [Robert Jones (1970), Jo Smith (1970), Joanne smith (1970), Joanne smith (1985), Joe Smith (1970), Joe Smyth (1970)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A sort descriptor uses two runtime features of Objective-C: the &lt;code&gt;key&lt;/code&gt; is a key
path, and &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html&#34;&gt;key-value
coding&lt;/a&gt;
is used to lookup the value of that key at runtime. The &lt;code&gt;selector&lt;/code&gt; parameter
takes a selector (which is really just a &lt;code&gt;String&lt;/code&gt; describing a method name). At
runtime, the selector is turned into a comparison function. When comparing two
objects, the values for the key are compared using that comparison function.&lt;/p&gt;

&lt;p&gt;This is a pretty cool use of runtime programming, especially when you realize
the array of sort descriptors can be built at runtime, say based on a user
clicking a column heading.&lt;/p&gt;

&lt;p&gt;How can we replicate this functionality using Swift&amp;rsquo;s &lt;code&gt;sort&lt;/code&gt;? It&amp;rsquo;s simple to
replicate &lt;em&gt;parts&lt;/em&gt; of the sort, for example, if you want to sort an array using
&lt;code&gt;localizedCaseInsensitiveCompare&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var strings = [&amp;quot;Hello&amp;quot;, &amp;quot;hallo&amp;quot;, &amp;quot;Hallo&amp;quot;, &amp;quot;hello&amp;quot;]
strings.sort { $0.localizedCaseInsensitiveCompare($1) == .orderedAscending}
strings // [&amp;quot;hallo&amp;quot;, &amp;quot;Hallo&amp;quot;, &amp;quot;Hello&amp;quot;, &amp;quot;hello&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to sort using just a single property of an object, that&amp;rsquo;s also
simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;people.sorted { $0.yearOfBirth &amp;lt; $1.yearOfBirth } 
// [Jo Smith (1970), Joe Smith (1970), Joe Smyth (1970), Joanne smith (1970), Robert Jones (1970), Joanne smith (1985)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach doesn&amp;rsquo;t work so great when optional properties are combined with
methods like &lt;code&gt;localizedCaseInsensitiveCompare&lt;/code&gt;, though — it gets ugly fast. For
example, consider sorting an array of filenames by file extension (using the
&lt;code&gt;fileExtension&lt;/code&gt; property from the &lt;a href=&#34;#optionals&#34;&gt;Optionals&lt;/a&gt; chapter):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var files = [&amp;quot;one&amp;quot;, &amp;quot;file.h&amp;quot;, &amp;quot;file.c&amp;quot;, &amp;quot;test.h&amp;quot;]
files.sort { l, r in r.fileExtension.flatMap { l.fileExtension?.localizedCaseInsensitiveCompare($0) } == .orderedAscending }
files // [&amp;quot;one&amp;quot;, &amp;quot;file.c&amp;quot;, &amp;quot;file.h&amp;quot;, &amp;quot;test.h&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later on, we&amp;rsquo;ll make it easier to use optionals when sorting. However, for now,
we haven&amp;rsquo;t even tried sorting by multiple properties. To sort by last name, then
first name, we can use the standard library&amp;rsquo;s &lt;code&gt;lexicographicalCompare&lt;/code&gt; method.
This takes two sequences and performs a phonebook-style comparison by moving
through each pair of elements until it finds one that isn&amp;rsquo;t equal. So we can
build two arrays of the elements and use &lt;code&gt;lexicographicalCompare&lt;/code&gt; to compare
them. It also takes a function to perform the comparison. We&amp;rsquo;ll put our use of
&lt;code&gt;localizedCaseInsensitiveCompare&lt;/code&gt; in the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let sortedPeople = people.sorted { p0, p1 in
    let left =  [p0.last, p0.first]
    let right = [p1.last, p1.first]

    return left.lexicographicallyPrecedes(right) {
        $0.localizedCaseInsensitiveCompare($1) == .orderedAscending
    }
}
sortedPeople // [Robert Jones (1970), Jo Smith (1970), Joanne smith (1985), Joanne smith (1970), Joe Smith (1970), Joe Smyth (1970)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, we&amp;rsquo;ve almost replicated the functionality of the original sort in
roughly the same number of lines. But there&amp;rsquo;s still a lot of room for
improvement: the building of arrays on every comparison is very inefficient, the
comparison is hardcoded, and we can&amp;rsquo;t really sort by &lt;code&gt;yearOfBirth&lt;/code&gt; using this
approach.&lt;/p&gt;

&lt;h3 id=&#34;functions-as-data&#34;&gt;Functions as Data&lt;/h3&gt;

&lt;p&gt;Rather than writing an even more complicated function that we can use to sort,
let&amp;rsquo;s take a step back. So far, the sort descriptors were much clearer, but they
use runtime programming. The functions we wrote do not use runtime programming,
but they are not so easy to write (and read).&lt;/p&gt;

&lt;p&gt;A sort descriptor is a way of describing the ordering of objects. Instead of
storing that information as a class, we can define a function to describe the
ordering of objects. The simplest possible definition would take two objects,
and returns &lt;code&gt;true&lt;/code&gt; if they are ordered. This is also exactly the type that the
standard library&amp;rsquo;s &lt;code&gt;sort(by:)&lt;/code&gt; and &lt;code&gt;sorted(by:)&lt;/code&gt; methods take as an argument.
It&amp;rsquo;s helpful to define a generic &lt;code&gt;typealias&lt;/code&gt; to describe sort descriptors:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;typealias SortDescriptor&amp;lt;Value&amp;gt; = (Value, Value) -&amp;gt; Bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As an example, we could define a sort descriptor that compares two &lt;code&gt;Person&lt;/code&gt;
objects by year of birth, or a sort descriptor that sorts by last name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let sortByYear: SortDescriptor&amp;lt;Person&amp;gt; = { $0.yearOfBirth &amp;lt; $1.yearOfBirth }
let sortByLastName: SortDescriptor&amp;lt;Person&amp;gt; = { 
  $0.last.localizedCaseInsensitiveCompare($1.last) == .orderedAscending 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than writing the sort descriptors by hand, we can write a function that
generates them. It&amp;rsquo;s not nice that we to write the same property twice: in the
&lt;code&gt;sortByLastName&lt;/code&gt;, we could have easily made a mistake and accidentally compared
&lt;code&gt;$0.last&lt;/code&gt; with &lt;code&gt;$1.first&lt;/code&gt;. Also, it&amp;rsquo;s tedious to write these sort descriptors:
to sort by first name, it&amp;rsquo;s probably easiest to copy and paste the
&lt;code&gt;sortByLastName&lt;/code&gt; definition and modify it.&lt;/p&gt;

&lt;p&gt;Rather than copying and pasting, we can define a function with an interface that
is much like &lt;code&gt;NSSortDescriptor&lt;/code&gt;, but without the runtime programming. This
function takes a key and a comparison method, and returns a sort descriptor (the
function, not the class &lt;code&gt;NSSortDescriptor&lt;/code&gt;). Here, &lt;code&gt;key&lt;/code&gt; is not a string, but a
function. To compare two keys, we use a function &lt;code&gt;isOrderedBefore&lt;/code&gt;. Finally, the
result type is a function as well, even though that is slightly obscured by the
&lt;code&gt;typealias&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sortDescriptor&amp;lt;Value, Key&amp;gt;(
  key: @escaping (Value) -&amp;gt; Key,
    _ isOrderedBefore: @escaping (Key, Key) -&amp;gt; Bool) 
    -&amp;gt; SortDescriptor&amp;lt;Value&amp;gt; {
    return { isOrderedBefore(key($0), key($1)) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to define &lt;code&gt;sortByYear&lt;/code&gt; in a different way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let sortByYearAlt: SortDescriptor&amp;lt;Person&amp;gt; = sortDescriptor(key: { $0.yearOfBirth }, &amp;lt;)
people.sorted(by: sortByYearAlt) 
// [Jo Smith (1970), Joe Smith (1970), Joe Smyth (1970), Joanne smith (1970), Robert Jones (1970), Joanne smith (1985)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can even define an overloaded variant that works for all &lt;code&gt;Comparable&lt;/code&gt; types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sortDescriptor&amp;lt;Value, Key&amp;gt;(key: @escaping (Value) -&amp;gt; Key)
    -&amp;gt; SortDescriptor&amp;lt;Value&amp;gt; where Key: Comparable {
    return { key($0) &amp;lt; key($1) }
}
let sortByYearAlt2: SortDescriptor&amp;lt;Person&amp;gt; = sortDescriptor(key: { $0.yearOfBirth })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both &lt;code&gt;sortDescriptor&lt;/code&gt; above work with boolean functions. The &lt;code&gt;NSSortDescriptor&lt;/code&gt;
class has an initializer that takes a comparison function such as
&lt;code&gt;localizedCaseInsensitiveCompare&lt;/code&gt;. Adding support for this is easy as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sortDescriptor&amp;lt;Value, Key&amp;gt;(
    key: @escaping (Value) -&amp;gt; Key,
    ascending: Bool = true,
    _ comparator: @escaping (Key) -&amp;gt; (Key) -&amp;gt; ComparisonResult
    ) -&amp;gt; SortDescriptor&amp;lt;Value&amp;gt; {
    return { lhs, rhs in
        let order: ComparisonResult = ascending ? .orderedAscending : .orderedDescending
        return comparator(key(lhs))(key(rhs)) == order
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to write our &lt;code&gt;sortByFirstName&lt;/code&gt; in a much shorter and clearer way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let sortByFirstName: SortDescriptor&amp;lt;Person&amp;gt; = 
  sortDescriptor(key: { $0.first }, String.localizedCaseInsensitiveCompare)
people.sorted(by: sortByFirstName) 
// [Jo Smith (1970), Joanne smith (1985), Joanne smith (1970), Joe Smith (1970), Joe Smyth (1970), Robert Jones (1970)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;SortDescriptor&lt;/code&gt; is just as expressive as its &lt;code&gt;NSSortDescriptor&lt;/code&gt; variant,
but it is typesafe, and it does not rely on runtime programming.&lt;/p&gt;

&lt;p&gt;Currently, we can only use a single &lt;code&gt;SortDescriptor&lt;/code&gt; function to sort arrays. If
you recall, we used the &lt;code&gt;NSArray.sortedArray(using:)&lt;/code&gt; method to sort an array
with a number of comparison operators. We could easily add a similar method to
&lt;code&gt;Array&lt;/code&gt;, or even to the &lt;code&gt;Sequence&lt;/code&gt; protocol. However, we would have to add it
twice: once for the mutating variant, and once for the non-mutating variant.&lt;/p&gt;

&lt;p&gt;We take a different approach so that we don&amp;rsquo;t have to write more extensions.
Instead, we write a function that combines multiple sort descriptors into a
single sort descriptor. It works just like the &lt;code&gt;sortedArray(using:)&lt;/code&gt; method: it
first tries the first descriptor and uses that result. Unless the values are
equal, then it uses the second descriptor, and so on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func combine&amp;lt;Value&amp;gt;
    (sortDescriptors: [SortDescriptor&amp;lt;Value&amp;gt;]) -&amp;gt; SortDescriptor&amp;lt;Value&amp;gt; {
    return { lhs, rhs in
        for isOrderedBefore in sortDescriptors {
            if isOrderedBefore(lhs,rhs) { return true }
            if isOrderedBefore(rhs,lhs) { return false }
        }
        return false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now finally replicate the initial example we had using sort descriptors:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let combined: SortDescriptor&amp;lt;Person&amp;gt; = combine(
  sortDescriptors: [sortByLastName,sortByFirstName,sortByYear]
)
people.sorted(by: combined) 
// [Robert Jones (1970), Jo Smith (1970), Joanne smith (1970), Joanne smith (1985), Joe Smith (1970), Joe Smyth (1970)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We ended up with the same behavior as before. However, the version using
functions is type-safe and does not rely on runtime programming, so it can be
optimized by the compiler as well. And we can use it with structs, or
non-Objective-C Objects.&lt;/p&gt;

&lt;p&gt;This approach of using functions as data — storing them in array and building
those arrays at runtime — opens up a new level of dynamic behavior, and it is
one way in which a statically typed compile-time-oriented language like Swift
can still replicate some of the dynamic behavior of languages like Objective-C
or Ruby.&lt;/p&gt;

&lt;p&gt;Also, it is possible to write functions that combine other functions. For
example, our &lt;code&gt;combine(sortDescriptors:)&lt;/code&gt; function took an array of sort
descriptors, and combined them into a single sort descriptor. Alternatively, we
could have written an operator to combine two sort functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;infix operator &amp;lt;||&amp;gt; : LogicalDisjunctionPrecedence
func &amp;lt;||&amp;gt;&amp;lt;A&amp;gt;(lhs: @escaping (A,A) -&amp;gt; Bool, rhs: @escaping (A,A) -&amp;gt; Bool) -&amp;gt; (A,A) -&amp;gt; Bool {
    return { x,y in
        if lhs(x,y) { return true }
        if lhs(y,x) { return false }
        
        // Otherwise, they&#39;re the same, so we check for the second condition
        if rhs(x,y) { return true }
        
        return false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the time, writing a custom operator is a bad idea. Custom operators are
often harder to read than functions, because the name isn&amp;rsquo;t explicit. However,
they can be very powerful when used sparingly. The operator above allows us to
rewrite our combined sort example like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let combinedAlt = sortByLastName &amp;lt;||&amp;gt; sortByFirstName &amp;lt;||&amp;gt; sortByYear
people.sorted(by: combinedAlt) 
// [Robert Jones (1970), Jo Smith (1970), Joanne smith (1970), Joanne smith (1985), Joe Smith (1970), Joe Smyth (1970)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That said, we prefer the &lt;code&gt;combine(sortDescriptors:)&lt;/code&gt; function over the custom
operator. It is clearer at the call-site, which makes for more readable code.
Unless you are writing highly domain-specific code, a custom operator is
probably overkill.&lt;/p&gt;

&lt;p&gt;The Foundation version still has one functional advantage over our version. It
can deal with optionals without having to write any more code. For example, if
we would make the &lt;code&gt;last&lt;/code&gt; property on &lt;code&gt;Person&lt;/code&gt; an optional string, we wouldn&amp;rsquo;t
have to change anything in our sorting code that uses &lt;code&gt;NSSortDescriptor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, all is not lost. You can feel it coming: once again, we write a
function which takes a function and returns a function. We can take a regular
comparing function such as &lt;code&gt;localizedCaseInsensitiveCompare&lt;/code&gt;, which works on two
&lt;code&gt;String&lt;/code&gt;s, and turn it into a function that takes two optional &lt;code&gt;String&lt;/code&gt;s. If
both values are &lt;code&gt;nil&lt;/code&gt;, they are equal. If the left-hand side is nil, but the
right-hand isn&amp;rsquo;t they&amp;rsquo;re ascending, and the other way around. Finally, if they
are both non-&lt;code&gt;nil&lt;/code&gt;, we can use the &lt;code&gt;compare&lt;/code&gt; function to compare them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func lift&amp;lt;A&amp;gt;(_ compare: @escaping (A) -&amp;gt; (A) -&amp;gt; ComparisonResult) -&amp;gt; (A?) -&amp;gt; (A?) -&amp;gt; ComparisonResult {
    return { lhs in { rhs in
        switch (lhs, rhs) {
        case (nil, nil): return .orderedSame
        case (nil, _): return .orderedAscending
        case (_, nil): return .orderedDescending
        case let (l?, r?): return compare(l)(r)
        default: fatalError() // Impossible case
        }
    } }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to &amp;ldquo;lift&amp;rdquo; a regular comparison function into the domain of
optionals, and it can be used together with our sortDescriptor function. If you
recall the &lt;code&gt;files&lt;/code&gt; array from before, sorting them by &lt;code&gt;fileExtension&lt;/code&gt; got really
ugly because we had to deal with optionals. However, with our new &lt;code&gt;lift&lt;/code&gt;
function, it&amp;rsquo;s very clean again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let lcic = lift(String.localizedCaseInsensitiveCompare)
let result = files.sorted(by: sortDescriptor(key: { $0.fileExtension }, lcic))
result // [&amp;quot;one&amp;quot;, &amp;quot;file.c&amp;quot;, &amp;quot;file.h&amp;quot;, &amp;quot;test.h&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We can write a similar version of &lt;code&gt;lift&lt;/code&gt; for functions that return a &lt;code&gt;Bool&lt;/code&gt;.
Before Swift 3, operators like &lt;code&gt;&amp;gt;&lt;/code&gt; were defined on optionals. They were
removed because they can lead to accidental bugs. However, with a boolean
&lt;code&gt;lift&lt;/code&gt; you can easily take an existing operator and make it work for
optionals.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One drawback of the function-based approach is that functions are opaque. We can
take an &lt;code&gt;NSSortDescriptor&lt;/code&gt;, print it to the console, and we get some information
about the sort descriptor: the key path, the selector name and whether it&amp;rsquo;s
ascending. Our function-based approach cannot do this. For sort descriptors,
this is not a problem in practice. If it&amp;rsquo;s important to have that information,
we could wrap the functions in a struct or class, and store additional debug
information.&lt;/p&gt;

&lt;p&gt;This approach has also given us a clean separation between the sorting method
and the comparison method. The algorithm that Swift&amp;rsquo;s sort uses is a hybrid of
multiple sorting algorithms — as of writing, it is an
&lt;a href=&#34;https://en.wikipedia.org/wiki/Introsort&#34;&gt;introsort&lt;/a&gt; (which is itself a hybrid
of a quicksort and a heapsort), but it switches to an &lt;a href=&#34;https://en.wikipedia.org/wiki/Insertion_sort&#34;&gt;insertion
sort&lt;/a&gt; for small collections to
avoid the upfront startup cost of the more complex sort algorithms.&lt;/p&gt;

&lt;p&gt;Introsort is not a
&amp;ldquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Category:Stable_sorts&#34;&gt;stable&lt;/a&gt;&amp;rdquo; sort. That is,
it does not necessarily maintain relative ordering of values that are otherwise
equal according to the comparison function.&lt;/p&gt;

&lt;p&gt;But if you implemented a stable sort, the separation of the sort method from the
comparison would allow you to swap it in easily:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;people.stableSorted(by: combine(
  sortDescriptors: [sortByLastName,sortByFirstName,sortByYear]
))
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Structs and mutation in Swift</title>
          <link>http://chris.eidhof.nl/post/structs-and-mutation-in-swift/</link>
          <pubDate>Tue, 16 Aug 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/structs-and-mutation-in-swift/</guid>
          <description>&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: This post is a draft-version of a new section in our book &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;. We&amp;rsquo;re currently updating the book for Swift 3. It&amp;rsquo;ll be a free update for everyone who has bought a digital version of the book. Thanks to &lt;a href=&#34;https://twitter.com/olebegemann&#34;&gt;Ole Begemann&lt;/a&gt; for suggestions and improvements.&lt;/p&gt;

&lt;p&gt;Value types imply that whenever a variable is copied, the value itself — and not just a reference to the value — is copied. For example, in almost all programming languages, scalar types are value types. This means that whenever a value is assigned to a new variable, it is copied rather than passed by reference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var a = 42
var b = a
b += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the code above executes, the value of &lt;code&gt;b&lt;/code&gt; will be 43, but &lt;code&gt;a&lt;/code&gt; will still be 42. This is so natural that it seems like stating the obvious. However, in Swift, all structs behave this way, not just scalar types.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple struct that describes a &lt;code&gt;Point&lt;/code&gt;. This is similar to &lt;code&gt;CGPoint&lt;/code&gt;, except that it contains &lt;code&gt;Int&lt;/code&gt;s, whereas &lt;code&gt;CGPoint&lt;/code&gt; contains &lt;code&gt;CGFloat&lt;/code&gt;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Point {
    var x: Int
    var y: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For structs, Swift automatically adds a memberwise initializer. This means we can now initialize a new variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let origin = Point(x: 0, y: 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because structs in Swift have value semantics, we cannot change any of the properties of a struct variable that&amp;rsquo;s defined using let. For example, the following code will not work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-highlight-swift&#34;&gt;origin.x = 10 // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though we defined &lt;code&gt;x&lt;/code&gt; within the struct as a &lt;code&gt;var&lt;/code&gt; property, we cannot change it, because &lt;code&gt;origin&lt;/code&gt; is defined using &lt;code&gt;let&lt;/code&gt;. This has some major advantages. For example, if you read a line like &lt;code&gt;let point = ...&lt;/code&gt;, and you know that &lt;code&gt;point&lt;/code&gt; is a struct variable, then you also know that it will never, ever, change. This is a great help when reading through code.&lt;/p&gt;

&lt;p&gt;To create a variable that we can mutate, we need to create it using &lt;code&gt;var&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var otherPoint = Point(x: 0, y: 0)
otherPoint.x += 10
otherPoint
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we create a variable using &lt;code&gt;var&lt;/code&gt;, we can mutate it. However, unlike with objects, every struct variable is unique. For example, we can create a new variable &lt;code&gt;thirdPoint&lt;/code&gt;, and assign the value of &lt;code&gt;origin&lt;/code&gt; to it. Now we can change &lt;code&gt;thirdPoint&lt;/code&gt;, but &lt;code&gt;origin&lt;/code&gt; (which we defined as an immutable variable using &lt;code&gt;let&lt;/code&gt;) will not change.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var thirdPoint = origin
thirdPoint.x += 10
thirdPoint
origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you assign a struct to a new variable, Swift automatically makes a copy. Even though this sounds very expensive, many of the copies can be optimized away by the compiler, and Swift tries hard to make the copies very cheap. In fact, many structs in the standard library are implemented using a technique called copy-on-write, which we will look at later.&lt;/p&gt;

&lt;p&gt;If we have struct values that we plan to use more often, we can define them in an extension as a static property. For example, we can define an &lt;code&gt;origin&lt;/code&gt; property on &lt;code&gt;Point&lt;/code&gt;, so that we can write &lt;code&gt;Point.origin&lt;/code&gt; everywhere we need it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Point {
    static let origin = Point(x: 0, y: 0)
}
Point.origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Structs can also contain other structs. For example, if we define a &lt;code&gt;Size&lt;/code&gt; struct, we can create a &lt;code&gt;Rect&lt;/code&gt; struct which is composed out of a point and a size:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Size {
    var width: Int
    var height: Int
}

struct Rectangle {
    var origin: Point
    var size: Size
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like before, we get a memberwise initializer for &lt;code&gt;Rectangle&lt;/code&gt;. The order of the parameters matches the order of the property definitions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;Rectangle(origin: Point.origin, 
          size: Size(width: 320, height: 480))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want a custom initializer for our struct, we can add it directly inside the struct definition. However, if the struct definition contains a custom initializer, Swift does not generate a memberwise initializer. By defining our custom initializer in an extension, we also get to keep the memberwise initializer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Rectangle {
    init(x: Int = 0, y: Int = 0, width: Int, height: Int) {
        origin = Point(x: x, y: y)
        size = Size(width: width, height: height)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of setting &lt;code&gt;origin&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; directly, we could have also called &lt;code&gt;self.init(origin:size:)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we define a mutable variable &lt;code&gt;screen&lt;/code&gt;, we can add a &lt;code&gt;didSet&lt;/code&gt; block that gets executed whenever &lt;code&gt;screen&lt;/code&gt; changes. This &lt;code&gt;didSet&lt;/code&gt; works for every definition of a struct, be it in a playground, in a class or when defining a global variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var screen = Rectangle(width: 320, height: 480) {
    didSet {
        print(&amp;quot;Screen changed! \(screen)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maybe somewhat surprisingly, even if we change something deep inside the struct, this will get triggered:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;screen.origin.x = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Understanding why this works is key to understanding value types. Mutating a struct variable is semantically the same as assigning a new value to it. When we mutate something deep inside the struct, it still means we are mutating the struct, so &lt;code&gt;didSet&lt;/code&gt; still needs to get triggered.&lt;/p&gt;

&lt;p&gt;With regular structs, the compiler will mutate the value in place, and not actually make a copy. With copy-on-write structs (which we&amp;rsquo;ll discuss later), this works differently.&lt;/p&gt;

&lt;p&gt;It would make sense to add two &lt;code&gt;Points&lt;/code&gt; together. We can use the &lt;code&gt;+&lt;/code&gt; operator for this, add both members, and return a new &lt;code&gt;Point&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func +(lhs: Point, rhs: Point) -&amp;gt; Point {
    return Point(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
}
screen.origin + Point(x: 10, y: 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could also lift this operation to rectangles, and add a &lt;code&gt;translate&lt;/code&gt; method which moves the rectangle by a given offset. Our first attempt doesn&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-highlight-swift&#34;&gt;extension Rectangle {
    func translate(by offset: Point) {
        origin = origin + offset
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler tells us that we cannot assign to the &lt;code&gt;origin&lt;/code&gt; property, because &lt;code&gt;self&lt;/code&gt; is immutable (writing &lt;code&gt;origin =&lt;/code&gt; is shorthand for &lt;code&gt;self.origin =&lt;/code&gt;). We could think of &lt;code&gt;self&lt;/code&gt; as an extra, implicit parameter that gets passed to every method on &lt;code&gt;Rectangle&lt;/code&gt;. You never have to pass the parameter, but it&amp;rsquo;s always there inside the method body. And it&amp;rsquo;s defined as &lt;code&gt;let&lt;/code&gt; by default. The reason this &lt;code&gt;let&lt;/code&gt; restriction exists is so that value semantics can be guaranteed. If we want to be able to mutate &lt;code&gt;self&lt;/code&gt;, or any property of &lt;code&gt;self&lt;/code&gt;, or even nested properties (e.g. &lt;code&gt;self.origin.x&lt;/code&gt;), we need to mark our method as &lt;code&gt;mutating&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Rectangle {
    mutating func translate(by offset: Point) {
        origin = origin + offset
    }
}
screen.translate(by: Point(x: 10, y: 10))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler enforces the &lt;code&gt;mutating&lt;/code&gt; keyword. Unless we use it, we are not allowed to mutate anything inside the method. By marking the method as &lt;code&gt;mutating&lt;/code&gt;, we change the behavior of &lt;code&gt;self&lt;/code&gt;. Instead of it being a &lt;code&gt;let&lt;/code&gt;, it now works like a &lt;code&gt;var&lt;/code&gt;: we can freely change any property. (To be precise, it&amp;rsquo;s not even a &lt;code&gt;var&lt;/code&gt;, but we will get to that in a little bit).&lt;/p&gt;

&lt;p&gt;If we define a &lt;code&gt;Rectangle&lt;/code&gt; variable using &lt;code&gt;let&lt;/code&gt;, we cannot call &lt;code&gt;translate&lt;/code&gt; on it, because the only &lt;code&gt;Rectangle&lt;/code&gt;s that are mutable are the ones defined using &lt;code&gt;var&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-highlight-swift&#34;&gt;let otherScreen = screen
otherScreen.translate(by: Point(x: 10, y: 10)) // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thinking back to the collections chapter, we can now see how the difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt; applies to our collections as well. The &lt;code&gt;append&lt;/code&gt; method on arrays is defined as &lt;code&gt;mutating&lt;/code&gt;, and therefore we are not allowed to call it on an array defined with &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Likewise, if we think about a property setter on a struct, it makes sense that they are mutating. Because Swift automatically marks every setter as &lt;code&gt;mutating&lt;/code&gt;, you cannot call a setter on a &lt;code&gt;let&lt;/code&gt; variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-highlight-swift&#34;&gt;let point = Point.origin
// doesn&#39;t work, because the setter is mutating.
point.x = 10 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In many cases, it makes sense to have both a &lt;code&gt;mutating&lt;/code&gt; and a non-mutating variant of the same method. For example, arrays have both a &lt;code&gt;sort()&lt;/code&gt; method (which is mutating and sorts in place) and a &lt;code&gt;sorted()&lt;/code&gt; method (which returns a new array). We can also add a non-mutating variant of our &lt;code&gt;translate(by:_)&lt;/code&gt; method. Instead of mutating &lt;code&gt;self&lt;/code&gt;, we create a copy, mutate that, and return a new &lt;code&gt;Rectangle&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Rectangle {
    func translated(by offset: Point) -&amp;gt; Rectangle {
        var copy = self
        copy.translate(by: offset)
        return copy
    }
}
screen.translated(by: Point(x: 20, y: 20))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The names &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;sorted&lt;/code&gt; are not chosen at random, but are names that conform to the Swift &lt;a href=&#34;https://swift.org/documentation/api-design-guidelines/&#34;&gt;API Design Guidelines&lt;/a&gt;. Likewise, we applied these guidelines to &lt;code&gt;translate&lt;/code&gt; and &lt;code&gt;translated&lt;/code&gt;. There is even specific documentation for methods that have a mutating and a non-mutating variant: because &lt;code&gt;translate&lt;/code&gt; has a side-effect, it should read as an imperative verb phrase. The non-mutating variant should have a -ed or -ing suffix.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In functional programming, side-effects are often considered bad, because they might influence your code in unexpected ways. For example, if an object is referenced in multiple places, every change automatically happens in every place. As we have seen in the introduction, when dealing with multi-threaded code, this can easily lead to bugs: because the object you are just checking can be modified from a different thread, all your assumptions might be invalid.&lt;/p&gt;

&lt;p&gt;With Swift structs, &lt;code&gt;mutating&lt;/code&gt; does not have the same problems. The mutation of the struct is a local side-effect, and only applies to the current struct variable. Because every struct variable is unique (or in other words: every struct value has exactly one owner), it&amp;rsquo;s almost impossible to introduce bugs this way. Unless you&amp;rsquo;re referring to a global struct variable across threads, that is.&lt;/p&gt;

&lt;p&gt;To understand how the &lt;code&gt;mutating&lt;/code&gt; keyword works, we can look at the behavior of &lt;code&gt;inout&lt;/code&gt;. In Swift, we can mark function parameters as &lt;code&gt;inout&lt;/code&gt;. Before we do that, let&amp;rsquo;s define a free function that moves a rectangle by ten points on both axes. We cannot simply call &lt;code&gt;translate&lt;/code&gt; directly on the &lt;code&gt;rectangle&lt;/code&gt; parameter, because all function parameters are immutable by default. In order to change it, we create a mutable copy using &lt;code&gt;var&lt;/code&gt;, call &lt;code&gt;translate&lt;/code&gt; and return the changed value. Then we need to re-assign it to &lt;code&gt;screen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func moveByTenTen(rectangle: Rectangle) -&amp;gt; Rectangle {
    var changed = rectangle
    changed.translate(by: Point(x: 10, y: 10))
    return changed
}
screen = moveByTenTen(rectangle: screen)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How could we write a function that changes the &lt;code&gt;rectangle&lt;/code&gt; in place? Thinking back, the &lt;code&gt;mutating&lt;/code&gt; keyword did exactly that. It makes the implicit &lt;code&gt;self&lt;/code&gt; parameter mutable, and it changes the value of the variable.&lt;/p&gt;

&lt;p&gt;In functions, we can mark parameters as &lt;code&gt;inout&lt;/code&gt;. Just like with a regular parameter, a copy of the value gets passed in to the function. However, we can change the copy (it&amp;rsquo;s as if it were defined as a &lt;code&gt;var&lt;/code&gt;). And once the function returns, the original value gets overwritten:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func moveByTwentyTwenty(rectangle: inout Rectangle) {
    rectangle.translate(by: Point(x: 20, y: 20))
}
moveByTwentyTwenty(rectangle: &amp;amp;screen)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;moveByTwentyTwenty&lt;/code&gt; function takes the &lt;code&gt;screen&lt;/code&gt; rectangle, changes it locally, and copies the new value back (overriding the previous value of &lt;code&gt;screen&lt;/code&gt;). This behavior is exactly the same as a &lt;code&gt;mutating&lt;/code&gt; method. In fact, &lt;code&gt;mutating&lt;/code&gt; methods are just like regular methods on struct, except that &lt;code&gt;self&lt;/code&gt; is marked as &lt;code&gt;inout&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just to make sure, we cannot call &lt;code&gt;moveByTwentyTwenty&lt;/code&gt; on a rectangle that&amp;rsquo;s defined using &lt;code&gt;let&lt;/code&gt;. We can only use it with mutable values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-highlight-swift&#34;&gt;let immutableScreen = screen
moveByTwentyTwenty(rectangle: &amp;amp;immutableScreen) // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it also makes sense how we could define a mutating operator like &lt;code&gt;+=&lt;/code&gt;. Such operators modify the left-hand side by adding the right-hand side:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func +=(lhs: inout Point, rhs: Point) {
    lhs = lhs + rhs
}
var myPoint = Point.origin
myPoint += Point(x: 10, y: 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;a href=&#34;#functions&#34;&gt;Functions&lt;/a&gt; chapter, we will go into more detail about &lt;code&gt;inout&lt;/code&gt;. For now, it suffices to say that &lt;code&gt;inout&lt;/code&gt; is in lots of places. For example, it&amp;rsquo;s now easy to understand how modifying a subscript works:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var array = [Point(x: 0, y: 0), Point(x: 10, y: 10)]
array[0] += Point(x: 100, y: 100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The expression &lt;code&gt;array[0]&lt;/code&gt; is automatically passed in as an &lt;code&gt;inout&lt;/code&gt; variable. In the Functions chapter, we will look in more detail at &lt;code&gt;inout&lt;/code&gt; parameters, and see why we can use expressions like &lt;code&gt;array[0]&lt;/code&gt; as an &lt;code&gt;inout&lt;/code&gt; parameter.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Protocols in Swift</title>
          <link>http://chris.eidhof.nl/post/protocols-in-swift/</link>
          <pubDate>Fri, 12 Aug 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/protocols-in-swift/</guid>
          <description>&lt;p&gt;Let&amp;rsquo;s say we are writing our own data-structure, a singly linked list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;enum ListNode&amp;lt;A&amp;gt; {
    case end
    indirect case cons(A, ListNode)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Today&amp;rsquo;s goal is to make &lt;code&gt;ListNode&lt;/code&gt; conform to the &lt;code&gt;Collection&lt;/code&gt; protocol. It&amp;rsquo;s actually fairly easy, but it&amp;rsquo;s almost impossible to figure it out by just looking at the types. The documentation tells us which methods to implement, but why is it like that? Even though the protocol is clearly specified, it&amp;rsquo;s not so easy to see what you need to do. Let&amp;rsquo;s give it a try without looking at the documentation, and see what the compiler tells us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ListNode: Collection { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler tells us we don&amp;rsquo;t conform to the following three protocols: &lt;code&gt;Sequence&lt;/code&gt;, &lt;code&gt;IndexableBase&lt;/code&gt;, and &lt;code&gt;Collection&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Looking at all these protocols, you might get overwhelmed. The most complicated one, &lt;code&gt;Collection&lt;/code&gt;, comes in at a whopping four associated types, two subscripts, four computed properties and seven methods. A protocol is a formal &amp;ldquo;todo-list&amp;rdquo; of all the things your type needs to do in order to conform. I copy/pasted this from the Standard Library, and removed all the documentation comments. With the documentation comments, it gets even harder to see!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol Collection : Indexable, Sequence {
    associatedtype IndexDistance : SignedInteger = Int
    associatedtype Iterator : IteratorProtocol = IndexingIterator&amp;lt;Self&amp;gt;
    associatedtype SubSequence : IndexableBase, Sequence = Slice&amp;lt;Self&amp;gt;
    associatedtype Indices : IndexableBase, Sequence = DefaultIndices&amp;lt;Self&amp;gt;
    public subscript(position: Self.Index) -&amp;gt; Self.Iterator.Element { get }
    public subscript(bounds: Range&amp;lt;Self.Index&amp;gt;) -&amp;gt; Self.SubSequence { get }
    public var indices: Self.Indices { get }
    public var isEmpty: Bool { get }
    public var count: Self.IndexDistance { get }
    public var first: Self.Iterator.Element? { get }
    public func makeIterator() -&amp;gt; Self.Iterator
    public func prefix(upTo end: Self.Index) -&amp;gt; Self.SubSequence
    public func suffix(from start: Self.Index) -&amp;gt; Self.SubSequence
    public func prefix(through position: Self.Index) -&amp;gt; Self.SubSequence
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -&amp;gt; Self.Index
    public func index(_ i: Self.Index, offsetBy n: Self.IndexDistance, limitedBy limit: Self.Index) -&amp;gt; Self.Index?
    public func distance(from start: Self.Index, to end: Self.Index) -&amp;gt; Self.IndexDistance
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting thing is: all associated types have default values. So if we decide to stick with them, we can cross those off of the todo-list, and fill the other parameters with their types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol Collection : Indexable, Sequence {
    public subscript(position: Self.Index) -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;.Element { get }
    public subscript(bounds: Range&amp;lt;Self.Index&amp;gt;) -&amp;gt; Slice&amp;lt;Self&amp;gt; { get }
    public var indices: DefaultIndices&amp;lt;Self&amp;gt; { get }
    public var isEmpty: Bool { get }
    public var count: Int { get }
    public var first: IndexingIterator&amp;lt;Self&amp;gt;.Element? { get }
    public func makeIterator() -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;
    public func prefix(upTo end: Self.Index) -&amp;gt; Slice&amp;lt;Self&amp;gt;
    public func suffix(from start: Self.Index) -&amp;gt; Slice&amp;lt;Self&amp;gt;
    public func prefix(through position: Self.Index) -&amp;gt; Slice&amp;lt;Self&amp;gt;
    public func index(_ i: Self.Index, offsetBy n: Int) -&amp;gt; Self.Index
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -&amp;gt; Self.Index?
    public func distance(from start: Self.Index, to end: Self.Index) -&amp;gt; Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many of the properties and methods have default implementations as well. For example, here are the default extensions on &lt;code&gt;Collection&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Collection {
    public func map&amp;lt;T&amp;gt;(_ transform: @noescape (Self.Iterator.Element) throws -&amp;gt; T) rethrows -&amp;gt; [T]
    public func dropFirst(_ n: Int) -&amp;gt; Self.SubSequence
    public func dropLast(_ n: Int) -&amp;gt; Self.SubSequence
    public func prefix(_ maxLength: Int) -&amp;gt; Self.SubSequence
    public func suffix(_ maxLength: Int) -&amp;gt; Self.SubSequence
    public func prefix(upTo end: Self.Index) -&amp;gt; Self.SubSequence
    public func suffix(from start: Self.Index) -&amp;gt; Self.SubSequence
    public func prefix(through position: Self.Index) -&amp;gt; Self.SubSequence
    public func split(maxSplits: Int = default, omittingEmptySubsequences: Bool = default, whereSeparator isSeparator: @noescape (Self.Iterator.Element) throws -&amp;gt; Bool) rethrows -&amp;gt; [Self.SubSequence]
    public func index(where predicate: @noescape (Self.Iterator.Element) throws -&amp;gt; Bool) rethrows -&amp;gt; Self.Index?
}

extension Collection {
    public var isEmpty: Bool { get }
    public var first: Self.Iterator.Element? { get }
    public var underestimatedCount: Int { get }
    public var count: Self.IndexDistance { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These default extensions allow us to cross the &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;suffix&lt;/code&gt; methods off of our list. Our todo-list is now a bit shorter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol Collection : Indexable, Sequence {
    public subscript(position: Self.Index) -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;.Element { get }
    public subscript(bounds: Range&amp;lt;Self.Index&amp;gt;) -&amp;gt; Slice&amp;lt;Self&amp;gt; { get }
    public var indices: DefaultIndices&amp;lt;Self&amp;gt; { get }
    public func makeIterator() -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;
    public func index(_ i: Self.Index, offsetBy n: Int) -&amp;gt; Self.Index
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -&amp;gt; Self.Index?
    public func distance(from start: Self.Index, to end: Self.Index) -&amp;gt; Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are more extensions that apply, though. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension Collection where SubSequence == Slice&amp;lt;Self&amp;gt; {
    public subscript(bounds: Range&amp;lt;Self.Index&amp;gt;) -&amp;gt; Slice&amp;lt;Self&amp;gt; { get }
}
extension Collection where Indices == DefaultIndices&amp;lt;Self&amp;gt; {
    public var indices: DefaultIndices&amp;lt;Self&amp;gt; { get }
}
extension Collection where Iterator == IndexingIterator&amp;lt;Self&amp;gt; {
    public func makeIterator() -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because all three apply, we can get rid of three more todos. Our list is getting shorter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol Collection : Indexable, Sequence {
    public subscript(position: Self.Index) -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;.Element { get }
    public func index(_ i: Self.Index, offsetBy n: Int) -&amp;gt; Self.Index
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -&amp;gt; Self.Index?
    public func distance(from start: Self.Index, to end: Self.Index) -&amp;gt; Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start adding the &lt;code&gt;Indexable&lt;/code&gt; requirements to our todo-list, we end up with a long list again. We now also need to conform to IndexableBase.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol Collection : IndexableBase, Sequence {
    public subscript(position: Self.Index) -&amp;gt; IndexingIterator&amp;lt;Self&amp;gt;.Element { get }
    public func index(_ i: Self.Index, offsetBy n: Int) -&amp;gt; Self.Index
    public func index(_ i: Self.Index, offsetBy n: Int, limitedBy limit: Self.Index) -&amp;gt; Self.Index?
    public func distance(from start: Self.Index, to end: Self.Index) -&amp;gt; Int
    associatedtype Index : Comparable
    public var startIndex: Self.Index { get }
    public var endIndex: Self.Index { get }
    public subscript(position: Self.Index) -&amp;gt; Self._Element { get }
    associatedtype SubSequence
    public subscript(bounds: Range&amp;lt;Self.Index&amp;gt;) -&amp;gt; Self.SubSequence { get }
    public func index(after i: Self.Index) -&amp;gt; Self.Index
    public func formIndex(after i: inout Self.Index)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, after removing all default implementations that are provided by collection, and using all extension that apply to our current protocol, we can cross out almost all the newly added &lt;code&gt;Indexable&lt;/code&gt; requirements (many have a default implementation). We can keep playing the game of looking at the extensions, crossing out requirements, adding new ones, until we finally end up with a minimal set of things we need to do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public protocol Collection {
    associatedtype Index : Comparable
    public var startIndex: Self.Index { get }
    public var endIndex: Self.Index { get }
    public func index(after i: Self.Index) -&amp;gt; Self.Index
    public subscript(position: Self.Index) -&amp;gt; Element { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lo and behold, we can make &lt;code&gt;ListNode&lt;/code&gt; conform:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension ListNode: Collection {
    var startIndex: Int { return 0 }
    /// This is 0(n), not the expected O(1) from `Collection`.
    var endIndex: Int {
        switch self {
        case .end: return 0
        case .cons(_, let tail): return 1 + tail.endIndex
        }
    }
    func index(after: Int) -&amp;gt; Int {
        return after+1
    }
    /// This is 0(n), not the expected O(1) from `Collection`.
    subscript(position: Int) -&amp;gt; A {
        switch (self, position) {
        case (.end, _): fatalError(&amp;quot;Index out of bounds&amp;quot;)
        case (.cons(let x, _), 0): return x
        case (.cons(_, let tail), _): return tail[position-1]
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we didn&amp;rsquo;t have to specify the &lt;code&gt;associatedtype&lt;/code&gt;, the compiler inferred this for us.&lt;/p&gt;

&lt;p&gt;Long story short: it&amp;rsquo;s really hard to see what you need to conform to. Or to be more precise: it&amp;rsquo;s not that hard, it&amp;rsquo;s just a &lt;em&gt;lot&lt;/em&gt; of manual work. Luckily, all of this can be completely automated. Unfortunately, the tooling in this respect is currently still very immature, even though the standard library isn&amp;rsquo;t. I have no idea if this will improve soon.&lt;/p&gt;

&lt;p&gt;Rather than waiting for Apple to fix this, maybe someone in the community could do this? I imagine it&amp;rsquo;s a few days of hard work: first you need to parse all the protocols in the standard library (or better: use SourceKit, because then you can also make it work on your own protocols). Then you need to have some kind of evaluation system that checks which extensions can be applied. It might need to be interactive, for example, once you specify that the &lt;code&gt;Index&lt;/code&gt; associated type will be an &lt;code&gt;Int&lt;/code&gt;, it could tell you what you still need to implement.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d love to build this myself, however, I&amp;rsquo;m currently too busy writing the update of &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;, and preparing new &lt;a href=&#34;https://talk.objc.io&#34;&gt;Swift Talk episodes&lt;/a&gt;. It would be the perfect procrastination project&amp;hellip;&lt;/p&gt;

&lt;p&gt;Update: Nicola &lt;a href=&#34;https://twitter.com/NSalmoria/status/764158023124258817&#34;&gt;writes in&lt;/a&gt; that &amp;ldquo;Conforming to the Collection Protocol&amp;rdquo; is actually a section of the &lt;a href=&#34;https://developer.apple.com/reference/swift/collection&#34;&gt;API documentation&lt;/a&gt;. Very good point. He also raises the point that my &lt;code&gt;endIndex&lt;/code&gt; and &lt;code&gt;subscript&lt;/code&gt; implementations aren&amp;rsquo;t &lt;code&gt;O(1)&lt;/code&gt;, which is the expected complexity as described in the &lt;code&gt;Collection&lt;/code&gt; protocol.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Responder Chain Alternatives</title>
          <link>http://chris.eidhof.nl/post/responder-chain-alternative/</link>
          <pubDate>Fri, 03 Jun 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/responder-chain-alternative/</guid>
          <description>&lt;p&gt;There&amp;rsquo;s been some recent talk about the &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW2&#34;&gt;responder chain&lt;/a&gt;. The responder chain works on a tree structure: the view hierarchy plus some other things. An event or action gets sent to a certain view (a node in the tree structure). Until it gets handled, it moves up the tree towards the root, going through all superviews, all the way until the &lt;code&gt;NSWindow&lt;/code&gt;, up to the &lt;code&gt;NSWindowController&lt;/code&gt;. You can even modify this tree structure, and insert your own responders. Depending on what you&amp;rsquo;re building (e.g. a document-based application), the responder chain can even be more advanced.&lt;/p&gt;

&lt;p&gt;The responder chain is really powerful, and saves you from writing boilerplate. It is built on top of runtime programming. For example, an action consists of a selector (in other words: a string) and the sender object. Using introspection, the application tries to dispatch an action through the responder chain, starting with the first responder, all the way up until some object handles the event.&lt;/p&gt;

&lt;p&gt;When you create a new Mac application, it comes with a menu by default. The menu items in send actions, for example, &lt;code&gt;paste:&lt;/code&gt;. If you want to implement paste support, it&amp;rsquo;s really easy. The only thing you&amp;rsquo;ll have to do (besides the domain logic of pasting) is implement a &lt;code&gt;paste:&lt;/code&gt; method somewhere in an object that will be in the responder chain. That&amp;rsquo;s it. Menu items can even be enabled and disabled automatically if you implement &lt;code&gt;validateMenuItem:&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is easy to write, but you do pay a price: maintaining these actions is more difficult than writing them. It&amp;rsquo;s hard to change code: if you ever want to refactor (for example, if you choose to rename the action), you&amp;rsquo;ll have to be very careful to change it in all places in your code, and in the Interface Builder file. If you forget to change things in one place, Interface Builder might be able to tell you this. But not always.&lt;/p&gt;

&lt;p&gt;The responder chain is easy, but it&amp;rsquo;s not simple&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:simpleasy&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:simpleasy&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. There is a lot of magic behind the scenes. It makes it hard to change your code. In addition, the responder chain on the Mac is complex: you need to have the order of the chain in your head (or read the documentation) to work effectively. You need to know your view hierarchy, and changes you intend to be local can accidentally be global.&lt;/p&gt;

&lt;p&gt;The responder chain is cool, but I&amp;rsquo;m not sure if we need to replicate it in Swift. Rather, we could try to think of a way that is just as easy as the responder chain, but also &lt;em&gt;simple&lt;/em&gt;. It should be easy to refactor code. It should be easy to understand. It should be easy to debug. In order to make a local change, you shouldn&amp;rsquo;t have to worry about the global effects. I&amp;rsquo;m not sure if we can solve all these issues, but I&amp;rsquo;m pretty sure we can solve a few of them.&lt;/p&gt;

&lt;p&gt;(Functional) Reactive Programming&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; might be one solution to this. I&amp;rsquo;m not sure, because I have never applied FRP in production. The idea behind FRP is simple (and easy), but all implementations I&amp;rsquo;ve tried aren&amp;rsquo;t easy, nor simple. I think a React-like architecture is really cool, it&amp;rsquo;s simple, it&amp;rsquo;s easy, but then you want to do animations: not so easy.&lt;/p&gt;

&lt;p&gt;In short, I don&amp;rsquo;t know a good alternative to the responder chain. I don&amp;rsquo;t think FRP will be a silver bullet. For now, we can keep using the responder chain anyway, because Cocoa and Objective-C are probably not going anywhere&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:lindy&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:lindy&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Sometimes, I hope that the answer comes when the Interface Builder team starts talking to the SourceKit API, and really leverage all this deep knowledge about the current program. In the mean time, we can try to come up with solutions ourselves, by keeping the following in mind: it should not only be easy, but also simple.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:simpleasy&#34;&gt;See Rich Hickey&amp;rsquo;s amazing &lt;a href=&#34;https://www.infoq.com/presentations/Simple-Made-Easy&#34;&gt;presentation&lt;/a&gt;, or read the &lt;a href=&#34;https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md&#34;&gt;transcript&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:simpleasy&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;It&amp;rsquo;s not so much about the functional part of FRP, but more about the reactive part, as pointed out by &lt;a href=&#34;https://twitter.com/simjp/status/738830379298131969&#34;&gt;JP&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:lindy&#34;&gt;If I understand the &lt;a href=&#34;https://en.wikipedia.org/wiki/Lindy_effect&#34;&gt;Lindy effect&lt;/a&gt; correctly, Cocoa might be around for 30 more years&amp;hellip;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:lindy&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Undo History in Swift</title>
          <link>http://chris.eidhof.nl/post/undo-history-in-swift/</link>
          <pubDate>Mon, 30 May 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/undo-history-in-swift/</guid>
          <description>&lt;p&gt;Over the last weeks, there have been a number of blog posts that want to add dynamic behavior to Swift. Swift is already a very dynamic language: it has generics, protocols, first-class functions, and the standard library is filled with functions like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;, which dynamically get their operation (not using a string like with KVC, but using a function, which is safer and more flexible). Most of the people that say they want dynamic behavior mean that they &lt;a href=&#34;http://inessential.com/2016/05/26/a_definition_of_dynamic_programming_in_t&#34;&gt;want reflection&lt;/a&gt; specifically: they want to analyze and modify the program at runtime.&lt;/p&gt;

&lt;p&gt;In Swift, there is only a very limited reflection mechanism, although you can already inspect and generate code at runtime. For example, here&amp;rsquo;s how to generate a dictionary ready for &lt;code&gt;NSCoding&lt;/code&gt; or JSON serialization: &lt;a href=&#34;http://chris.eidhof.nl/post/swift-mirrors-and-json/&#34;&gt;Swift mirrors and JSON&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, we&amp;rsquo;ll have a look at implementing undo functionality in Swift. One of the examples people keep bringing up to make the case for reflection (the way Objective-C) supports it is &lt;code&gt;NSUndoManager&lt;/code&gt;.  With struct semantics, we can add undo support to our apps in a different way. Before we get started, make sure that you understand how structs work in Swift (most importantly, how they are all unique copies). Clearly, this post will not remove the need for runtime programming in Swift, nor is it a replacement for &lt;code&gt;NSUndoManager&lt;/code&gt;. It&amp;rsquo;s just a simple example of how to think different.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll build a struct called &lt;code&gt;UndoHistory&lt;/code&gt;. It&amp;rsquo;s generic, with the caveat that it only works when &lt;code&gt;A&lt;/code&gt; is a struct. To keep a history of all the states, we can store every value in an array. Whenever we want to change something, we just push onto the array, and whenever we want to undo, we pop from the array. We always want to start with an initial state, so we create an initializer for that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct UndoHistory&amp;lt;A&amp;gt; {
    private let initialValue: A
    private var history: [A] = []
    init(initialValue: A) {
        self.initialValue = initialValue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, if we want to add undo support to a table view controller that&amp;rsquo;s backed by an array, we can create a value of this struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var history = UndoHistory(initialValue: [1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To support undo for a different struct, we just start with a different initial value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Person {
    var name: String
    var age: Int
}

var personHistory = UndoHistory(initialValue: Person(name: &amp;quot;Chris&amp;quot;, age: 31))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we want to have a way of getting the current state, and setting the current state (in other words: adding an item to our history). To get the current state, we simply return the last item in our &lt;code&gt;history&lt;/code&gt; array, and if the array is empty, we return the initial value. To set the current state, we simply append to our &lt;code&gt;history&lt;/code&gt; array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UndoHistory {
    var currentItem: A {
        get {
            return history.last ?? initialValue
        }
        set {
            history.append(newValue)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, if we want to change the person&amp;rsquo;s age, we can easily do that through our new computed property:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;personHistory.currentItem.age += 1
personHistory.currentItem.age // Prints 32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the code isn&amp;rsquo;t complete without an &lt;code&gt;undo&lt;/code&gt; method. This is as simple as removing the last item from the array. Depending on your preference, you could also make it &lt;code&gt;throw&lt;/code&gt; when the undo stack is empty, but I&amp;rsquo;ve chosen not to do that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;extension UndoHistory {
    mutating func undo() {
        guard !history.isEmpty else { return }
        history.removeLast()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using it is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;personHistory.undo()
personHistory.currentItem.age // Prints 31 again
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, our &lt;code&gt;UndoHistory&lt;/code&gt; works on more than just simple &lt;code&gt;Person&lt;/code&gt; structs. For example, if we want to create a table view controller that&amp;rsquo;s backed by an &lt;code&gt;Array&lt;/code&gt;, we can use the &lt;code&gt;currentItem&lt;/code&gt; property to get the array out &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class MyTableViewController&amp;lt;Item&amp;gt;: UITableViewController {
    var data: UndoHistory&amp;lt;[Item]&amp;gt;
    
    init(value: [Item]) {
        data = UndoHistory(initialValue: value)
        super.init(style: .Plain)
    }
    
    override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
        return data.currentItem.count
    }
    
    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell {
        let cell = tableView.dequeueReusableCellWithIdentifier(&amp;quot;Identifier&amp;quot;, forIndexPath: indexPath)
        let item = data.currentItem[indexPath.row]
        // configure `cell` with `item`
        return cell
    }

    override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
        guard editingStyle == .Delete else { return }
        data.currentItem.removeAtIndex(indexPath.row)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another thing that is really cool with struct semantics: we get observation for free. For example, we could change the definition of &lt;code&gt;data&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var data: UndoHistory&amp;lt;[Item]&amp;gt; {
    didSet {
        tableView.reloadData()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even if we change something deep inside the array (e.g. &lt;code&gt;data.currentItem[17].name = &amp;quot;John&amp;quot;&lt;/code&gt;) our &lt;code&gt;didSet&lt;/code&gt; will get triggered. Of course, we probably want to do something a little bit smarter than &lt;code&gt;reloadData&lt;/code&gt;. For example, we could use the &lt;a href=&#34;https://github.com/osteslag/Changeset&#34;&gt;Changeset&lt;/a&gt; library to compute a diff and have insert/delete/move animations&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Obviously, this approach has its drawbacks too. For example, it keeps a full history of the state, rather than a diff. It only works with structs (to be precise: only with structs that have value semantics). That said, you do not have to read the &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html&#34;&gt;runtime programming guide&lt;/a&gt;, you only need to have a good grasp of structs and generics to come up with this solution &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;It would probably be nice to define a computed property &lt;code&gt;items&lt;/code&gt; which just gets and sets &lt;code&gt;data.currentItem&lt;/code&gt;. This makes the data source / delegate method implementations much nicer.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;If you want to take this further, there are a couple of fun exercises: try adding redo support, or labeled actions. You can implement reordering in the table view, and you will see that if you do it naively, you&amp;rsquo;ll end up with two entries in your undo history.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;In &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt; we go into way much more detail on these and many other topics.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Dynamic Swift</title>
          <link>http://chris.eidhof.nl/post/dynamic-swift/</link>
          <pubDate>Thu, 26 May 2016 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/dynamic-swift/</guid>
          <description>&lt;p&gt;Recently, &lt;a href=&#34;http://inessential.com&#34;&gt;Brent&lt;/a&gt; and others wrote a lot about the lack of dynamic features&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; in Swift. I tried distilling Brent&amp;rsquo;s thoughts, and came up with the following summary:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s easy to write code in AppKit and UIKit, because many things just work, without having to write a lot of code.&lt;/li&gt;
&lt;li&gt;AppKit/UIKit are written in Objective-C, and use runtime programming to remove boilerplate.&lt;/li&gt;
&lt;li&gt;Therefore, we either need these same features in Swift, or need to find a different way of solving some problems.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think we don&amp;rsquo;t need all the runtime programming features from Objective-C.&lt;/p&gt;

&lt;p&gt;As long as AppKit and UIKit will be around, we&amp;rsquo;ll have Objective-C and its runtime. If Apple releases a Swift-only successor to either one of these frameworks, I&amp;rsquo;m confident that they will do a good job: they&amp;rsquo;ll make us write less boilerplate, rather than more.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at a completely different context: web programming. I&amp;rsquo;ve seen amazing web frameworks that rely a lot on runtime programming (stuff like Rails, but also &lt;a href=&#34;http://seaside.st&#34;&gt;Seaside&lt;/a&gt;, back in its day). But, there are web frameworks in languages like Haskell, Scala and C# that use features like protocols, datatype-generic programming&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; and passing around functions to reduce boilerplate. With both approaches you can get short, simple, maintainable code that&amp;rsquo;s easy to write.&lt;/p&gt;

&lt;p&gt;Yet, techniques you don&amp;rsquo;t know will almost always seem more complicated at first. I tried arguing with a Haskell programmer that runtime programming can be useful. I tried arguing with a Ruby programmer that static types can be helpful. To both, it seemed unnecessary and complicated. They&amp;rsquo;ve been writing great code without those features.&lt;/p&gt;

&lt;p&gt;Brent, if you read this, I&amp;rsquo;d like to offer you a free copy of my books. Just send me an email. There are some techniques in there that will show how to replace runtime programming with things like functions, or protocols. These techniques definitely won&amp;rsquo;t solve all your problems. I do think they will show you some ways in which you can write short, simple, and maintainable code in Swift today, without having to resort to runtime programming.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;To have a productive discussion, I think it&amp;rsquo;s important to understand about which dynamic features we are speaking. Dynamic can mean so many different things: KVO/KVC, late binding, subclassing, swizzling, dependency injection, reflection, runtime casting, and so on. Because the word dynamic means different things to different people, the discussion has been (and will be) hand-wavy. Swift has a lot of dynamic features, but they are different: protocols, safe runtime casting, passing around functions, and so on.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Datatype-generic programming is a cool technique in functional programming. It allows you to write methods that operate on the structure of the data. For example, it would let you write something like an NSCoder implementation that works on all structs and classes. It&amp;rsquo;s much the same as writing it using runtime introspection, except that it&amp;rsquo;s type-safe, and more importantly, the compiler can help you catch mistakes. Unfortunately, datatype-generic programming isn&amp;rsquo;t yet (but almost!) possible in Swift.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Rejected Swift Proposals</title>
          <link>http://chris.eidhof.nl/post/rejected-swift-proposals/</link>
          <pubDate>Fri, 22 Apr 2016 15:46:42 CEST</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/rejected-swift-proposals/</guid>
          <description>

&lt;p&gt;Not too long ago, we finally shipped &lt;a href=&#34;http://www.objc.io/books/advanced-swift&#34;&gt;Advanced Swift&lt;/a&gt;. It was a long process, but I&amp;rsquo;m really happy about the result. Just before we finished it, Swift became open-source, the mailing lists opened up, and many GitHub repositories appeared.&lt;/p&gt;

&lt;p&gt;At first, I subscribed to all the mailing lists, and added a filter to move them into a separate folder. There was so much discussion that I couldn&amp;rsquo;t keep up at all - at least not while finishing the book. I was so overwhelmed that I completely stopped reading the lists, let alone participate in the discussions.&lt;/p&gt;

&lt;p&gt;In the next edition of Advanced Swift (the update for Swift 3) we want to include a chapter about the history of Swift. At the beginning of this week, I set aside a day to read through all current proposals in detail. Not only to understand what is coming up, but also to learn what got rejected. With most rejections, the core team included a good rationale that can help us understand how they see the language evolve.&lt;/p&gt;

&lt;p&gt;One interesting thing I found while going through all proposals is the ever-present discussion about &amp;ldquo;readability&amp;rdquo;. I&amp;rsquo;m convinced more than ever that readability is subjective in many cases.&lt;/p&gt;

&lt;p&gt;I am going to write a series of posts about all the proposals. First off, let&amp;rsquo;s start with all the rejected proposals. Here, it&amp;rsquo;s especially interesting to see why they got rejected, and I&amp;rsquo;ve selectively quoted the rationales given by the core team.&lt;/p&gt;

&lt;h2 id=&#34;se-0009-require-self-for-accessing-instance-members-https-github-com-apple-swift-evolution-blob-master-proposals-0009-require-self-for-accessing-instance-members-md&#34;&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&#34;&gt;SE-0009 Require self for accessing instance members&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This proposal wants to make &lt;code&gt;self.&lt;/code&gt; mandatory for all instance members. The author feels that requiring &lt;code&gt;self.&lt;/code&gt; increases readability, and make everything more consistent.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mandatory “self.” introduces a significant amount of verbosity that does not justify itself with added clarity. While it is true that mandatory “self.” may prevent a class of bugs, the cost of eliminating those bugs is fairly high in terms of visual clutter, which goes against the generally uncluttered feel of Swift. Paul Cantrell put it well in his review &lt;a href=&#34;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002910.html&#34;&gt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002910.html&lt;/a&gt; when he said, “anything that is widely repeated becomes invisible.” Swift aims to avoid such boilerplate and repetition in its design, a principle also espoused by the Swift API Design Guidelines &lt;a href=&#34;https://swift.org/documentation/api-design-guidelines.html&#34;&gt;https://swift.org/documentation/api-design-guidelines.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The requirement to use “self.” within potentially-escaping closures is a useful indicator of the potential for retain cycles that we don’t want to lose. Additionally, developers can optionally use “self.” when they feel it improves clarity (e.g., when similar operations are being performed on several different instances, of which “self” is one).&lt;/p&gt;

&lt;p&gt;The name-shadowing concerns behind the mandatory “self.” apply equally well to anything found by unqualified name lookup, including names found in the global scope. To call out members of types as requiring qualification while global names do not (even when global names tend to be far more numerous) feels inconsistent, but requiring qualification for everything (e.g., “Swift.print”, “self.name”) exacerbates the problem of visual clutter.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005478.html&#34;&gt;Rationale&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The author of the proposal feels that requiring &lt;code&gt;self.&lt;/code&gt; makes the code more readable. I can see why, yet still feel the opposite. This is one of those cases where we can hardly say anything objective about it being more readable, instead, we should probably say &amp;ldquo;it&amp;rsquo;s more readable for me&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;se-0010-add-staticstring-unicodescalarview-https-github-com-apple-swift-evolution-blob-master-proposals-0010-add-staticstring-unicodescalarview-md&#34;&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0010-add-staticstring-unicodescalarview.md&#34;&gt;SE-0010 Add StaticString.UnicodeScalarView&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This proposal wants to make it possible to make static substrings of &lt;code&gt;StaticString&lt;/code&gt; by adding a new type &lt;code&gt;StaticString.UnicodeScalarView&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;While the addition of StaticString.UnicodeScalarView is a useful feature by itself, the core team felt that it would be inconsistent just to add this narrow set of APIs for Unicode scalars. (&amp;hellip;) If StaticString is to gain Unicode support, it should be done comprehensively, not piecemeal. Moreover, &lt;em&gt;with the aforementioned String re-evaluation underway&lt;/em&gt;, it is possible that StaticString itself might change considerably or even be obsoleted.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thread.gmane.org/gmane.comp.lang.swift.evolution/7697&#34;&gt;Rationale&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Emphasis mine: strings are being re-evaluated. I&amp;rsquo;m not sure what will happen to the &lt;code&gt;String&lt;/code&gt; type. I can imagine that it could get simpler somehow.&lt;/p&gt;

&lt;h2 id=&#34;se-0027-expose-code-unit-initializers-on-string-https-github-com-apple-swift-evolution-blob-master-proposals-0027-string-from-code-units-md&#34;&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&#34;&gt;SE-0027 Expose code unit initializers on String&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This proposal wants to make it easier to build Swift strings from C strings.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At this point, the core team feels that we have not fully explored the design space here, and that known alternatives (e.g., making the UTF-16 and UTF-32 views of a String mutable collections) might provide a better long-term solution. Moreover, the String type itself is undergoing a significant re-evaluation, so the core team feels that improvements to String should be delayed until the newer design is better understood.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thread.gmane.org/gmane.comp.lang.swift.evolution/7695&#34;&gt;Rationale&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Just like before, it seems like big changes will happen to the &lt;code&gt;String&lt;/code&gt; type.&lt;/p&gt;

&lt;h2 id=&#34;se-0024-optional-value-setter-https-github-com-apple-swift-evolution-blob-master-proposals-0024-optional-value-setter-md&#34;&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0024-optional-value-setter.md&#34;&gt;SE-0024 Optional Value Setter &lt;code&gt;??=&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This proposal wants to add another setter, &lt;code&gt;??=&lt;/code&gt;, which sets the left-hand side to the value of the right-hand side (but only if the left-hand side is &lt;code&gt;nil&lt;/code&gt;).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The proposal is rejected. While the ‘??=‘ operator’s semantics are clear and fit with other compound assignment operators, the use cases are not strong enough to motivate inclusion of this operator. &lt;a href=&#34;http://thread.gmane.org/gmane.comp.lang.swift.evolution/6895&#34;&gt;Radek’s lukewarm +0.5 review&lt;/a&gt; captures the sentiment of the core team fairly well (as was echoed by others): one very common use case in the Ruby’s similar ||= operator is to assign a default value to an optional parameter or a local variable. However, neither case works well in Swift because ??= does not erase the optionality of the variable (and cannot be used to change a parameter now that var has been removed from parameters). Property access and subscripting could still benefit from ??=, but the latter case is likely to be handled better by a Dictionary subscript operator that can substitute a default value (see, e.g., &lt;a href=&#34;http://thread.gmane.org/gmane.comp.lang.swift.evolution/6895&#34;&gt;Joe Groff’s suggestion&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://article.gmane.org/gmane.comp.lang.swift.evolution/7694&#34;&gt;Rationale&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;rsquo;ve used &lt;code&gt;||=&lt;/code&gt; in Ruby as well, and really like it there. But with Swift&amp;rsquo;s Optionals, I never felt the need for this. As an aside, the mentioned dictionary subscript operator is really cool. We use it in the functions chapter of Advanced Swift, in a way very similar to this: &lt;a href=&#34;https://twitter.com/AirspeedSwift/status/626701244455895044&#34;&gt;https://twitter.com/AirspeedSwift/status/626701244455895044&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;se-0018-flexible-memberwise-initialization-https-github-com-apple-swift-evolution-blob-master-proposals-0018-flexible-memberwise-initialization-md-draft&#34;&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md&#34;&gt;SE-0018 Flexible Memberwise Initialization&lt;/a&gt; (Draft)&lt;/h2&gt;

&lt;p&gt;This was a really long proposal, and really long rejection &lt;a href=&#34;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160111/006469.html&#34;&gt;rationale&lt;/a&gt; mail. It&amp;rsquo;s about the automatic memberwise initializers that get generated (e.g. when you create a struct). The proposal wants to make this possible in more places, and make it easier to control this. The core team decided that it isn&amp;rsquo;t in scope for Swift 3. An interesting meta-point they raised it that the length of the proposal was off-putting for many people. Another thing I learned is that the Swift team really strives for predictable models. You can also see this in the accepted proposals, there are a few that really make the language more predictable and consistent (e.g. &lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md&#34;&gt;named first parameters&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;se-0056-allow-trailing-closures-in-guard-conditions-https-github-com-apple-swift-evolution-blob-master-proposals-0056-trailing-closures-in-guard-md&#34;&gt;&lt;a href=&#34;https://github.com/apple/swift-evolution/blob/master/proposals/0056-trailing-closures-in-guard.md&#34;&gt;SE-0056 Allow trailing closures in guard conditions&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This proposal is about letting trailing closures in &lt;code&gt;guard&lt;/code&gt; conditions compile. For example, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let object = someSequence.findElement { $0.passesTest() } else {
  return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currently, it doesn&amp;rsquo;t like the trailing closure when using a &lt;code&gt;guard&lt;/code&gt; (or &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;), and it needs to be written with parentheses around the closure.&lt;/p&gt;

&lt;p&gt;The proposal was &lt;a href=&#34;https://lists.swift.org/pipermail/swift-evolution-announce/2016-April/000108.html&#34;&gt;rejected&lt;/a&gt; with a very short sentence:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The core team felt that the benefits from this change were outweighed by the inconsistency it would introduce with &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Interestingly, it was proposed by Chris Lattner, a member of the core team. Again, I can see how they made the decision. If you look at it from being able to write it in a &lt;code&gt;guard&lt;/code&gt;, it seems like a logical proposal. However, once you can write trailing closures in a &lt;code&gt;guard&lt;/code&gt; condition, you&amp;rsquo;ll probably be surprised that you can&amp;rsquo;t write them in &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In the next post, we&amp;rsquo;ll look at accepted proposals. Stay tuned!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Struct Semantics in Swift</title>
          <link>http://chris.eidhof.nl/post/struct-semantics-in-swift/</link>
          <pubDate>Sun, 30 Aug 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/struct-semantics-in-swift/</guid>
          <description>&lt;p&gt;In our book &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;, we show how to implement your own copy-on-write structs in detail. This blogpost shows the same technique, but in less detail.&lt;/p&gt;

&lt;p&gt;One big difference between Swift strings and Cocoa strings is how they deal with mutability. If you define a Swift string using &lt;code&gt;let&lt;/code&gt;, the compiler enforces immutability: there is no way to change the string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let myString = &amp;quot;immutable string&amp;quot;
myString += &amp;quot; test&amp;quot; // Illegal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Cocoa, the same is done using classes: an &lt;code&gt;NSString&lt;/code&gt; is immutable, and an &lt;code&gt;NSMutableString&lt;/code&gt; is mutable. However, there is a catch: NSMutableString is a subclass of NSString. Therefore, we can do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x: NSMutableString = &amp;quot;Hello&amp;quot;
let y: NSString = x
x.appendString(&amp;quot; world&amp;quot;)
// Now x and y both point to the string &amp;quot;Hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even if we have a variable that&amp;rsquo;s an NSString, we cannot be sure that it&amp;rsquo;s immutable, in order to be completely sure, we need to make a copy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x: NSMutableString = &amp;quot;Hello&amp;quot;
let y: NSString = x.copy() as! NSString
x.appendString(&amp;quot; world&amp;quot;)
// Now x is &amp;quot;Hello world&amp;quot;, and y is &amp;quot;Hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Swift strings, this works a bit differently. Because they are defined as structs, they have copy semantics. If you have a constant string, there is no way it can change under your nose:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = &amp;quot;Hello&amp;quot;
let y = x
x += &amp;quot; world&amp;quot;
// Now x is &amp;quot;Hello world&amp;quot;, and y is still &amp;quot;Hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another advantage of Swift&amp;rsquo;s approach is that both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the same String type. They have methods defined that can mutate the string, but all those methods are marked as &lt;code&gt;mutating&lt;/code&gt;. You simply cannot call them on constant values: the compiler won&amp;rsquo;t let you.&lt;/p&gt;

&lt;p&gt;In order to understand how they work, we will make a wrapper around &lt;code&gt;NSData&lt;/code&gt;. For mutation, &lt;code&gt;NSData&lt;/code&gt; also has a subclass &lt;code&gt;NSMutableData&lt;/code&gt;, but it suffers from the same problem as &lt;code&gt;NSString&lt;/code&gt;: you always have to make a copy if you want to be sure that you the data doesn&amp;rsquo;t change accidentally.&lt;/p&gt;

&lt;p&gt;Before we can start, we will need a small wrapper type: &lt;code&gt;Box&lt;/code&gt;. This can wrap anything, be it a class, or a struct, and the result will be a Swift class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final class Box&amp;lt;A&amp;gt; {
    let unbox: A
    init(_ value: A) { unbox = value }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can create our own &lt;code&gt;Data&lt;/code&gt; struct. It just contains a single field, &lt;code&gt;boxedData&lt;/code&gt;. We also add a convience accessor &lt;code&gt;data&lt;/code&gt; which just unboxes the data. We provide an initializer, which also has a default (empty) value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Data {
    private var boxedData: Box&amp;lt;NSMutableData&amp;gt;
    var data: NSData { return boxedData.unbox }
    init(data: NSData = NSData()) {
        self.boxedData = Box(NSMutableData(data: data))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we&amp;rsquo;ll define some read-only functions: these can be used on immutable values of our struct. They just call their respective methods on &lt;code&gt;NSData&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Data {
    var length: Int { return data.length }
    var bytes: UnsafePointer&amp;lt;Void&amp;gt; {
        return data.bytes
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a mutating variant, we first write a mutating accessor for &lt;code&gt;boxedData&lt;/code&gt;. This accessor makes a copy of the data before returning it. This allows us to implemement &lt;code&gt;append&lt;/code&gt;: whenever we &lt;code&gt;append&lt;/code&gt; to a Swift &lt;code&gt;var&lt;/code&gt;, we now automatically make a copy. This way, our data has the same semantics as other Swift structs such as strings and arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var mutableData: NSMutableData {
    mutating get {
        boxedData = Box(NSMutableData(data: data))
        return boxedData.unbox
    }
}

mutating func append(other: NSData) {
    mutableData.appendData(other)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is one problem with the code above. It is very inefficient. If we define a single variable and mutate it a couple of times, each time the internal data will be copied, even though no other variable is referring to the same data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myData = Data()
myData.append(someOtherData) // copy
myData.append(moreData) // copy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, we can change our &lt;code&gt;mutableData&lt;/code&gt; accessor to prevent copying when there are no other references to the &lt;code&gt;data&lt;/code&gt; variable. To do this, we need to check if the data is uniquely referenced. In other words, we only make a copy of the data if the data is shared. We can do this using the &lt;code&gt;isUniquelyReferencedNonObjC&lt;/code&gt; function. This is the reason why we need &lt;code&gt;Box&lt;/code&gt;: it only works on Swift classes. &lt;code&gt;NSMutableData&lt;/code&gt; is an Objective-C class, and then the function doesn&amp;rsquo;t work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var mutableData: NSMutableData {
    mutating get {
        if !isUniquelyReferencedNonObjC(&amp;amp;boxedData) {
            boxedData = Box(NSMutableData(data: data))
        }
        return boxedData.unbox
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have full copy semantics, and efficient behavior: only when a copy is really necessary, it is made. This way, we never have to remember to write &lt;code&gt;data.copy()&lt;/code&gt; ourselves, we implemented it correctly once and can then forget about it. I think it&amp;rsquo;s probably a matter of time until the Swift Standard Library will get extended with a &lt;code&gt;Data&lt;/code&gt; type, but even then, this technique is very useful when you want to make your own efficient structs by wrapping pointers.&lt;/p&gt;

&lt;p&gt;To test our behavior, we can add some &lt;code&gt;print&lt;/code&gt; statements to the &lt;code&gt;mutableData&lt;/code&gt; accessor, and verify that our behavior is correct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var mutableData: NSMutableData {
    mutating get {
        if !isUniquelyReferencedNonObjC(&amp;amp;boxedData) {
            print(&amp;quot;Making a copy&amp;quot;)
            boxedData = Box(NSMutableData(data: data))
        } else {
            print(&amp;quot;Not making a copy&amp;quot;)
        }
        return boxedData.unbox
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As stated in the introduction, we describe this technique in more detail in our book &lt;a href=&#34;https://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;. If you&amp;rsquo;ve enjoyed this post, be sure to grab a copy. Finally, a gist of the code is &lt;a href=&#34;https://gist.github.com/chriseidhof/d96f0f652a7c6358d865&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Literate Swift</title>
          <link>http://chris.eidhof.nl/post/literate-swift/</link>
          <pubDate>Fri, 31 Jul 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/literate-swift/</guid>
          <description>&lt;p&gt;Last year, when we started writing &lt;a href=&#34;http://www.objc.io/books/fpinswift/&#34;&gt;Functional Programming in Swift&lt;/a&gt;, we realized that the language would change every few weeks. We didn&amp;rsquo;t anticipate the pace, but we were ready for change. Rather than manually updating every article, we used a technique called &lt;a href=&#34;https://en.wikipedia.org/wiki/Literate_programming&#34;&gt;literate programming&lt;/a&gt;. In literate programming, you write the code and text at the same time. The code in the text can be executed. To do this, we wrote a small utility called Literate Swift.&lt;/p&gt;

&lt;p&gt;For our two new books, &lt;a href=&#34;http://www.objc.io/books/core-data/&#34;&gt;Core Data&lt;/a&gt; and &lt;a href=&#34;http://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;, we are using the same technique, except with a newer version of the tool. Literate Swift is a library (and comes with a GUI or command-line tool) that takes a Markdown file, extracts all the code blocks marked with &lt;code&gt;swift&lt;/code&gt;, and compiles those. The awesome thing about it is that you can compile your Markdown: you can statically check that the code in your blog posts (or in our case, our books) is correct.&lt;/p&gt;

&lt;p&gt;Not only does it compile the code blocks marked as Swift, it also takes code blocks marked as &lt;code&gt;print-swift&lt;/code&gt;, and replaces them by the code &lt;em&gt;and&lt;/em&gt; the result of executing that code. For example, the following block after running it through Literate Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```print-swift
(1..&amp;lt;10).reduce(0, combine: +)
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Will get replaced by the following block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```swift
(1..&amp;lt;10).reduce(0, combine: +)
&amp;gt; 45
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We support just highlighting code by marking a block as &lt;code&gt;highlight-swift&lt;/code&gt;. This way, it gets highlighted, but not compiled (which is also a danger, because that code might easily get outdated).&lt;/p&gt;

&lt;p&gt;Finally, sometimes you just want to work in a Swift file. For this, we support embeds. If you have the following block, Literate Swift will look at all Swift files in that directory (and all its subdirectories, recursively), and see if there are lines that are surrounded by &lt;code&gt;// &amp;lt;&amp;lt;MySnippet&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;// &amp;lt;&amp;lt;/MySnippet&amp;gt;&amp;gt;&lt;/code&gt;, and embed the contents of that into the output (without executing it). This way, you can write separate Swift files that are easy to edit using Xcode and still make sure it gets embedded into the output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```highlight-swift
&amp;lt;&amp;lt;MySnippet&amp;gt;&amp;gt;
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Literate Swift tool can currently generate a number of outputs: HTML, Markdown and LaTeX. The &lt;a href=&#34;https://github.com/chriseidhof/LiterateSwiftGUI&#34;&gt;GUI tool&lt;/a&gt; renders the HTML directly into a web view, which is great for previewing while writing. It also has tabs for Markdown, Playground syntax and just the Swift code (for easy copy-pasting). The entire tool chain is still very immature (and a bit hacky at some points), but it has proven to be a great help during writing already. It should also be very simple to integrate this into blogging workflows, and other publishing formats.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Swift and C functions</title>
          <link>http://chris.eidhof.nl/post/swift-c-interop/</link>
          <pubDate>Fri, 31 Jul 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/swift-c-interop/</guid>
          <description>

&lt;p&gt;One of Swift&amp;rsquo;s greatest strengths is the low friction when interoperating with C and Objective-C. Swift can automatically bridge Objective-C types, and can even bridge with many C types. This allows us to use existing libraries, and provide a nice interface on top. In our book &lt;a href=&#34;http://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;, we will write a wrapper around &lt;a href=&#34;https://github.com/jgm/cmark&#34;&gt;cmark&lt;/a&gt;, and a wrapper around &lt;a href=&#34;http://libuv.org&#34;&gt;libuv&lt;/a&gt;. This post is an excerpt from a first draft of one of the C interop chapters.&lt;/p&gt;

&lt;h2 id=&#34;function-pointers&#34;&gt;Function Pointers&lt;/h2&gt;

&lt;p&gt;Rather than wrapping a larger library, let&amp;rsquo;s have a look at wrapping the standard C &lt;code&gt;qsort&lt;/code&gt; function. The type as it imported in Darwin is given below (we&amp;rsquo;ve added the argument names back in, unfortunately they get lost during the import process):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; func qsort(base:   UnsafeMutablePointer&amp;lt;Void&amp;gt;,
            nel:    Int,
            width:  Int,
            compar: ((UnsafePointer&amp;lt;Void&amp;gt;, UnsafePointer&amp;lt;Void&amp;gt;) -&amp;gt; Int32)!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The manual (&lt;code&gt;man qsort&lt;/code&gt;) describes how to use it:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;qsort()&lt;/code&gt; and &lt;code&gt;heapsort()&lt;/code&gt; functions sort an array of &lt;code&gt;nel&lt;/code&gt; objects, the initial member of which is pointed to by &lt;code&gt;base&lt;/code&gt;.  The size of each object is specified by &lt;code&gt;width&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The contents of the array base are sorted in ascending order according to a comparison function pointed to by &lt;code&gt;compar&lt;/code&gt;, which requires two arguments pointing to the objects being compared.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And here is a wrapper function that uses &lt;code&gt;qsort&lt;/code&gt; to sort an array of Swift strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func qsortWrapper(inout array: [String]) {
    qsort(&amp;amp;array, array.count, strideof(String)) { a, b in
        let l: String = UnsafePointer(a).memory
        let r: String = UnsafePointer(b).memory
        return r &amp;gt; l ? -1 : (r == l ? 0 : 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at each of the arguments being passed to &lt;code&gt;qsort&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A pointer to the base of the array. Swift arrays automatically convert to C-style base pointers when you pass them into a function that takes an &lt;code&gt;UnsafePointer&lt;/code&gt;. We use the &lt;code&gt;&amp;amp;&lt;/code&gt; prefix because it is an &lt;code&gt;UnsafeMutablePointer&lt;/code&gt; (in the C declaration, a &lt;code&gt;void *base&lt;/code&gt;). If the function didn&amp;rsquo;t need to mutate its input so declared in C as &lt;code&gt;const void *base&lt;/code&gt;, the &lt;code&gt;&amp;amp;&lt;/code&gt; wouldn&amp;rsquo;t be needed. This matches the difference with &lt;code&gt;inout&lt;/code&gt; arguments in Swift functions.&lt;/li&gt;
&lt;li&gt;The number of elements. This one is easy, just the count property of the array.&lt;/li&gt;
&lt;li&gt;To get the width of each element, we use &lt;code&gt;strideof&lt;/code&gt; – &lt;em&gt;not&lt;/em&gt; &lt;code&gt;sizeof&lt;/code&gt;.  In Swift, &lt;code&gt;sizeof&lt;/code&gt; returns the true size of a type, but when locating elements in memory, platform alignment needs might mean the gap between each element (the &amp;ldquo;stride&amp;rdquo;) could be the size &lt;em&gt;plus&lt;/em&gt; some padding.  In case of strings they will be the same, but when dealing with some types (specific structs and enums), &lt;code&gt;sizeof&lt;/code&gt; doesn&amp;rsquo;t include the memory padding, and &lt;code&gt;strideof&lt;/code&gt; does.

&lt;ul&gt;
&lt;li&gt;For the &lt;code&gt;compar&lt;/code&gt;, we can just pass in a trailing closure expression (as long as it doesn&amp;rsquo;t capture any variables).  The &lt;code&gt;compar&lt;/code&gt; function accepts two void pointers. A C void pointer can be a pointer to anything: the first thing to do is cast it to a pointer to the actual type you (hope) it is. In the case of &lt;code&gt;qsort&lt;/code&gt;, the they will be to elements in the array, pointers to two Swift strings. Finally, the function needs to return an &lt;code&gt;Int32&lt;/code&gt;: if the first element is greater than the second, it should be larger than 0, if they&amp;rsquo;re equal, 0, and if it&amp;rsquo;s small a number, less than zero.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s easy enough to create another wrapper that works for a different type; we can copy-paste the code, change &lt;code&gt;String&lt;/code&gt; to a different type, and then we&amp;rsquo;re done. However, when we try to make the code generic, we hit the limit of C function pointers. When writing the function below, the Swift compiler segfaulted on the code below. Even if it wouldn&amp;rsquo;t segfault, the code is still impossible: it captures a variable from outside the closure. Specifically, it captures the comparison and equality operators: they are different for each A. There is nothing we can do about this: we just hit a hard limitation of the way C works.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func qsortWrapper&amp;lt;A: Comparable&amp;gt;(inout array: [A]) {
    qsort(&amp;amp;array, array.count, strideof(A)) { a, b in
        let l: A = UnsafePointer(a).memory
        let r: A = UnsafePointer(b).memory
        return r &amp;gt; l ? -1 : (r == l ? 0 : 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, in practice this is a problem for many C programmers as well. On OS X, there is a variant of &lt;code&gt;qsort&lt;/code&gt; called &lt;code&gt;qsort_b&lt;/code&gt;, which takes a block as the last parameter, instead of a function pointer. If we replace the &lt;code&gt;qsort&lt;/code&gt; by &lt;code&gt;qsort_b&lt;/code&gt; in the code above, our code will compile and run fine.&lt;/p&gt;

&lt;p&gt;However, on many platforms &lt;code&gt;qsort_b&lt;/code&gt; might not be available. Specifically, in other APIs, there might not be a block-based alternative. Oftentimes, there is a different solution. Many C functions and datatypes take an extra unsafe void pointer as a parameter, which is user-defined context that can be used. In C, you can store the address of any type of variable in that context (it is untyped). In the case of &lt;code&gt;qsort&lt;/code&gt;, there is a variant called &lt;code&gt;qsort_r&lt;/code&gt; which does exactly this. Comparing the type with &lt;code&gt;qsort&lt;/code&gt;, we can see that just before the block, it takes an extra parameter &lt;code&gt;thunk&lt;/code&gt;, an unsafe mutable void pointer. This parameter also gets passed in to the comparison function pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func qsort_r(base:   UnsafeMutablePointer&amp;lt;Void&amp;gt;,
             nel:    Int, 
             width:  Int, 
             thunk:  UnsafeMutablePointer&amp;lt;Void&amp;gt;,
             compar: ((UnsafeMutablePointer&amp;lt;Void&amp;gt;, UnsafePointer&amp;lt;Void&amp;gt;, UnsafePointer&amp;lt;Void&amp;gt;) -&amp;gt; Int32)!)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use this mutable void pointer to pass arbitrary context to &lt;code&gt;qsort&lt;/code&gt;, and use it inside the block. In order to do that, we first need to be able to convert any data into an unsafe mutable pointer. First, when we pass data to C, we want to make sure the data is retained (if it is a reference type). To do that, we can create an unmanaged reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let unmanaged = Unmanaged.passRetained(Box(data))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we want to create an unsafe mutable void pointer out of this. We can take the unmanaged value, make it an opaque value and initialize an unsafe mutable pointer with it. This is a couple of steps, and hopefully in the future, the Swift Standard Library will provide a shorter way to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let pointer: UnsafeMutablePointer&amp;lt;Void&amp;gt; = UnsafeMutablePointer(unmanaged.toOpaque())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can pass that pointer around. Finally, once we are done, we want to make sure to release the reference again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unmanaged.release()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make sure we don&amp;rsquo;t make any mistakes with retains and releases, we can wrap this up in a function. This function takes a value of any type, and a callback function which performs a computation with the void pointer. By using a callback function, we can make sure to release our object after we are done. The moment the callback returns, the value is released. Therefore, this is only safe to use when the void pointer is not stored somewhere, or used asynchronously.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func withVoidPointer&amp;lt;A&amp;gt;(x: A, @noescape f: UnsafeMutablePointer&amp;lt;Void&amp;gt; -&amp;gt; ()) {
    let unmanaged = Unmanaged.passRetained(Box(x))
    f(UnsafeMutablePointer(unmanaged.toOpaque()))
    unmanaged.release()
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a companion function, we can also write an &lt;code&gt;unsafeFromVoidPointer&lt;/code&gt;, which removes all the wrapping we added in the previous function. It uses &lt;code&gt;takeUnretainedValue&lt;/code&gt; to make sure to not change the retain count when using the value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func unsafeFromVoidPointer&amp;lt;A&amp;gt;(thunk: UnsafeMutablePointer&amp;lt;Void&amp;gt;) -&amp;gt; A {
    return Unmanaged&amp;lt;Box&amp;lt;A&amp;gt;&amp;gt;.fromOpaque(COpaquePointer(thunk)).takeUnretainedValue().unbox
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we use the two functions, we will introduce a new function on &lt;code&gt;Comparable&lt;/code&gt;, which will have the form of a C comparison callback function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Comparable {
    static func compare(a: UnsafePointer&amp;lt;Void&amp;gt;, _ b: UnsafePointer&amp;lt;Void&amp;gt;) -&amp;gt; Int32 {
        let l: Self = UnsafePointer(a).memory
        let r: Self = UnsafePointer(b).memory
        return r &amp;gt; l ? -1 : (r == l ? 0 : 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have all the pieces together to finally wrap &lt;code&gt;qsort_r&lt;/code&gt;. Instead of a block, we will use a separate function &lt;code&gt;cmp&lt;/code&gt; which we define below. By using &lt;code&gt;withVoidPointer&lt;/code&gt;, we can convert the &lt;code&gt;A.compare&lt;/code&gt; function into a void pointer, which we pass as the fourth argument to qsort_r. The rest of the code remains unchanged.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func qsortRWrapper&amp;lt;A: Comparable&amp;gt;(inout array: [A]) {
    withVoidPointer(A.compare) { p in
        qsort_r(&amp;amp;array, array.count, strideof(A), p, cmp)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, our &lt;code&gt;cmp&lt;/code&gt; function needs to take the first void pointer, convert it back into a comparison function, and call it with the two other arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias Compare = (UnsafePointer&amp;lt;Void&amp;gt;, 
                     UnsafePointer&amp;lt;Void&amp;gt;) -&amp;gt; Int32

private func cmp(thunk: UnsafeMutablePointer&amp;lt;Void&amp;gt;,
                 a: UnsafePointer&amp;lt;Void&amp;gt;,
                 b: UnsafePointer&amp;lt;Void&amp;gt;) -&amp;gt; Int32 {
    let f: Compare = unsafeFromVoidPointer(thunk)
    return f(a, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It might seem like this is a lot of work to use a sorting algorithm from the C Standard Library, after all, the default Swift sorting algorithm is much more optimized in many cases. However, what we have done is reusable in many cases. Not only are we now able to succesfully use C&amp;rsquo;s builtin functions in Swift, we can now also use them in a type-safe and generic way. There are many other interesting libraries and functions out there, written in C, which we can wrap using the same technique.&lt;/p&gt;

&lt;p&gt;If you liked this, consider buying our book &lt;a href=&#34;http://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;, where we&amp;rsquo;ll go into much more detail on how to work with C libraries (among many other things). Thanks to my co-author &lt;a href=&#34;http://airspeedvelocity.net&#34;&gt;Airspeed Velocity&lt;/a&gt; for reading through and making edits to this text.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Advanced Swift</title>
          <link>http://chris.eidhof.nl/post/advanced-swift/</link>
          <pubDate>Tue, 21 Jul 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/advanced-swift/</guid>
          <description>&lt;p&gt;Over the last months, &lt;a href=&#34;http://airspeedvelocity.net&#34;&gt;Airspeed Velocity&lt;/a&gt; and me have been very busy writing a new book: &lt;a href=&#34;http://www.objc.io/books/advanced-swift/&#34;&gt;Advanced Swift&lt;/a&gt;. We are quite far along, most of the book has been written already. During the next months, we will polish the chapters and release them one by one. We aim to have the book done by this fall (hopefully so we can coincide with the official Swift release).&lt;/p&gt;

&lt;p&gt;Writing this book has been a lot of fun, and a huge learning experience. After finishing &lt;a href=&#34;http://www.objc.io/books/fpinswift/&#34;&gt;my first book&lt;/a&gt; last summer, I immediately started thinking about other possible books to write. When meeting Airspeed in London, we started talking about a possible collaboration, came up with a list of subjects and started writing. For this book, we also did something different: we asked &lt;a href=&#34;http://oleb.net&#34;&gt;Ole Begemann&lt;/a&gt; as our technical reviewer. He is very thorough and has already helped shaped the book in some crucial parts.&lt;/p&gt;

&lt;p&gt;I personally had a lot of fun figuring out the C interoperability. I believe this will be a huge topic in the community, especially once Swift is open source. Many of the Cocoa libraries will not be available under Linux, and rather than writing every possible library from scratch, it will be much easier to write a Swift layer on top of them. Therefore, after the announcement that Swift will be open source, we decided to focus more on interoperability in the book.&lt;/p&gt;

&lt;p&gt;In our book, we will wrap two libraries: &lt;a href=&#34;https://github.com/jgm/cmark&#34;&gt;cmark&lt;/a&gt;, a library for parsing CommonMark, and &lt;a href=&#34;https://github.com/libuv/libuv&#34;&gt;libuv&lt;/a&gt;, a library for doing asynchronous I/O. When wrapping a C library, the two most difficult things are conversions between types (for example, converting between a C data buffer and &lt;code&gt;NSData&lt;/code&gt;), and memory management (because every C library deals with memory in a different way).&lt;/p&gt;

&lt;p&gt;When wrapping a synchronous library (such as cmark), we can often make memory management really easy by wrapping pointers in classes, and then using the &lt;code&gt;deinit&lt;/code&gt; method to free up any memory. When wrapping asynchronous code, this becomes a bit harder, because classes might go out of scope (and thus are deallocated) before the memory needs to be freed.&lt;/p&gt;

&lt;p&gt;We will also discuss C function pointers, and how to work with them. Because C function pointers do not allow for capturing of any context (e.g. refer to variables outside of a function), we will need some special techniques to convert C pointer-based APIs into APIs that work with regular Swift closures.&lt;/p&gt;

&lt;p&gt;The interop chapters are only a small part of the book, we will cover a lot of topics in detail: collections, generics, structs and classes, strings, errors, protocols and much more. If you want to start reading already, and help shape the book, you should get into the &lt;a href=&#34;http://www.objc.io/books/advanced-swift/&#34;&gt;early access program&lt;/a&gt; today.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Via Alpina</title>
          <link>http://chris.eidhof.nl/post/via-alpina/</link>
          <pubDate>Tue, 23 Jun 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/via-alpina/</guid>
          <description>&lt;p&gt;In a few days, I&amp;rsquo;ll head over to Innsbruck to meet up with some friends for the weekend. After that, I&amp;rsquo;m going to start a big running adventure. My plan is to run solo across the Alps for a month, from mountain hut to mountain hut. I&amp;rsquo;ll be bringing a small backpack, filled mostly with warm layers and my laptop. In the mornings, I plan to run, and in the afternoons, I&amp;rsquo;ll &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;write my new book&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To be honest, I have no idea what it&amp;rsquo;s going to be like. I&amp;rsquo;ve ran in mountains before, but never for such a long stretch. Being Dutch, I&amp;rsquo;m not used to mountains, so there&amp;rsquo;ll be lots to explore and learn. I&amp;rsquo;m going to be running a stretch of the &lt;a href=&#34;http://www.via-alpina.org&#34;&gt;Via Alpina&lt;/a&gt;, and will start somewhere close to Innsbruck and run towards the Mt. Blanc.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not sure how much I can cover in a day, and have no clue where I&amp;rsquo;ll end up after a month. Even though I&amp;rsquo;ve been training 4-5 times a week for the last years, I can imagine that running in this terrain and running so much can get me injured, in which case I&amp;rsquo;m totally prepared to stop (and come back another time).&lt;/p&gt;

&lt;p&gt;I hope there will be WiFi in at least some of the huts, and if so, I&amp;rsquo;ll be posting updates &lt;a href=&#34;http://vialpina.tumblr.com/&#34;&gt;on a new blog&lt;/a&gt;!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Swift Mirrors and JSON</title>
          <link>http://chris.eidhof.nl/post/swift-mirrors-and-json/</link>
          <pubDate>Mon, 15 Jun 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/swift-mirrors-and-json/</guid>
          <description>&lt;p&gt;Inspired by &lt;a href=&#34;https://twitter.com/mikeash/status/609575730024984576&#34;&gt;Mike Ash&amp;rsquo;s tweet&lt;/a&gt;, I tried generating JSON dictionaries in Swift by using the new reflection features. First of all, let&amp;rsquo;s create two structs for holding a person and an address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Address {
    var street: String
}

struct Person {
    var name: String = &amp;quot;John&amp;quot;
    var age: Int = 42
    var dutch: Bool = false
    var address: Address? = Address(street: &amp;quot;Market St.&amp;quot;)
}

let john = Person()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can introspect values using the &lt;code&gt;reflect&lt;/code&gt; function. It returns a &lt;code&gt;MirrorType&lt;/code&gt;, which is a value we can use to inspect the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reflect(john)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every &lt;code&gt;MirrorType&lt;/code&gt; value has a property &lt;code&gt;count&lt;/code&gt;, which counts the number of children (e.g. the address struct has a single child, &lt;code&gt;street&lt;/code&gt;, whereas the person struct has four children, one for every field). We can extend &lt;code&gt;MirrorType&lt;/code&gt; with a simple &lt;code&gt;children&lt;/code&gt; property that loops over the children and returns them in an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension MirrorType {
    var children: [(String,MirrorType)] {
        var result: [(String, MirrorType)] = []
        for i in 0..&amp;lt;self.count {
            result.append(self[i])
        }
        return result
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will implement our solution in two steps. First, we&amp;rsquo;ll create a protocol &lt;code&gt;JSON&lt;/code&gt; which converts any value into a JSON-serializable object. Because serialization might fail, we&amp;rsquo;ll mark it as &lt;code&gt;throws&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol JSON {
    func toJSON() throws -&amp;gt; AnyObject?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now comes the big trick I copied from Mike. We can provide a default implementation by extending the protocol. This default implementation reflects a value, and loops over the children, recursively serializing them as well. If the type doesn&amp;rsquo;t have any children, we assume it&amp;rsquo;s a primitive (e.g. a String or an Int) and don&amp;rsquo;t serialize it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension JSON {
    func toJSON() throws -&amp;gt; AnyObject? {
        let mirror = reflect(self)
        if mirror.count &amp;gt; 0  {
            var result: [String:AnyObject] = [:]
            for (key, child) in mirror.children {
                if let value = child.value as? JSON {
                  result[key] = try value.toJSON()
                } else {
                    throw CouldNotSerializeError.NoImplementation(source: self, type: child)
                }
            }
            return result
        }
        return self as? AnyObject
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because of the implementation above, we can now easily derive JSON generation for structs and simple values, without having to implement it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Address: JSON { }
extension Person: JSON { }
extension String: JSON { }
extension Int: JSON { }
extension Bool: JSON { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For optional values, we want to return nil in case the value isn&amp;rsquo;t there, and otherwise try to serialize it. This is how you can override the &lt;code&gt;toJSON&lt;/code&gt; function for a more specific type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Optional: JSON {
    func toJSON() throws -&amp;gt; AnyObject? {
        if let x = self {
            if let value = x as? JSON {
                return try value.toJSON()
            }
            throw CouldNotSerializeError.NoImplementation(source: x, type: reflect(x))
        }
        return nil
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, to test that it worked:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do {
    try john.toJSON()
} catch {
    print(error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full code is in a &lt;a href=&#34;https://gist.github.com/chriseidhof/48243eb549481bc38d58&#34;&gt;gist&lt;/a&gt;. It runs fine in a real app, but seems to not always work in a playground. After posting the gist on Twitter yesterday, Rich pointed out that I was late to the party: Matthew Cheok already implemented &lt;a href=&#34;https://github.com/matthewcheok/JSONCodable&#34;&gt;JSONCodable&lt;/a&gt;, which is a library that&amp;rsquo;s ready for use!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Monads in Swift</title>
          <link>http://chris.eidhof.nl/post/monads-in-swift/</link>
          <pubDate>Mon, 01 Jun 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/monads-in-swift/</guid>
          <description>&lt;p&gt;Last year, many people have dipped their toes into functional programming. Unfortunately, one of the side-effects of learning functional programming is a great amount of people trying to explain monads. Many explanations I&amp;rsquo;ve seen were bad and only add to the existing confusion. This makes me quite upset sometimes.&lt;/p&gt;

&lt;p&gt;So here&amp;rsquo;s my very short (and slightly simplified) explanation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you can define &lt;a href=&#34;http://swiftdoc.org/func/flatMap/&#34;&gt;&lt;code&gt;flatMap&lt;/code&gt;&lt;/a&gt; for a type, the type is often called a monad.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, you can define &lt;code&gt;flatMap&lt;/code&gt; for &lt;code&gt;Array&lt;/code&gt;. Array is a monad. You can define &lt;code&gt;flatMap&lt;/code&gt; for optionals. &lt;code&gt;Optional&lt;/code&gt; is a monad. You can also define &lt;code&gt;flatMap&lt;/code&gt; for other types, such as functions, tuples, reactive cocoa signals, the &lt;code&gt;Result&lt;/code&gt; type, and many more. Defining &lt;code&gt;flatMap&lt;/code&gt; for a type often is really useful, even if it&amp;rsquo;s not &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Monad_(functional_programming)#Formal_definition&#34;&gt;officially&lt;/a&gt;&amp;rdquo; a monad. That&amp;rsquo;s really all there&amp;rsquo;s to it.&lt;/p&gt;

&lt;p&gt;If you care for a longer explanation in Swift, then &lt;a href=&#34;http://nomothetis.svbtle.com/the-culmination-i&#34;&gt;Alexandros&amp;rsquo;s articles&lt;/a&gt; are pretty good. If you prefer video, have a look at &lt;a href=&#34;http://2014.funswiftconf.com/speakers/john.html&#34;&gt;John Gallagher&amp;rsquo;s talk&lt;/a&gt;. Finally, if you like reading books, you can read my book &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;Functional Programming in Swift&lt;/a&gt; or &lt;a href=&#34;http://learnyouahaskell.com&#34;&gt;Learn You a Haskell&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Race Report: Rotterdam Marathon</title>
          <link>http://chris.eidhof.nl/post/race-report-rotterdam-harzquerung/</link>
          <pubDate>Wed, 29 Apr 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/race-report-rotterdam-harzquerung/</guid>
          <description>

&lt;p&gt;After &lt;a href=&#34;http://chris.eidhof.nl/posts/race-report-munich-marathon.html&#34;&gt;my first marathon&lt;/a&gt;, I wanted to do a better job at running my next marathon. Instead of training by myself, I decided to work with &lt;a href=&#34;https://twitter.com/markpersista&#34;&gt;Mark&lt;/a&gt;, who made a training plan for me leading up to the Rotterdam Marathon. I spent a few months in New York, a while in San Francisco, and generally traveled around while still putting in my training, this went surprisingly well. I even ran some races in the US (and won a 5K in Brooklyn).&lt;/p&gt;

&lt;p&gt;Because my training (and races) went really well, Mark proposed to try to run a 2:50 marathon (my PB is 3:28). At first, I felt very hesitant, because I spent half a year training really hard (about 5 days a week) to run this marathon. The week before the marathon, I ran a 10K at the proposed marathon pace (4:02/km), and it felt quite easy. So I decided to take the risk, willingly, with a good chance of blowing up somewhere down the road.&lt;/p&gt;

&lt;h3 id=&#34;rotterdam&#34;&gt;Rotterdam&lt;/h3&gt;

&lt;p&gt;On the 12th of April, I was feeling strong before the start. I had a relaxing week before, and felt completely prepared. We set off, and the first 10K felt really easy. However, I noticed that after that, it was just a little bit harder to keep up the pace (I was running alone on a windy part, and couldn&amp;rsquo;t hide behind a group). Yet, I managed to run the first half marathon in 1:25, exactly on pace. However, after that, my pace quickly dropped. I immediately set a new goal: just make sure to run the second half in 1:30. A bit later, I also noticed that this was too fast, and wanted to finish in under three hours. Then, during the last 10K, I only had one goal left: just keep running. Make it to the finish without walking. It was really tough, but I managed (and even was able to push out a sprint finish). The second half took me 1:40, and I ended up with &lt;a href=&#34;https://app.strava.com/activities/284274016&#34;&gt;3:05 as my final time&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rather than a disappointment, I was really happy that I tried. I knew the risk going into this. If I would have started slightly slower, I&amp;rsquo;d probably have managed a time under 3 hours relatively easily.&lt;/p&gt;

&lt;h3 id=&#34;harzquerung&#34;&gt;Harzquerung&lt;/h3&gt;

&lt;p&gt;The recovery went well, and after about a week I was able to run again, albeit slowly. Before my marathon, I had already been looking at the &lt;a href=&#34;http://www.harzquerung.de&#34;&gt;Harzquerung&lt;/a&gt;, a 51K ultra trail through the mountains, and promised myself to run it if recovery went fast. Last week, I went for a few very short runs and felt strong, so I booked a hotel, registered for the race and got my train tickets. My first ultra-marathon!&lt;/p&gt;

&lt;p&gt;On Sunday, at the start, I was feeling even more relaxed. I knew that the course would be hard (quite some elevation compared to my usual runs), and that I could never run a fast time (whatever that means in a mountainy ultrarace). Also, it was only 2 weeks after Rotterdam, so my body wasn&amp;rsquo;t completely recovered. Therefore, I took it really easy and focused on enjoying the nature. It was the best. I chatted with some fellow runners, took it easy on the uphills and took it easy on the downhills. There were hardly any flat parts. The race itself was also very well organized, and the course well marked. After 7km my legs felt tired, but that feeling went away quite quickly.&lt;/p&gt;

&lt;p&gt;After 45km I was ready for the race to end, but still had quite a bit to go. But because I had not pushed myself at all, it was still really enjoyable. The recovery went really fast as well: it&amp;rsquo;s four days later and I was able to finish a normal training. This was my first ultra race, but definitely not my last, I thoroughly enjoyed it. Here&amp;rsquo;s my &lt;a href=&#34;https://app.strava.com/activities/292438296&#34;&gt;strava link&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;plan&#34;&gt;Plan&lt;/h3&gt;

&lt;p&gt;In July, I&amp;rsquo;m thinking of doing a long trip crossing the Alps, running for a few weeks. Then, I&amp;rsquo;ll prepare specifically for the Berlin marathon, and if I stay injury-free, I&amp;rsquo;ll try to give the 2:50 another go. After Berlin, I&amp;rsquo;ll probably look into more ultra trails.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Swift in Production: Scenery</title>
          <link>http://chris.eidhof.nl/post/scenery-launch/</link>
          <pubDate>Tue, 24 Mar 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/scenery-launch/</guid>
          <description>&lt;p&gt;Today, we shipped our first Swift app completely written in Swift: &lt;a href=&#34;https://www.getscenery.com&#34;&gt;Scenery&lt;/a&gt;. From our press release:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scenery is the Mac app that makes your app or website designs look instantly beautiful and professional, by putting them in context – placed into smartphones, tablets, laptops, and more – in stunningly-photographed scenes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://www.getscenery.com/gallery/video.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s been a very interesting experience, because all iOS and Mac apps we&amp;rsquo;ve built before were done using Objective-C. In the beginning, we spent a lot of time waiting for the compiler, but the stability and speed of the tooling has improved a lot in recent releases, so we hardly ever have issues anymore. Even when you take the time spent waiting on the compiler into account, I think we were still writing better code at a higher speed than with Objective-C.&lt;/p&gt;

&lt;p&gt;The code base we ended up with makes me much happier than most Objective-C code bases I&amp;rsquo;ve seen. Having Swift&amp;rsquo;s type-safety greatly improves my trust in refactorings: I feel free to change a function&amp;rsquo;s type, add parameters or change parameter types. I know that the compiler will help me catch any type-related errors. We use a lot of functional patterns: &lt;a href=&#34;http://chris.eidhof.nl/posts/tiny-networking-in-swift.html&#34;&gt;tiny networking&lt;/a&gt;, &lt;a href=&#34;http://www.objc.io/snippets/16.html&#34;&gt;typed observers&lt;/a&gt;, &lt;a href=&#34;http://www.objc.io/snippets/20.html&#34;&gt;configuration values&lt;/a&gt;, &lt;a href=&#34;http://www.objc.io/snippets/8.html&#34;&gt;wrapper types&lt;/a&gt;, and the list goes on. Many of the snippets we published over at &lt;a href=&#34;http://www.objc.io&#34;&gt;objc.io&lt;/a&gt; come from our Scenery code base.
Another really big win was the ability to use enums. Creating a new enum is very simple, and comes at no runtime cost, yet gives us a lot better readability and maintainability.&lt;/p&gt;

&lt;p&gt;Finally, we use a lot of tiny functions that help us compose functionality out of short and understandable pieces.
Our app uses two frameworks: UIShared, which has reusable code that&amp;rsquo;s unrelated to Scenery, and SceneryShared, which has a lot of our domain logic. The app itself is very lean.  This means that the stateful parts of our app are quite contained (in the app itself), and that most of our code is stateless and thus easier to maintain and understand.&lt;/p&gt;

&lt;p&gt;So, when people ask me whether Swift is ready for production, for me the answer is a resounding yes. It&amp;rsquo;s served us very well, and it keeps getting better, faster and easier. And the best thing: this is only the beginning of the Swift journey, if the language keeps improving at this pace, the future will be very bright indeed.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>The Boring Choice</title>
          <link>http://chris.eidhof.nl/post/boring-choice/</link>
          <pubDate>Thu, 05 Mar 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/boring-choice/</guid>
          <description>&lt;p&gt;I love new and experimental technologies. These days, I like trying to push Swift to the limits. I once wrote a Haskell web backend for financial transactions that used lots of generic programming. When Rails was just out, I started playing around with it (back when hosting was really complicated, except if you wanted PHP3 and MySQL). I&amp;rsquo;ve used all these things in production code, mainly in very small teams.&lt;/p&gt;

&lt;p&gt;For &lt;a href=&#34;https://www.getscenery.com&#34;&gt;Scenery&lt;/a&gt;, we also had to write a backend. I debated using Swift (but hosting would&amp;rsquo;ve been a pain), or maybe something like Haskell or Scala. The cool kids seem to be doing Go and Elixir these days. It&amp;rsquo;d have been lots of fun. However, I went for one of the most boring choices: Ruby on Rails. Rails is at version 4, and even though a lot has changed, it is also very mainstream these days. This means there&amp;rsquo;s a lot less exciting technology to play around with.&lt;/p&gt;

&lt;p&gt;There are a couple of reasons for choosing Rails:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s very widely used and tested. During this project, I haven&amp;rsquo;t come across any bugs in Rails.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s really easy to get help. Most of the times, I don&amp;rsquo;t even need to ask, but just google my problem and I&amp;rsquo;ll quickly find out what&amp;rsquo;s going wrong.&lt;/li&gt;
&lt;li&gt;There are &lt;em&gt;so many&lt;/em&gt; libraries available. This is a killer feature: I wanted to keep a history of some of my model objects, and found out about &lt;a href=&#34;https://github.com/airblade/paper_trail&#34;&gt;papertrail&lt;/a&gt;. For testing, I can use &lt;a href=&#34;https://github.com/thoughtbot/factory_girl&#34;&gt;FactoryGirl&lt;/a&gt;. For authentication, we use &lt;a href=&#34;https://github.com/plataformatec/devise&#34;&gt;devise&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The eco-system is great, Heroku takes away a lot of deployment worries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, one of the most important things is that anybody on our team can contribute. With Haskell, there would have been a decent chance that I would be the only one even being able to build the project. With Rails, none of the people we work with had to learn anything new: they were productive immediately. I recently came across this African proverb, and thought it fitted well to our situation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;If you want to go fast, go alone. if you want to go far, go together.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(Via &lt;a href=&#34;https://twitter.com/ryangraves/status/562492587039150080&#34;&gt;ryangraves&lt;/a&gt;
)&lt;/p&gt;

&lt;p&gt;So far, I&amp;rsquo;m really happy with the boring choice. Being able to get many hands on deck quickly really made a big difference. Hardly having to worry about stability and deployment helps me sleep at night. And finally, knowing that whenever I have a problem, others will have had the same problem saves me heaps of time. Luckily, we&amp;rsquo;ve written the Mac app entirely in Swift, with lots of functional code, so there&amp;rsquo;s always a place left to play with new technology.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Functional View Controllers</title>
          <link>http://chris.eidhof.nl/post/functional-view-controllers/</link>
          <pubDate>Tue, 13 Jan 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/functional-view-controllers/</guid>
          <description>&lt;p&gt;I&amp;rsquo;m working on something new: a functional wrapper around view controllers. Making view controllers simpler has been a &lt;a href=&#34;http://www.objc.io/issue-1/&#34;&gt;long obsession&lt;/a&gt; for me. I think functional view controllers might make them even simpler. This is still very much work in progress, but I hope that over the next months I can flesh out something nice. For this article, we&amp;rsquo;ll work with artists and albums, and this is how they&amp;rsquo;re defined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Album {
    let name: String
}

struct Artist {
    let name : String
    let albums: [Album]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s some example data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let artists : [Artist] = [
    Artist(name: &amp;quot;JS Bach&amp;quot;, albums: [Album(name: &amp;quot;The Art of Fugue&amp;quot;)]),
    Artist(name: &amp;quot;Simeon Ten Holt&amp;quot;, albums: [])
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When working with UIKit, view controllers are the opposite of isolated: they are connected to everything. The view controller often pulls network or database data, populates and interacts with views, and finally, it pushes other view controllers onto the navigation stack (or presents them in a different way). In this article, we&amp;rsquo;ll look at view controllers that do only one thing: they populate the views and interact with them. They don&amp;rsquo;t load any data themselves, nor do they present other view controllers.&lt;/p&gt;

&lt;p&gt;In functional view controllers, every view controller takes some input, renders that, and has some output. For example, if we consider the stock Music app, there&amp;rsquo;s a simple table view controller. It displays a list of artists, and, when the user taps on an artist, it shows another view controller. We could model that as following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let chooseArtist: ViewController&amp;lt;[Artist], Artist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now, we can ignore how it is implemented. The only thing this view controller does is displaying the list of artists in a table, and calling a callback once an artist is selected. We can also make a &lt;code&gt;chooseAlbum&lt;/code&gt; view controller, which, given a list of albums, renders them and lets the user select an album:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let chooseAlbum: ViewController&amp;lt;[Album],Album&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we would like to present both in a navigation controller. To do that, there&amp;rsquo;s a function called &lt;code&gt;rootViewController&lt;/code&gt;, which lifts a view controller into a navigation controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func rootViewController&amp;lt;A,B&amp;gt;(vc: ViewController&amp;lt;A,B&amp;gt;) -&amp;gt; 
                           NavigationController&amp;lt;A,B&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let startPoint: NavigationController&amp;lt;[Artist], Artist&amp;gt; = 
    rootViewController(chooseArtist)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we would like to add some functionality to push another view controller. For example, when the user selects an artist, we would like to push the &lt;code&gt;chooseAlbum&lt;/code&gt; view controller onto the navigation stack. To do that, we can use the &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func &amp;gt;&amp;gt;&amp;gt;&amp;lt;A,B,C&amp;gt;(l: NavigationController&amp;lt;A,B&amp;gt;, 
                r: ViewController&amp;lt;B,C&amp;gt;) -&amp;gt; 
                   NavigationController&amp;lt;A,C&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The operator takes a left operand (a navigation controller from A to B) and a right operand (a view controller from B to C). When the left view controller is done (e.g. when an artist is selected) it pushes the right view controller.&lt;/p&gt;

&lt;p&gt;However, we can&amp;rsquo;t use this &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; operator yet. Our &lt;code&gt;chooseArtist&lt;/code&gt; returns an artist, but our &lt;code&gt;chooseAlbum&lt;/code&gt; expects a list of albums, not just a single artist. Luckily, the solution is very easy: we can use a &lt;code&gt;map&lt;/code&gt; function (which works similar to &lt;code&gt;map&lt;/code&gt; on optionals or dictionaries).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func map&amp;lt;A,B,C&amp;gt;(vc: NavigationController&amp;lt;A,B&amp;gt;, 
                f: B -&amp;gt; C) -&amp;gt; 
                NavigationController&amp;lt;A,C&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, the map function takes a navigation controller that maps from A to B. Once that navigation controller is done, it applies a function &lt;code&gt;f&lt;/code&gt; to convert that B into a C, and we end up with a navigation controller that maps from A to C. Now, we have all the ingredients to write down our entire hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let artists = rootViewController(chooseArtist)
let navigation = map(artists, { $0.albums }) &amp;gt;&amp;gt;&amp;gt; chooseAlbum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re almost done. We haven&amp;rsquo;t looked at how &lt;code&gt;chooseArtist&lt;/code&gt; and &lt;code&gt;chooseAlbum&lt;/code&gt; are defined. They&amp;rsquo;re both table view controllers. There&amp;rsquo;s a simple function &lt;code&gt;tableViewController&lt;/code&gt; in the library which will render an array of things into a table, and performs an action when a cell is selected. Because all of this can be made to work independent of the datatype, the only thing we need to specify is how to configure the cell:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func tableViewController&amp;lt;A&amp;gt;(render: (UITableViewCell, A) -&amp;gt; ()) -&amp;gt; ViewController&amp;lt;[A],A&amp;gt;

let chooseArtist: ViewController&amp;lt;[Artist], Artist&amp;gt; = tableViewController { cell, artist in
    cell.textLabel?.text = artist.name
}

let chooseAlbum: ViewController&amp;lt;[Album],Album&amp;gt; = tableViewController { cell, album in
    cell.textLabel?.text = album.name
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have our individual view controllers defined, and our navigation stack, it&amp;rsquo;s time to setup the window&amp;rsquo;s root view controller in the app delegate. We run the navigation stack we created with the list of artists defined above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window?.rootViewController = run(navigation, artists) { album in
    println(&amp;quot;Selected \(album.name)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all there is to it. With just a few simple lines, we have created a working app with two table views, with the only &amp;ldquo;real&amp;rdquo; programming that we&amp;rsquo;ve done is configuring the cell. Based off of that, we created two table view controllers, and hooked them up together. The table view controllers know absolutely nothing about each other, and are not contaminated with any navigation controller logic. They don&amp;rsquo;t even know how to load the data. Having to do this outside of the view controller really forces you to separate concerns.&lt;/p&gt;

&lt;p&gt;The current implementation is a proof of concept. We&amp;rsquo;ll have to see how this can extend. For example, how does this work with custom transitions? Adding modal transitions is easy, but I&amp;rsquo;m not entirely sure what would be the best way to have completely custom transitions outside of a navigation controller. It&amp;rsquo;s very easy to use this technique with existing view controllers, you can easily wrap them. I&amp;rsquo;d love to experiment more with this. But as I&amp;rsquo;m mostly doing Mac development these days, I can&amp;rsquo;t promise the development will go very fast.&lt;/p&gt;

&lt;p&gt;A full example is on &lt;a href=&#34;https://github.com/chriseidhof/functional-view-controllers/&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Repmin in Swift</title>
          <link>http://chris.eidhof.nl/post/repmin-in-swift/</link>
          <pubDate>Sat, 10 Jan 2015 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/repmin-in-swift/</guid>
          <description>&lt;p&gt;This might be my most obscure functional programming post yet.&lt;/p&gt;

&lt;p&gt;Yesterday, I attended the Dutch Functional Programming Day, and it was very nice to see many old friends. &lt;a href=&#34;http://foswiki.cs.uu.nl/foswiki/Swierstra/WebHome&#34;&gt;Doaitse&lt;/a&gt;&amp;rsquo;s talk was about different solutions to the repmin problem (and related problems). Repmin is a slightly obscure problem (but famous amoung a small group of functional programmers):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Given a binary tree with integers at the leaves, replace each leave&amp;rsquo;s value by the minimum value in the tree.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For example, given the following tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1 2) (3 (4 5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1 1) (1 (1 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The simplest solution would take two steps: in step 1, we iterate over the tree, finding the minimum value. In step 2, we iterate over the tree again, replacing every leaf with the minimum value. Let&amp;rsquo;s build that. In Swift, we can define a tree like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Tree {
    case Node(Tree, Tree)
    case Leaf(Int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finding the minimum is simple, in case of a leaf we return the leaf&amp;rsquo;s value, in case of a node we return the minimum of both branches:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func minimum(t: Tree) -&amp;gt; Int {
    switch t {
    case let .Node(l, r):
        return min(minimum(l), minimum(r))
    case .Leaf(let x):
        return x
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For replacing, we can write another function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func replaceAllLeaves(t: Tree, newValue: Int) -&amp;gt; Tree {
    switch t {
    case .Node(let l, let r):
        return .Node(replaceAllLeaves(l, newValue), replaceAllLeaves(r, newValue))
    case .Leaf(_):
        return .Leaf(newValue)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can write our solution like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repmin = { tree in replaceAllLeaves(tree, minimum(tree)) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We compute the minimum of &lt;code&gt;tree&lt;/code&gt; and then replace all values in the leaves with that result, and everything is fine. However, in 1984, Richard Bird came up with &lt;a href=&#34;http://link.springer.com/article/10.1007/BF00264249#page-1&#34;&gt;a solution&lt;/a&gt; that uses a single inspection. In a single pass, we compute both the minimum of a tree, and a function that, given the minimum, returns the new tree. That function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func repMinHelper(t: Tree) -&amp;gt; (Int, Int -&amp;gt; Tree) {
    switch t {
    case .Node(let l, let r):
        let (lMin, lBuild) = repMinHelper(l)
        let (rMin, rBuild) = repMinHelper(r)
        return (min(lMin,rMin), 
                { x in .Node(lBuild(x), rBuild(x)) })
    case .Leaf(let value):
        return (value, { x in .Leaf(x) })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we can solve the repmin problem by creating a new function &lt;code&gt;repMin&lt;/code&gt; that wraps the helper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func repMin(t: Tree) -&amp;gt; Tree {
    let (min, builder) = repMinHelper(t)
    return builder(min)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty cool: in a single inspection, we compute both the minimum value and a function to build the new tree. This relates strongly to &lt;a href=&#34;http://en.wikipedia.org/wiki/Attribute_grammar&#34;&gt;attribute grammars&lt;/a&gt;: we can think of the minimum as a synthesized attribute, and the new tree uses that synthesized attributed as an inherited attribute.&lt;/p&gt;

&lt;p&gt;In a way, it also reminds me of &lt;a href=&#34;https://github.com/mbrandonw/learn-transducers-playground&#34;&gt;transducers&lt;/a&gt;: transducers combine multiple functions that operate on lists, but compute everything using a single pass. The technique above is a little bit similar, but for tree-structures. I can&amp;rsquo;t really see a useful way to apply this in my production code, but it&amp;rsquo;s an interesting exercise nonetheless.&lt;/p&gt;

&lt;p&gt;The full code is &lt;a href=&#34;https://gist.github.com/chriseidhof/6b4d1c8a542003d60cb9&#34;&gt;available as a gist&lt;/a&gt;, and uses &lt;code&gt;Box&lt;/code&gt; to work around Swift&amp;rsquo;s limitations with recursive enums.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>2014</title>
          <link>http://chris.eidhof.nl/post/2014/</link>
          <pubDate>Wed, 17 Dec 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/2014/</guid>
          <description>&lt;p&gt;Continuing from my &lt;a href=&#34;http://chris.eidhof.nl/posts/2013.html&#34;&gt;2013 retrospective&lt;/a&gt;, here&amp;rsquo;s one for 2014.&lt;/p&gt;

&lt;p&gt;In the beginning of the year, Florian and me moved into the A Color Bright office (which has been awesome). We continued working on Deckset, and &lt;a href=&#34;http://chris.eidhof.nl/posts/we-launched-deckset.html&#34;&gt;launched Deckset&lt;/a&gt; in April. It&amp;rsquo;s been a really rewarding experience to have a product out, maintain it and have lots of happy users. We have some great plans for next year.&lt;/p&gt;

&lt;p&gt;In May, we organized the second edition of &lt;a href=&#34;http://2014.uikonf.com&#34;&gt;UIKonf&lt;/a&gt;. It has been a blast, and except for one person, we only heard really nice feedback. I&amp;rsquo;m super happy that later in the year we decided to hand over UIKonf to a new team, and even more excited to be attending next year&amp;rsquo;s UIKonf without being an organizer.&lt;/p&gt;

&lt;p&gt;In June, I went hiking with Pim in the Polish mountains. This was during WWDC, and there we heard about Swift. After coming home from my trip, it was very clear to me that we had to write a book on &lt;a href=&#34;http://chris.eidhof.nl/posts/functional-programming-in-swift.html&#34;&gt;Functional Programming in Swift&lt;/a&gt;. We put up a website, started writing, planning and selling pre-access. We&amp;rsquo;re very happy with how the book turned out, and this is reflected by both the sales and feedback from our readers.&lt;/p&gt;

&lt;p&gt;We kept on putting out monthly issues of &lt;a href=&#34;http://www.objc.io&#34;&gt;objc.io&lt;/a&gt;, and starting creating weekly &lt;a href=&#34;http://www.objc.io/snippets/&#34;&gt;functional snippets&lt;/a&gt;. This still takes quite a bit of effort, but we have smoothened the process. There has been another big batch of awesome authors who wrote some great stuff. It&amp;rsquo;s a really rewarding project. Because of objc.io and the book, I&amp;rsquo;ve been &lt;a href=&#34;http://github.com/chriseidhof/speaking/&#34;&gt;speaking&lt;/a&gt; a lot last year. It&amp;rsquo;s been awesome to travel so much and meet so many nice people all over the world. Some of my favorite places from last year were Istanbul, Poland and Minsk. I&amp;rsquo;ve been to only one conference where I wasn&amp;rsquo;t involved as an organizer or speaker, and that was &lt;a href=&#34;http://makerland.com&#34;&gt;Makerland&lt;/a&gt;, which was really, really awesome.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been to the USA twice this year. In fact, I&amp;rsquo;m writing this from New York, where I&amp;rsquo;m staying for 6 weeks this winter. I really like the city, although I do miss Berlin quite a bit! In the summer I spent another 4 weeks all over the country, in New York, Boulder, Denver, San Francisco and more New York. I fell in love with Boulder and its mountains. In NY, I met many great new people. Two weeks ago, together with &lt;a href=&#34;https://twitter.com/mbrandonw&#34;&gt;Brandon&lt;/a&gt; I organized the &lt;a href=&#34;http://2014.funswiftconf.com&#34;&gt;Functional Swift Conference&lt;/a&gt;, which was a great success.&lt;/p&gt;

&lt;p&gt;There has been some solid running in 2014: I&amp;rsquo;ve hit the 2000km mark early December. My favorite running spots were the Alps and the Rockies, where I would wake up, run up a mountain, eat lunch, run back down and then write. I also ran &lt;a href=&#34;http://chris.eidhof.nl/posts/race-report-munich-marathon.html&#34;&gt;my first real marathon&lt;/a&gt;, which didn&amp;rsquo;t really go as well as I wanted. Directly after that, I started training with &lt;a href=&#34;https://twitter.com/markpersista&#34;&gt;Mark&lt;/a&gt; as my coach, and he made an awesome schedule on the way to the Rotterdam Marathon in April 2015.&lt;/p&gt;

&lt;p&gt;Work-wise, we spent the last months finishing details on the print version of our book, maintaining Deckset and objc.io, but also have put in a lot of work &lt;a href=&#34;https://twitter.com/getscenery&#34;&gt;creating our new app&lt;/a&gt;. It&amp;rsquo;s going to be another Mac app, and we hope to be ready in early 2015. I expect this to save people a lot of time, maybe even more so than Deckset. Once we ship it, I&amp;rsquo;ve achieved one of my goals originally set for 2012: have three products out there. Only late by a few years.&lt;/p&gt;

&lt;p&gt;Thanks to all the awesome people who made this year so great. ❤&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Burnout: five years later</title>
          <link>http://chris.eidhof.nl/post/burnout-five-years-later/</link>
          <pubDate>Sun, 30 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/burnout-five-years-later/</guid>
          <description>&lt;p&gt;About five years ago, I had a burnout. Or at least, something very similar to it. I had no joy programming anymore, &lt;em&gt;especially&lt;/em&gt; programming for iOS. I wrote some stream-of-consciousness &lt;a href=&#34;http://chris.eidhof.nl/posts/how-i-got-a-burnout.html&#34;&gt;posts&lt;/a&gt; about it. Now, five years later, I&amp;rsquo;m a very happy programmer again. I&amp;rsquo;m writing this to figure out what happened in between.&lt;/p&gt;

&lt;p&gt;When I realized things weren&amp;rsquo;t going to well with me, the first thing that I did is taking a few months off. I hardly did any programming. In fact, I hardly did anything at all. I did start taking running a bit more serious, and really tried to put some effort into that. I believe the running was a big factor in helping me through the burnout, both because it helps against depression and it made me feel good about myself. Even at the moment I&amp;rsquo;m writing this, I have just put in a hard run and am still high on the endorphins.&lt;/p&gt;

&lt;p&gt;I started thinking really hard about other ways to make a living, but couldn&amp;rsquo;t really figure out what I wanted. I did not get excited at all about any technology-related stuff. The &amp;ldquo;best&amp;rdquo; idea was to start a trail running company that organizes trips to mountainous areas for people who live in flat places. I moved to Berlin. I had some small iOS gigs going on to pay the bills, but I wasn&amp;rsquo;t too happy (although I was happier than in the beginning). Then, at some point, I decided I needed to take on some bigger gigs to make sure I could keep paying the bills, and started doing lots of things. I got busy, and at some point started working with &lt;a href=&#34;https://twitter.com/floriankugler&#34;&gt;Florian&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Working with him made things really fun again, for many different reasons. We had a challenging project and took the time to do things right. He was inexperienced on the iOS platform, but really challenged lots of my habits, and I learned a lot. At the same time, I started organizing the first edition of &lt;a href=&#34;http://www.uikonf.com&#34;&gt;UIKonf&lt;/a&gt;. Doing all these things was just so much fun. It did &amp;ldquo;feel like work&amp;rdquo; sometimes, but because of the results we were getting, it was awesome.&lt;/p&gt;

&lt;p&gt;Around the same time, I started objc.io, together with Florian and &lt;a href=&#34;https://twitter.com/danielboedewadt&#34;&gt;Daniel&lt;/a&gt;. I already knew working with Florian was awesome. Working with Daniel was just as awesome, but for different reasons. He is both really smart and has &lt;em&gt;a lot&lt;/em&gt; of experience. It is so nice writing things and having Daniel say: &amp;ldquo;well, actually&amp;hellip;&amp;rdquo; and learning so much from his explanations. He often solves problems in a very elegant way that is obvious to understand, but not so easy to come up with. Learning all this stuff made programming a lot of fun again.&lt;/p&gt;

&lt;p&gt;Looking back, I think I might have &lt;a href=&#34;http://chris.eidhof.nl/posts/reaching-a-plateau.html&#34;&gt;reached a plateau&lt;/a&gt; when I got the burnout. Taking a long break and having a new hobby was really good. After that, learning lots of new things and accepting that I hardly knew anything really made me excited about programming again. Finally, a major part is other people: working together with people who challenge you is really great. If you&amp;rsquo;re struggling with similar problems: it took me a few years, but this is what worked for me.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>CocoaConf</title>
          <link>http://chris.eidhof.nl/post/cocoaconf/</link>
          <pubDate>Sat, 22 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/cocoaconf/</guid>
          <description>

&lt;p&gt;This summer, I was in touch with CocoaConf about speaking at their Boston edition. After they checked their schedules, they confirmed me as a speaker, and asked me if I could swing a second talk so that they could cover my flight from NY and my hotel. I&amp;rsquo;ve never given two talks at a single conference, but I was happy to do it: challenge accepted.  I started organizing my flight to the US around this, I had started planning my two talks, and got super excited about meeting all these awesome people.&lt;/p&gt;

&lt;p&gt;Just three weeks before the conference, I got an email that both of my talks were cancelled, because they had overbooked on speakers. I felt like it could have been an honest mistake, but it did make me feel sad, because I was really looking forward to this. However, these things can happen.&lt;/p&gt;

&lt;p&gt;At the same time, I saw that another speaker (who works for one of the sponsors) had just been announced. It turns out that he works for one of the sponsors (he&amp;rsquo;s a great guy, and deserves no blame in this story).
It wasn&amp;rsquo;t clear at the time, but after asking about it specifically, I found out I got bumped because of a sponsored talk.
CocoaConf offered me a free ticket to make up for it, but I gave it away.&lt;/p&gt;

&lt;p&gt;Bumping speakers is not so cool, but I imagine it can happen sometimes. Bumping me without telling me upfront that they were doing it to make room for a sponsored speaker made me feel really shitty. About a week ago they asked my if I wanted to speak in Atlanta, and I told them in clear words that this experience made me never want to speak at CocoaConf again. A similar thing happened with the GOTO conference once, but at least they told me directly that I was being bumped because of a sponsored talk.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t mind if conference organizers make an honest mistake. I&amp;rsquo;ve slept in really bad hotels, had to wait at airports for a really long time, have experienced bad tech setups and it&amp;rsquo;s all fine. I know how tough it is to be a conference organizer. Mistakes happen. If this had happened at a small indie conference, I would&amp;rsquo;ve been less upset (but probably still not come back). However, because this came from a professional organization who have been doing this for years, just the bumping made me feel really sad. The fact that they did not tell me up front that it was because of a sponsored talk and that I had to figure it out myself made me feel very disrespected.&lt;/p&gt;

&lt;h3 id=&#34;update-https-github-com-chriseidhof-chris-eidhof-nl-commit-87a4feff9a30c510b7e5714f60a8d78504b0b9f8&#34;&gt;&lt;a href=&#34;https://github.com/chriseidhof/chris.eidhof.nl/commit/87a4feff9a30c510b7e5714f60a8d78504b0b9f8&#34;&gt;Update&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Dave from CocoaConf send me an email asking to clarify some misinformation:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;As I told you when you asked, we had promised [him] spots in Boston and Atlanta long before you contacted us, but we had forgotten to add him to the site.  The same thing happened with another speaker.  Also, [his company] was not even signed up as a sponsor at the time that we agreed to have him speak.  His speaking slots are not tied, in any way, to [their] sponsorship and never have been.  In fact, we do not have any sponsored speakers, other than lunch time, optional demos.  You can see our sponsorship prospectus online.  There are no speaking slots included with any sponsorship level.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I edited it to remove the name of the sponsor because it doesn&amp;rsquo;t matter.  Also, Dave mentions that they are part-time family business, and barely covering costs.  It could very well be that my interpretation of the events was wrong.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Lenses in Swift</title>
          <link>http://chris.eidhof.nl/post/lenses-in-swift/</link>
          <pubDate>Tue, 11 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/lenses-in-swift/</guid>
          <description>&lt;p&gt;This is another FP-inspired blogpost, this time about lenses. There&amp;rsquo;s &lt;a href=&#34;http://www.cis.upenn.edu/~bcpierce/papers/index.shtml#Lenses&#34;&gt;a lot of
literature&lt;/a&gt;
around lenses, but I wanted to show some simple examples.&lt;/p&gt;

&lt;p&gt;Sometimes, you have a set of data (this could be anything, from a struct to a Core Data database, or a webservice), and you want to create a view on that data. For example, suppose you have a value of type &lt;code&gt;Person&lt;/code&gt;, you might want to create a view that only has a specific person&amp;rsquo;s address. And from that address, you want to take the street name. Then, somewhere else in the code, you might want to update this street name, and finally, update the original &lt;code&gt;Person&lt;/code&gt;. To make it concrete, let&amp;rsquo;s define two datatypes &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt; (sorry about the trailing underscores):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Person {
    let name_ : String
    let address_ : Address
}

struct Address {
    let street_ : String
    let city_ : String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Getting a person&amp;rsquo;s street name is simple: given a &lt;code&gt;person&lt;/code&gt;, you can just write &lt;code&gt;person.address_.street_&lt;/code&gt;. However, updating a person with a new street name is a bit more complicated. Because we defined our &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt; as immutable structs, there&amp;rsquo;s no simple way. With mutable code, we could have just changed the values.&lt;/p&gt;

&lt;p&gt;In Objective-C, we could have used key-value coding, and the keypath &lt;code&gt;&amp;quot;address_.street_&amp;quot;&lt;/code&gt; can be used both for getting the street out (using &lt;code&gt;valueForKey:&lt;/code&gt;), and for updating the street (using &lt;code&gt;setValue:forKey:&lt;/code&gt;). In Swift, this is generally not possible.&lt;/p&gt;

&lt;p&gt;This is where lenses come in. A lens is simply the combination of a getter (e.g. getting the address out of a person) and a setter (a function that, given a person and a changed address, creates a new person value with the updated address). In code, it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Lens&amp;lt;A,B&amp;gt; {
    let from : A -&amp;gt; B
    let to : (B, A) -&amp;gt; A
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, the lens for &lt;code&gt;address_&lt;/code&gt; consists of a function that takes the &lt;code&gt;address_&lt;/code&gt; out, and a function creating a new person with the original name (&lt;code&gt;$1&lt;/code&gt; is the original value), but the updated address:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let address : Lens&amp;lt;Person,Address&amp;gt; = Lens(from: { $0.address_ }, to: {
    Person(name_: $1.name_, address_: $0)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, we can write a lens for the address&amp;rsquo;s &lt;code&gt;street_&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let street : Lens&amp;lt;Address,String&amp;gt; = Lens(from: { $0.street_ }, to: {
    Address(street_: $0, city_: $1.city_)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if we want to change an address&amp;rsquo;s street, we can use the following syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let newAddress = street.to(&amp;quot;My new street name&amp;quot;, existingAddress)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without lenses, the code would have looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let newAddress = Address(street_: &amp;quot;My new street name&amp;quot;, city_: existingAddress.city)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a way, it looks like we might not have gained much. But there is something really cool we can do: composing lenses! If you&amp;rsquo;ve been following our &lt;a href=&#34;http://www.objc.io/snippets/2.html&#34;&gt;functional snippets&lt;/a&gt;, you&amp;rsquo;ve already seen function composition. We can write a similar composition operator for lenses. When reading this, don&amp;rsquo;t focus on the implementation, but just look at the type: it takes a lens from A to B, and a lens from B to C, and composes them into a new lens from A to C.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func &amp;gt;&amp;gt;&amp;gt;&amp;lt;A,B,C&amp;gt;(l: Lens&amp;lt;A,B&amp;gt;, r: Lens&amp;lt;B,C&amp;gt;) -&amp;gt; Lens&amp;lt;A,C&amp;gt; {
    return Lens(from: { r.from(l.from($0)) }, to: { (c, a) in
        l.to(r.to(c,l.from(a)), a)
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can use this to compose the &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;street&lt;/code&gt; lenses:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let personStreet = address &amp;gt;&amp;gt;&amp;gt; street
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use the getter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let robb = Person(name_: &amp;quot;Robb&amp;quot;, address_: Address(street_: &amp;quot;Alexanderplatz&amp;quot;, city_: &amp;quot;Berlin&amp;quot;))
let robbsStreet = personStreet.from(robb)
// Evaluates to &amp;quot;Alexanderplatz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the setter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let robb2 = personStreet.to(&amp;quot;Kottbusser Damm&amp;quot;, robb)
// Creates a new `Person` with an updated street
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in a way, this &lt;code&gt;address &amp;gt;&amp;gt;&amp;gt; street&lt;/code&gt; is similar to the keypath &lt;code&gt;&amp;quot;address_.street_&amp;quot;&lt;/code&gt;, except that it&amp;rsquo;s fully typed.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot more cool stuff that you can do with lenses, but that&amp;rsquo;s for a later post. One idea: this could be very useful when applied to the &lt;a href=&#34;http://www.objc.io/issue-13/mvvm.html&#34;&gt;ViewModel&lt;/a&gt; pattern. You could have an immutable model X, create a lens to a mutable ViewModel Y that you pass around, and then once you&amp;rsquo;re done, you can update the original model X with the new value in Y. In order to build that, you would need a bit more infrastructure around lenses (just function composition won&amp;rsquo;t be enough), but we can just look at &lt;a href=&#34;http://hackage.haskell.org/package/fclabels&#34;&gt;existing implementations&lt;/a&gt; and port that to Swift.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>A tiny networking library</title>
          <link>http://chris.eidhof.nl/post/tiny-networking-in-swift/</link>
          <pubDate>Fri, 07 Nov 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/tiny-networking-in-swift/</guid>
          <description>&lt;p&gt;For a new project we&amp;rsquo;ve been working on at Unsigned Integer, the company behind &lt;a href=&#34;http://www.decksetapp.com&#34;&gt;Deckset&lt;/a&gt;, we needed to wrap a webservice API. I had a look at both &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire&lt;/a&gt; and &lt;a href=&#34;https://github.com/AshFurrow/Moya&#34;&gt;Moya&lt;/a&gt;. Alamofire is a full-featured networking library, and if I would need something with more features, I would almost certainly use it. Moya is also very nice, and is built on top of Alomofire, and provides some extra safety. However, neither of them provide a simple way to parse results, so I started to experiment a bit. The library&amp;rsquo;s source is &lt;a href=&#34;https://gist.github.com/chriseidhof/26bda788f13b3e8a279c&#34;&gt;available as a gist&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My design goal was to have a way of describing API endpoints in such a way that I don&amp;rsquo;t have to use any strings when calling them, and I wanted both the input data and output data converted automatically. After a couple of iterations, I ended up with a simple struct to describe a resource that returns a value of type &lt;code&gt;A&lt;/code&gt;. It contains an endpoint&amp;rsquo;s path, the HTTP method, an optional request body, and some headers specific to the request. The last parameter is the most interesting: it&amp;rsquo;s a way to parse the response: a function that produces an &lt;code&gt;A&lt;/code&gt; from the response data. Because this parsing might fail, the result is an optional.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Resource&amp;lt;A&amp;gt; {
    let path: String
    let method : Method
    let requestBody: NSData?
    let headers : [String:String]
    let parse: NSData -&amp;gt; A?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As an example, we can construct a resource for the Github &lt;a href=&#34;https://developer.github.com/guides/getting-started/&#34;&gt;zen endpoint&lt;/a&gt;. It says the path is &amp;ldquo;zen&amp;rdquo;, it uses the &lt;code&gt;GET&lt;/code&gt; method, has no request body or headers, and simply parses the data as an UTF-8 encoded string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func parseString(data: NSData) -&amp;gt; String? {
    return NSString(data: data, encoding: NSUTF8StringEncoding)
}

func zen() -&amp;gt; Resource&amp;lt;String&amp;gt; {
    return Resource(path: &amp;quot;zen&amp;quot;, method: Method.GET, 
                    requestBody: nil, headers: [:], parseString)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fetch this resource, there&amp;rsquo;s another function called &lt;code&gt;apiRequest&lt;/code&gt;. As we will see later on, we will wrap this function for our purposes, but for now, we&amp;rsquo;ll call it directly. The implementation is not too important, in order to understand it we only need to look at the type signature. It takes a &lt;code&gt;modifyRequest&lt;/code&gt; function, which we&amp;rsquo;ll ignore, a base URL (e.g. &lt;code&gt;https://api.github.com&lt;/code&gt;), a resource (e.g. &lt;code&gt;zen()&lt;/code&gt;), and then it takes two callback functions: one for the failure case, which provides a reason and an optional response body, and one for the success case. The completion handler is only called when the request returns a status code of 200, and when the parse function returns a non-nil result.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func apiRequest&amp;lt;A&amp;gt;(modifyRequest: NSMutableURLRequest -&amp;gt; (), 
                   baseURL: NSURL,
                   resource: Resource&amp;lt;A&amp;gt;,
                   failure: (Reason, NSData?) -&amp;gt; (),
                   completion: A -&amp;gt; ())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can construct a call. At first, we don&amp;rsquo;t need to modify the request, so we just pass in a function that does nothing. For the failure handler, we define a function that logs the failure to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func defaultFailureHandler(failureReason: Reason, data: NSData?) {
    let string = NSString(data: data!, encoding: NSUTF8StringEncoding)
    println(&amp;quot;Failure: \(failureReason) \(string)&amp;quot;)
}

let baseURL = NSURL(string: &amp;quot;https://api.github.com&amp;quot;)!

apiRequest({ _ in }, baseURL, zen(), defaultFailureHandler) { message in
    println(&amp;quot;Got a message: \(message)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this code, we&amp;rsquo;ll get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Got a message: Encourage flow.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works perfectly. Now, let&amp;rsquo;s try our hand at something a bit more difficult: getting and parsing a JSON result. In this case, we set some headers (the content-type, and the authorization token). Then instead of passing in the &lt;code&gt;parseString&lt;/code&gt; function that we used earlier, we pass in the &lt;code&gt;decodeJSON&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func decodeJSON(data: NSData) -&amp;gt; JSONDictionary? {
    return NSJSONSerialization.JSONObjectWithData(data, options: 
              NSJSONReadingOptions.allZeros, error: nil) 
      as? [String:AnyObject]
}

func authenticatedUser() -&amp;gt; Resource&amp;lt;JSONDictionary&amp;gt; {
    let headers = [&amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;]
    return Resource(path: &amp;quot;user&amp;quot;, method: Method.GET, requestBody: nil, 
                    headers: headers, decodeJSON)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we expect to have lots of times where we would like to encode and decode JSON for an API call, we can make a &lt;em&gt;smart constructor&lt;/em&gt;. This is a wrapper around the &lt;code&gt;Resource&lt;/code&gt; init function which will do the extra work of encoding JSON, decoding JSON and setting the right headers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func jsonResource&amp;lt;A&amp;gt;(path: String, method: Method, requestParameters: JSONDictionary, parse: JSONDictionary -&amp;gt; A?) -&amp;gt; Resource&amp;lt;A&amp;gt; {
    let f = { decodeJSON($0) &amp;gt;&amp;gt;= parse }
    let jsonBody = encodeJSON(requestParameters)
    let headers = [&amp;quot;Content-Type&amp;quot;: &amp;quot;application/json&amp;quot;]
    return Resource(path: path, method: method, requestBody: jsonBody, headers: headers, parse: f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can rewrite our &lt;code&gt;authenticatedUser&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func authenticatedUser() -&amp;gt; Resource&amp;lt;JSONDictionary&amp;gt; {
    return jsonResource(path: &amp;quot;user&amp;quot;, method: Method.GET, 
                        requestParameters: [:]) { $0 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, instead of a dictionary, we would really like to parse this into a &lt;code&gt;GithubProfile&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct GithubProfile {
    let login: String
    let id: Int
    let avatarURL: NSURL
}

let makeGithubProfile = { GithubProfile(login: $0, id: $1, avatarURL: $2) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use the &lt;a href=&#34;http://chris.eidhof.nl/posts/json-parsing-in-swift.html&#34;&gt;JSON parsing&lt;/a&gt; technique to write a small parsing function and rewrite our &lt;code&gt;authenticatedUser&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func parseGithubProfile(dict: JSONDictionary) -&amp;gt; GithubProfile? {
    return curry(makeGithubProfile) &amp;lt;*&amp;gt; string(dict, &amp;quot;login&amp;quot;)
                                    &amp;lt;*&amp;gt; int(dict, &amp;quot;id&amp;quot;)
                                    &amp;lt;*&amp;gt; url(dict, &amp;quot;avatar_url&amp;quot;)
}

func authenticatedUser() -&amp;gt; Resource&amp;lt;GithubProfile&amp;gt; {
    return jsonResource(&amp;quot;user&amp;quot;, .GET, [:], parseGithubProfile)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For me, this is the power of functional programming. We wrote one &lt;code&gt;apiRequest&lt;/code&gt; function and one &lt;code&gt;Resource&lt;/code&gt; datatype, and never changed it again. We can provide this in a library. We then created a couple of small functions for encoding and decoding JSON, and wrapped the existing functions to create our own convenience functions. The &lt;code&gt;authenticatedUser&lt;/code&gt; is now very tiny.&lt;/p&gt;

&lt;p&gt;As a final step, we&amp;rsquo;ll wrap the &lt;code&gt;apiRequest&lt;/code&gt; function in a new function that&amp;rsquo;s tied to the Github API. It sets the authorization token, and provides the base URL. The completion handler is called only in case of success:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func request&amp;lt;A&amp;gt;(resource: Resource&amp;lt;A&amp;gt;, completionHandler: A -&amp;gt; ()) {
    func setAuthToken(request: NSMutableURLRequest) {
        request.setValue(&amp;quot;token \(authorizationToken)&amp;quot;, forHTTPHeaderField: &amp;quot;Authorization&amp;quot;)
    }
    let baseURL = NSURL(string: &amp;quot;https://api.github.com&amp;quot;)!
    apiRequest(setAuthToken, baseURL, resource, defaultFailureHandler, completionHandler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can test our API with the following simple statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request(authenticatedUser()) { user in
    println(&amp;quot;User&#39;s avatar URL: \(user.avatarURL)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think designing a library like this has a lot of benefits. We provided some base functionality, and then by composing and wrapping functions into new functions we quickly made it very specific to our app without having to put in much effort. There are no complicated configuration steps, just simple function composition.&lt;/p&gt;

&lt;p&gt;If you want to learn more about how to design APIs in a functional way, do consider reading our book on &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;Functional Programming in Swift&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Race Report: Munich Marathon</title>
          <link>http://chris.eidhof.nl/post/race-report-munich-marathon/</link>
          <pubDate>Mon, 13 Oct 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/race-report-munich-marathon/</guid>
          <description>&lt;p&gt;Today, I want to write about non-code: yesterday I ran my first real marathon. Although I did run the distance before, never in a road race. Another runner I met once said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;One of the best things you can do for your body, is train for a marathon. One of the worst things you can do is to actually run it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I couldn&amp;rsquo;t agree more. I&amp;rsquo;ve been feeling really good after all the training, however, today, the day after the marathon, my body is not so happy.&lt;/p&gt;

&lt;p&gt;Even after running a lot over the last years, the sheer idea of running a marathon at full speed is bit daunting. Nevertheless, my friend and me decided to do it, and had about half a year to specifically prepare for this marathon. We did track work, lots of long runs in the cold and the heat, I spent a week running up mountains in Boulder, and finally prepared with some races (half-marathons and a 25K). The races went really well, I ran the half marathon in 1:26 the day after I got back from the States, and I was very confident that I could run the entire marathon in 3 hours.&lt;/p&gt;

&lt;p&gt;The first bit went good, we started too slow (it&amp;rsquo;s always very crowded at the beginning of the race). But we really nailed the pace, very steady and almost exactly as we planned (4:15/km). It didn&amp;rsquo;t feel as easy as expected, and at km 15 my friend said he either had to slow down or drop out in a bit. I was feeling exactly the same way, but we decided to keep on going until the half marathon point, arriving there at 1:30. A bit before that, I couldn&amp;rsquo;t push anymore and had to let him go ahead of me. Surprisingly, at km 23 he was standing at the side, and joined me, telling me he was about to drop out. I wanted to do the same thing, and said: let&amp;rsquo;s run to 25k, and stop there.&lt;/p&gt;

&lt;p&gt;At 25k, we started walking on the sidewalk, feeling horrible. My legs were hurting, and I was tired, but not exhausted. We were about to go look for a train stop, but I decided to give it one more try. I didn&amp;rsquo;t come all the way to Munich to quit at 25k. Even though there was no chance anymore of running a 3-hour marathon, at least I could run a bit more. Maybe until the 30k point. Because I had already given up and quit, anything that I&amp;rsquo;d do now would feel like winning. I managed to run to the 30k point, my pace dropping quite a bit. At every aid station I walked with my drink, instead of running, and at 35k I picked up another friend who was walking. If you want to know what dropping the pace looks like, check out &lt;a href=&#34;http://www.strava.com/activities/206659319&#34;&gt;strava&lt;/a&gt;. A fast race is very evenly paced: this wasn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;We managed to run 2k more, I had to walk, and that&amp;rsquo;s basically what happened for the final five kilometers: running, interspersed with bits of walking. The final 400m was a &amp;ldquo;victory lap&amp;rdquo; through the Olympic Stadium, which I couldn&amp;rsquo;t enjoy it at all because of pure exhaustion. I finished seconds under 3:28, got the medal, drank lots of alcohol-free beer and ate, and was actually quite happy. Even though I did not even come close to what I came here for, I did manage to come back from giving up, adjusted my goals, and really overcame myself by finishing the thing. I&amp;rsquo;m not sure what went wrong, but one day in the next 10 years, I&amp;rsquo;ll run it in under 3 hours. However, first it&amp;rsquo;s time for some new challenges.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Tuples, Structs and Enums</title>
          <link>http://chris.eidhof.nl/post/tuples-structs-enums/</link>
          <pubDate>Fri, 29 Aug 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/tuples-structs-enums/</guid>
          <description>

&lt;p&gt;Swift has lots of different ways of storing your data. You can use enums, tuples, structs, classes (or even just use malloc and manage it yourself)! In this article, we&amp;rsquo;ll compare enums, tuples and structs. Let&amp;rsquo;s start with the simplest: tuples.&lt;/p&gt;

&lt;p&gt;A tuple is a typed list of values. For example, you can define a tuple that holds an integer and a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let amount = (100, &amp;quot;EUR&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very useful when you want to return multiple values from a function. To get the values out, you can use &lt;code&gt;.0&lt;/code&gt;, &lt;code&gt;.1&lt;/code&gt; (and so on), or pattern matching. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let currency = money.1 // &amp;quot;USD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to, you can also name the individual elements, to have a bit more documentation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let money = (amount: 100, currency: &amp;quot;USD&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you can still use &lt;code&gt;.1&lt;/code&gt;, but alternatively, you can also use &lt;code&gt;.currency&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let currency = money.currency // &amp;quot;USD&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to write a formatter for currencies, we can now do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func format(input: (Int,String)) -&amp;gt; String {
    return &amp;quot;I have \(input.0) \(input.1) in my wallet&amp;quot;
}

println(format(money)) // This prints &amp;quot;I have 100 USD in my wallet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our format function works on any &lt;code&gt;(Int,String)&lt;/code&gt; tuple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mass = (1, &amp;quot;kg&amp;quot;)

let formatted = format(mass) // &amp;quot;I have 1 kg in my wallet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clearly, having 1 kg in your wallet doesn&amp;rsquo;t make sense. Therefore, let&amp;rsquo;s introduce a struct. A struct can hold exactly the same kind of a data as a tuple. In addition, you can also define functions on the struct itself (whereas with tuples, you can only define top-level functions). Let&amp;rsquo;s consider the following struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Money {
    let amount: Int
    let currency: String
}

let wallet = Money(amount: 100, currency: &amp;quot;USD&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can hold exactly the same kind of data as a tuple, but now we can also define a function on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Money {
  func format() -&amp;gt; String {
    return &amp;quot;I have \(self.amount) \(self.currency) in my wallet&amp;quot;
  }
}

println(wallet.format())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to make a distinctive type for mass, we can now do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Mass {
    let quantity: Int
    let unit: String

    func format() -&amp;gt; String {
        return &amp;quot;I have \(self.quantity) \(self.unit) in my backpack.&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not only do we now have functions on our &lt;code&gt;Money&lt;/code&gt; type, we also have given it an explicit name. In other parts of our code, we can be certain that we don&amp;rsquo;t accidentally pass in a mass pair (like &lt;code&gt;(1, &amp;quot;kg&amp;quot;)&lt;/code&gt;). A struct is also called a &lt;a href=&#34;http://en.wikipedia.org/wiki/Nominal_type_system&#34;&gt;nominal type&lt;/a&gt;: it gives an explicit name to a type, and values only have the same type if they share that name. In the example above, &lt;code&gt;mass&lt;/code&gt; and the first definition of &lt;code&gt;wallet&lt;/code&gt; have the same type, but values of type &lt;code&gt;Money&lt;/code&gt; and &lt;code&gt;Mass&lt;/code&gt; have different types. If we call &lt;code&gt;format&lt;/code&gt; on them, we get different results.&lt;/p&gt;

&lt;h3 id=&#34;enums&#34;&gt;Enums&lt;/h3&gt;

&lt;p&gt;If we want to store some values together, we now know that we can use a tuple or a struct, depending on the use-case. We can also use classes, but that&amp;rsquo;s beyond the scope of this article. However, sometimes we want to represent a choice between some values. For example, let&amp;rsquo;s consider currencies. In the previous example, we&amp;rsquo;ve used &lt;code&gt;String&lt;/code&gt; to use the currency, but what if we want to restrict our program to only currencies we know about? This is where we can use an enum. For example, if we want to restrict our program to only euros, US dollars and yen, we can write the following enum:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Currency {
   case EUR
   case USD
   case YEN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if we have a value of type &lt;code&gt;Currency&lt;/code&gt;, we know that it will be either &lt;code&gt;EUR&lt;/code&gt;, &lt;code&gt;USD&lt;/code&gt; or &lt;code&gt;YEN&lt;/code&gt;. There is no way it can be of any other value, or multiple of these values at the same time. Just like with structs, you can also define functions on enums:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Currency {
    func symbol() -&amp;gt; String {
        switch self {
            case .EUR: return &amp;quot;€&amp;quot;
            case .USD: return &amp;quot;$&amp;quot;
            case .YEN: return &amp;quot;¥&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add as many cases as we want. However, we could also have an enum with a single case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Angle {
   case Radian(radians: Double)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to having a struct: we can add functions, and it is impossible to accidentally confuse &lt;code&gt;Angle&lt;/code&gt; values with other &lt;code&gt;Double&lt;/code&gt; values. However, if we decide that we want to add more cases in the future, we can do this.&lt;/p&gt;

&lt;h3 id=&#34;what-should-i-use&#34;&gt;What should I use?&lt;/h3&gt;

&lt;p&gt;Now we have a good overview of how to choose between tuples, structs and enums. Start with a tuple and see if it does the job. If two values with the same type structure are the same (e.g. String and Int pairs), excellent. If you want more type-safety and a nominal type, use structs. For example, if you want to disambiguate between currency and mass. Finally, if you need multiple mutually exclusive cases (for example, either EUR or USD or YEN), use enums.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Some ideas for projects in Swift</title>
          <link>http://chris.eidhof.nl/post/swift-ideas/</link>
          <pubDate>Wed, 27 Aug 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/swift-ideas/</guid>
          <description>&lt;p&gt;If you are looking for some programming projects to port to Swift, my list is way bigger than I can tackle. Most ideas here are ports of libraries from other languages, some are different. I would love to build all of these, but can&amp;rsquo;t possibly do even ten percent of this list. The list is in random order.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An &lt;strong&gt;SVG Parser&lt;/strong&gt; that can parse SVG, turn it into an abstract syntax tree, and has support to render it.&lt;/li&gt;
&lt;li&gt;A full version of &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck-2.4.2&#34;&gt;QuickCheck&lt;/a&gt;. I created a very rough &lt;a href=&#34;http://chris.eidhof.nl/posts/quickcheck-in-swift.html&#34;&gt;example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A full wrapper of Core Image, see &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;our book&lt;/a&gt; or &lt;a href=&#34;https://speakerdeck.com/chriseidhof/functional-swift-1&#34;&gt;my presentation&lt;/a&gt; for the basic idea.&lt;/li&gt;
&lt;li&gt;A routing library that takes enums and builds URLs, like described &lt;a href=&#34;http://chris.eidhof.nl/posts/typesafe-url-routes-in-swift.html&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;https://github.com/AshFurrow/Moya&#34;&gt;here&lt;/a&gt;, but independent of any networking framework.&lt;/li&gt;
&lt;li&gt;Some functional wrappers around UIControls. Not sure how this would work, maybe something like &lt;a href=&#34;http://conal.net/papers/Eros/&#34;&gt;tangible values&lt;/a&gt;?&lt;/li&gt;
&lt;li&gt;A drawing library like &lt;a href=&#34;http://projects.haskell.org/diagrams/&#34;&gt;diagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A variant of &lt;a href=&#34;http://www.haskell.org/hoogle/&#34;&gt;Hoogle&lt;/a&gt; for Swift. This would allow you to find Swift functions by their type, not by name. Should work together with the standard libraries, and eventually also with CocoaPods.&lt;/li&gt;
&lt;li&gt;A web framework (like Rails or like Sinatra). Some people have already been experimenting in this direction.&lt;/li&gt;
&lt;li&gt;A simple implementation of &lt;a href=&#34;http://mustache.github.io&#34;&gt;Mustache&lt;/a&gt;. The &lt;a href=&#34;https://github.com/janl/mustache.js/blob/master/mustache.js&#34;&gt;Javascript version&lt;/a&gt; is short (under 600 lines).&lt;/li&gt;
&lt;li&gt;A wrapper around GCD. For example, it&amp;rsquo;s possible to write a &lt;code&gt;parallel&lt;/code&gt; function that executes a bunch of functions in parallel: &lt;a href=&#34;https://gist.github.com/chriseidhof/c62e45554c2394bb6871&#34;&gt;gcd.swift&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A port of &lt;a href=&#34;http://www.haskell.org/haskellwiki/Software_transactional_memory&#34;&gt;Software Transactional Memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A parser/pretty-printer combinator library, maybe like &lt;a href=&#34;http://hackage.haskell.org/package/boomerang&#34;&gt;Boomerang&lt;/a&gt;. It would generate both a parser and a pretty-printer from a single grammar.&lt;/li&gt;
&lt;li&gt;A library for binary serialisation (like &lt;a href=&#34;http://hackage.haskell.org/package/cereal&#34;&gt;cereal&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;A library for generating or processing XML (maybe built on top of NSXMLParser?)&lt;/li&gt;
&lt;li&gt;A library for dealing with HTML (like &lt;a href=&#34;http://hackage.haskell.org/package/tagsoup&#34;&gt;tagsoup&lt;/a&gt; or &lt;a href=&#34;http://nokogiri.org&#34;&gt;nokogiri&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;A library for generating PDFs in a combinatoric way (like &lt;a href=&#34;https://github.com/prawnpdf/prawn&#34;&gt;Prawn&lt;/a&gt;, but built on top of Cocoa goodness)&lt;/li&gt;
&lt;li&gt;A native Markdown parsing library (or really good wrapper around &lt;a href=&#34;https://github.com/vmg/sundown&#34;&gt;sundown&lt;/a&gt; or another C library)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br/&gt; If you are starting one of these and would like feedback, ping me!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Type-safe URL routes in Swift</title>
          <link>http://chris.eidhof.nl/post/typesafe-url-routes-in-swift/</link>
          <pubDate>Mon, 18 Aug 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/typesafe-url-routes-in-swift/</guid>
          <description>&lt;p&gt;While Ash Furrow is working on his &lt;a href=&#34;https://github.com/AshFurrow/Moya&#34;&gt;Moya&lt;/a&gt; project, I got inspired by his approach, and decided to write a little bit of code to demonstrate a technique I used in Haskell a few years ago.&lt;/p&gt;

&lt;p&gt;It uses Swift enums to describe API endpoints. Instead of describing endpoints this with strings, you can use Swift&amp;rsquo;s enums to make it type-safe and well-documented. Let&amp;rsquo;s build an example that wraps a very small part of the &lt;a href=&#34;https://developer.github.com/v3/&#34;&gt;GitHub API&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s an API endpoint &amp;ldquo;zen&amp;rdquo;, which works like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl &#39;https://api.github.com/zen&#39;
Favor focus over features.~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a different API endpoint &amp;ldquo;/users/name&amp;rdquo;, which works like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl &#39;https://api.github.com/users/chriseidhof&#39;
{
  &amp;quot;login&amp;quot;: &amp;quot;chriseidhof&amp;quot;,
  &amp;quot;id&amp;quot;: 5382,
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, what we can do is define an enum with a case for all endpoints. Note that the &amp;ldquo;zen&amp;rdquo; endpoint doesn&amp;rsquo;t take any parameters, where as the &amp;ldquo;users&amp;rdquo; endpoint takes a string parameter (the user name):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Github {
    case Zen
    case UserProfile(String)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then define a protocol &lt;code&gt;Path&lt;/code&gt; that, for a given type, describes how to turn this into a &lt;code&gt;String&lt;/code&gt; value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Path {
    var path : String { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can make our Github enum conform to the Path protocol. Because this is just a proof of concept, we don&amp;rsquo;t escape the user&amp;rsquo;s name (which should definitely be done in production code).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Github : Path {
    var path: String {
        switch self {
        case .Zen: return &amp;quot;/zen&amp;quot;
        case .UserProfile(let name): return &amp;quot;/users/\(name)&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having done this work, we can create a route, and get the path out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let sample = Github.UserProfile(&amp;quot;ashfurrow&amp;quot;)
println(sample.path) 
// Prints &amp;quot;/users/ashfurrow&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Ash&amp;rsquo;s library, generates full URLs, and also has sample data included for each endpoint (which makes it really convenient when doing TDD). We can create a protocol that helps us with both:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Moya : Path {
    var baseURL: NSURL { get }
    var sampleData: String { get } // Probably JSON would be better than String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above protocol says that there has to be a base URL of type NSURL, and that for each value of &lt;code&gt;Moya&lt;/code&gt; there should be sample data available in string form (this string would probably contain JSON data).&lt;/p&gt;

&lt;p&gt;Implementing this for the Github API is simple. For the sample data, we use a switch and depending on the case, we return different sample data. We can even use the user&amp;rsquo;s name in the sample data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Github : Moya {
    var baseURL: NSURL { return NSURL(string: &amp;quot;https://api.github.com&amp;quot;) }
    var sampleData: String {
        switch self {
        case .Zen: return &amp;quot;Half measures are as bad as nothing at all.&amp;quot;
        case .UserProfile(let name): return &amp;quot;{login: \&amp;quot;\(name)\&amp;quot;, id: 100}&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the pieces to write a function &lt;code&gt;url&lt;/code&gt; that, given an object conforming to the &lt;code&gt;Moya&lt;/code&gt; protocol, will return us a URL. Note that this doesn&amp;rsquo;t depend on the Github enum at all, it&amp;rsquo;ll work on any type that conforms to the &lt;code&gt;Moya&lt;/code&gt; protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func url(route: Moya) -&amp;gt; NSURL {
    return route.baseURL.URLByAppendingPathComponent(route.path)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;println(url(sample)) 
// prints https://api.github.com/users/ashfurrow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think it&amp;rsquo;s a really nice way of building APIs. The Github enum makes it very clear which endpoints are available, and the form of their parameters. By defining these things once, we can make it much harder for users of this API to make mistakes. For example, it&amp;rsquo;s not possible to pass in a &lt;code&gt;nil&lt;/code&gt; username, because the &lt;code&gt;UserProfile&lt;/code&gt; takes a non-optional string. If we wanted to add optional parameters, we have to be explicit about that.&lt;/p&gt;

&lt;p&gt;The other nice thing is that all of the above code is independent of any networking library. It&amp;rsquo;s so simple that it could be used with any library, be it &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;AlamoFire&lt;/a&gt;, &lt;a href=&#34;http://allseeing-i.com/ASIHTTPRequest/&#34;&gt;ASIHTTPRequest&lt;/a&gt; (remember that?) or just plain &lt;code&gt;NSURLSession&lt;/code&gt;. Enjoy!&lt;/p&gt;

&lt;p&gt;The full code is available as a gist &lt;a href=&#34;https://gist.github.com/chriseidhof/1fc977ffb856dbcdc113&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>The Blub Paradox in Swift</title>
          <link>http://chris.eidhof.nl/post/blub-paradox-in-swift/</link>
          <pubDate>Sun, 17 Aug 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/blub-paradox-in-swift/</guid>
          <description>&lt;p&gt;In his article &lt;a href=&#34;http://www.paulgraham.com/avg.html&#34;&gt;Beating the Averages&lt;/a&gt;, Paul Graham writes about the Blub paradox. I think this is excellent reading for every programmer, the article is full of interesting advice.&lt;/p&gt;

&lt;p&gt;The Blub paradox is about a hypothetical language Blub, but in this article, we&amp;rsquo;ll talk about Objective-C. Objective-C is a major improvement over C in terms of productivity. I wouldn&amp;rsquo;t know how I would get anything done in C, coming from Objective-C. In C, there&amp;rsquo;s no ARC, no KVO and you have to write a lot of boilerplate. Knowing Objective-C, and looking at a language that is more low-level, it&amp;rsquo;s hard to see why you write anything except low-level code in it.&lt;/p&gt;

&lt;p&gt;However, if you are used to Objective-C, and have never programmed in a language that allows for functional programming (such as Lisp, Haskell or Swift), it&amp;rsquo;s hard to see why you would need that. Objective-C is a perfect language to express your thoughts, and most experienced iOS/Mac developers I know can translate their ideas straight into code.&lt;/p&gt;

&lt;p&gt;Before I started Objective-C, I was writing a lot of my code in Haskell. Haskell has features like generics, pattern matching, easy recursion and first-class functions. Moving to Objective-C was very painful for me: how did people get anything done? Back then, we had to write retain/release statements, modify code in three places to define a property, and there was no easy way to define closures. Another thing I was really missing is a powerful type system that helps you think about state, input and mutability.&lt;/p&gt;

&lt;p&gt;I started writing Objective-C full time, and after a while, I didn&amp;rsquo;t miss most of those features anymore. It&amp;rsquo;s perfectly possible to write beautiful code without it. I embraced the limitations and after about two years, I actually started liking Objective-C. Combined with the powerful frameworks, the iOS platform allowed me to create beautiful applications, and I focused more on the resulting product than on the programming language.&lt;/p&gt;

&lt;p&gt;Now, with the introduction of Swift, I see a lot of confusion: if you&amp;rsquo;ve never used it, a type system with generics might look like overkill. Custom operators are mostly really confusing when you&amp;rsquo;re not accustomed to working with them. Pattern matching looks unnecessary. Optionals are hard to wrap your head around. Functional code looks completely incomprehensible, it&amp;rsquo;s much easier to read and write Objective-C.&lt;/p&gt;

&lt;p&gt;All of these &amp;ldquo;confusing&amp;rdquo; features can help you write much more readable code. If you&amp;rsquo;re not used to them, you might not see that until you thoroughly understand them. If you think Objective-C is a readable language, I couldn&amp;rsquo;t agree more. However, show it to somebody who spent their entire career only writing Python, and they might be very confused by all the square brackets, retain cycles, or block syntax. The same holds for the new possibilities of Swift: if you are not used to them, it might look like nonsense. But the people who wrote Swift know what they are doing, and the new features aren&amp;rsquo;t there to show off how smart they are: it&amp;rsquo;s to help us write better, faster and safer code.&lt;/p&gt;

&lt;p&gt;If you are confused by Swift&amp;rsquo;s new features, it&amp;rsquo;s easy to turn that confusion into anger or frustration. I&amp;rsquo;ve seen this quite a bit, recently. However, instead, you could also try to turn it into curiosity. I think there&amp;rsquo;s a lot to like about Swift, and I&amp;rsquo;d encourage you to dive deeper into the language and new concepts, and maybe you will like it too.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Parsing JSON in Swift</title>
          <link>http://chris.eidhof.nl/post/json-parsing-in-swift/</link>
          <pubDate>Mon, 28 Jul 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/json-parsing-in-swift/</guid>
          <description>&lt;p&gt;headline: Safe and easy&lt;/p&gt;

&lt;p&gt;After reading &lt;a href=&#34;http://inessential.com/2014/06/17/c_in_sheeps_clothing&#34;&gt;Brent&lt;/a&gt;&amp;rsquo;s and &lt;a href=&#34;https://medium.com/swift-programming/b6f4f232e35e&#34;&gt;David&lt;/a&gt;&amp;rsquo;s posts on parsing JSON in Swift, I really wanted to write this post. However, we&amp;rsquo;ve been very busy with writing a book on &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;Functional Programming in Swift&lt;/a&gt;, and I wanted to finish some other things first, so it took a while to come up with it. The full code accompanying this post is on &lt;a href=&#34;https://gist.github.com/chriseidhof/4c071de50461a802874e&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this posts I will give an outline of a parsing library for dealing with JSON in Swift in a type-safe way. I bluntly copied the example JSON from David, and it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var json : [String: AnyObject] = [
  &amp;quot;stat&amp;quot;: &amp;quot;ok&amp;quot;,
  &amp;quot;blogs&amp;quot;: [
    &amp;quot;blog&amp;quot;: [
      [
        &amp;quot;id&amp;quot; : 73,
        &amp;quot;name&amp;quot; : &amp;quot;Bloxus test&amp;quot;,
        &amp;quot;needspassword&amp;quot; : true,
        &amp;quot;url&amp;quot; : &amp;quot;http://remote.bloxus.com/&amp;quot;
      ],
      [
        &amp;quot;id&amp;quot; : 74,
        &amp;quot;name&amp;quot; : &amp;quot;Manila Test&amp;quot;,
        &amp;quot;needspassword&amp;quot; : false,
        &amp;quot;url&amp;quot; : &amp;quot;http://flickrtest1.userland.com/&amp;quot;
      ]
    ]
  ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the challenge is to convert this into an array of Swift structs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Blog {
    let id: Int
    let name: String
    let needsPassword : Bool
    let url: NSURL
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll first show the finished parsing functions, which contains two operators: &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. They might look very foreign, but parsing the entire JSON structure is as simple as this. The rest of the article only describes library code. The parsing below works in such a way, that if the JSON is invalid (e.g. the name is missing, or id is not an integer) the entire result will be nil. There&amp;rsquo;s no need for reflection or KVO, we just have a couple of simple functions and some smart ways to combine them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func parseBlog(blog: AnyObject) -&amp;gt; Blog? {
    return asDict(blog) &amp;gt;&amp;gt;= {
        mkBlog &amp;lt;*&amp;gt; int($0,&amp;quot;id&amp;quot;)
               &amp;lt;*&amp;gt; string($0,&amp;quot;name&amp;quot;)
               &amp;lt;*&amp;gt; bool($0,&amp;quot;needspassword&amp;quot;)
               &amp;lt;*&amp;gt; (string($0, &amp;quot;url&amp;quot;) &amp;gt;&amp;gt;= toURL)
    }
}

let parsed : [Blog]? = dictionary(json, &amp;quot;blogs&amp;quot;) &amp;gt;&amp;gt;= {
    array($0, &amp;quot;blog&amp;quot;) &amp;gt;&amp;gt;= {
        join($0.map(parseBlog))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, what does the above code do? Let&amp;rsquo;s go over the most important functions. First, let&amp;rsquo;s have a look at the &lt;code&gt;dictionary&lt;/code&gt; function. It&amp;rsquo;s a function that, given a dictionary from &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;AnyObject&lt;/code&gt;, tries to find a dictionary with the specified key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func dictionary(input: [String: AnyObject], key: String) -&amp;gt;  [String: AnyObject]? {
    return input[key] &amp;gt;&amp;gt;= { $0 as? [String:AnyObject] }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, in the example JSON we expect the key &amp;ldquo;blogs&amp;rdquo; to contain a dictionary. If the dictionary exists, the above function returns it, otherwise it returns &lt;code&gt;nil&lt;/code&gt;. We can write similar functions for arrays, strings, and integers (here are just their signatures, the full code is on GitHub):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func array(input: [String:AnyObject], key: String) -&amp;gt;  [AnyObject]?
func string(input: [String:AnyObject], key: String) -&amp;gt; String?
func int(input: [NSObject:AnyObject], key: String) -&amp;gt; Int?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s have a look at the outermost structure of our JSON. It is a dictionary, with a key &amp;ldquo;blogs&amp;rdquo;, which contains an array, under the key &amp;ldquo;blog&amp;rdquo;. To parse that, we could have written the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if let blogsDict = dictionary(parsedJSON, &amp;quot;blogs&amp;quot;) {
    if let blogsArray = array(blogsDict, &amp;quot;blog&amp;quot;) {
         // Do something with the blogs array
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, we can define the &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; operator, which takes an optional value, and applies a function only if the optional is not nil. It makes use of the &lt;code&gt;flatten&lt;/code&gt; function, which flattens a nested optional into a single one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operator infix &amp;gt;&amp;gt;= {}
@infix func &amp;gt;&amp;gt;= &amp;lt;U,T&amp;gt;(optional : T?, f : T -&amp;gt; U?) -&amp;gt; U? {
    return flatten(optional.map(f))
}

func flatten&amp;lt;A&amp;gt;(x: A??) -&amp;gt; A? {
    if let y = x { return y }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other operator that&amp;rsquo;s in heavy use is the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; operator. For the parsing of a single blog, we had the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkBlog &amp;lt;*&amp;gt; int(dict,&amp;quot;id&amp;quot;)
       &amp;lt;*&amp;gt; string(dict,&amp;quot;name&amp;quot;)
       &amp;lt;*&amp;gt; bool(dict,&amp;quot;needspassword&amp;quot;)
       &amp;lt;*&amp;gt; (string(dict, &amp;quot;url&amp;quot;) &amp;gt;&amp;gt;= toURL)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read this as a functional call that only gets executed when all optional values are non-nil:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkBlog(int(dict,&amp;quot;id&amp;quot;), string(dict,&amp;quot;name&amp;quot;), bool(dict,&amp;quot;needspassword&amp;quot;), (string(dict, &amp;quot;url&amp;quot;) &amp;gt;&amp;gt;= toURL))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So let&amp;rsquo;s look at the definition of the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; operator. It combines two optional values: as the left operand, it takes a function, and the right operand a parameter to that function. It checks if both operands are non-nil, and then just applies the function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operator infix &amp;lt;*&amp;gt; { associativity left precedence 150 }
func &amp;lt;*&amp;gt;&amp;lt;A, B&amp;gt;(f: (A -&amp;gt; B)?, x: A?) -&amp;gt; B? {
    if let f1 = f {
        if let x1 = x {
            return f1(x1)
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you might wonder what &lt;code&gt;mkBlog&lt;/code&gt; does. It is a &lt;a href=&#34;http://en.wikipedia.org/wiki/Currying&#34;&gt;curried&lt;/a&gt; function that wraps our initializer. First, we create a function with type &lt;code&gt;(Int,String,Bool,NSURL) -&amp;gt; Blog&lt;/code&gt;. Then, the &lt;code&gt;curry&lt;/code&gt; function turns that into &lt;code&gt;Int -&amp;gt; String -&amp;gt; Bool -&amp;gt; NSURL -&amp;gt; Blog&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mkBlog = curry {id, name, needsPassword, url in 
   Blog(id: id, name: name, needsPassword: needsPassword, url: url) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is needed so that we can use &lt;code&gt;mkBlog&lt;/code&gt; together with the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; operator. If we look at the first line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mkBlog : Int -&amp;gt; String -&amp;gt; Bool -&amp;gt; NSURL -&amp;gt; Blog
// int(dict,&amp;quot;id&amp;quot;) : Int?
let step1 = mkBlog &amp;lt;*&amp;gt; int(dict,&amp;quot;id&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that combining them with &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; gives us a new function of type &lt;code&gt;(String -&amp;gt; Bool -&amp;gt; NSURL -&amp;gt; Blog)?&lt;/code&gt;. And if we combine that with a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let step2 = step1 &amp;lt;*&amp;gt; string(dict,&amp;quot;name&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get a function of type &lt;code&gt;(Bool -&amp;gt; NSURL -&amp;gt; Blog)?&lt;/code&gt;. And if we continue doing this, we end up with an optional &lt;code&gt;Blog?&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;I hope you can now understand how all the pieces fit together. By creating a few helper functions and operators, we can make strongly-typed JSON parsing really easy. Instead of optional, we could have also used a different type that would include errors, but that&amp;rsquo;s a topic for a different blog post.&lt;/p&gt;

&lt;p&gt;In our book, we&amp;rsquo;ll be writing in much more detail about these kinds of things (and other really cool stuff). If you&amp;rsquo;re interested, you can already get early access today: &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;Functional Programming in Swift&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Functional Programming in Swift</title>
          <link>http://chris.eidhof.nl/post/functional-programming-in-swift/</link>
          <pubDate>Mon, 14 Jul 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/functional-programming-in-swift/</guid>
          <description>&lt;p&gt;A few weeks ago, after Apple announced their new programming language Swift, it
became very clear to me that we had to write a book on &lt;a href=&#34;http://www.objc.io/books/&#34;&gt;Functional Programming
in Swift&lt;/a&gt;. Once the idea was there, I just couldn&amp;rsquo;t stop
thinking about it anymore. After getting &lt;a href=&#34;http://www.staff.science.uu.nl/~swier004/&#34;&gt;Wouter&lt;/a&gt; and &lt;a href=&#34;http://floriankugler.com&#34;&gt;Florian&lt;/a&gt; on board, I knew we had a killer team for writing this book.&lt;/p&gt;

&lt;p&gt;We decided to do give people early access, so they can read along and comment
as we proceed with the writing. So far, the response has been really great, and I&amp;rsquo;m really happy that we chose to do this. It works like this: after people buy the early access version, we immediately grant them access to a GitHub repository where they can read and comment on the chapters we&amp;rsquo;ve written so far.&lt;/p&gt;

&lt;p&gt;One of the things I only realized after we started: if we do this right, we
might write a book that is still relevant in 5 or 10 years. The book is not
about any specific frameworks, it&amp;rsquo;s about doing functional programming.
Frameworks might change a lot, the principles of functional programming have been the same for a really long time.
Because we write our chapters using &lt;a href=&#34;https://github.com/chriseidhof/literate-swift&#34;&gt;literate
programming&lt;/a&gt; it&amp;rsquo;s very easy for
us to update them later on as the language evolves.&lt;/p&gt;

&lt;p&gt;After we brainstormed a lot of ideas (way more than we could possibly fit into
one book) we picked the best ones, and starting writing chapter outlines and example
code. I&amp;rsquo;m so excited about some of the examples we&amp;rsquo;ll show you: they make
things that were previously complex now very simple. Functional programming can
be like that: making certain programs smaller by a huge factor.&lt;/p&gt;

&lt;p&gt;What I love about Swift is that it allows us to mix functional and
object-oriented programming. We can keep doing all the great stuff that we
know, we can keep using all of Apple&amp;rsquo;s great APIs, but at the same time we can
write parts of our program in a functional style. This book will hopefully show
you examples where the functional style is way more powerful.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Swift Tricks</title>
          <link>http://chris.eidhof.nl/post/swift-tricks/</link>
          <pubDate>Mon, 14 Jul 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/swift-tricks/</guid>
          <description>&lt;p&gt;Here are some quick Swift functions that can make your life easier. First, a function that splits up an array into head and tail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Array {
    var match : (head: T, tail: [T])? {
      return (count &amp;gt; 0) ? (self[0],Array(self[1..&amp;lt;count])) : nil
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func map&amp;lt;A,B&amp;gt;(f: A -&amp;gt; B, arr: [A]) -&amp;gt; [B] {
    if let (head,tail) = arr.match {
        return [f(head)] + map(f, tail)
    } else {
        return []
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you lazily want to generate a list of things, but don&amp;rsquo;t really know how many will be needed, you can use a Generator. It turns out there&amp;rsquo;s a type &lt;code&gt;GeneratorOf&lt;/code&gt; that makes it really easy for us to define one. For example, this is how you can generate an infinite list of numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func naturalNumbers() -&amp;gt; GeneratorOf&amp;lt;Int&amp;gt; {
    var i = 0
    return GeneratorOf { return i++ }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can now just iterate over the generator it with &lt;code&gt;for..in&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for x in naturalNumbers() {
    println(&amp;quot;x: \(x)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, a sketch of how you could wrap &lt;code&gt;NSScanner&lt;/code&gt; to have a more Swift-like API:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Scanner {
    let scanner : NSScanner

    init(string: String) {
        scanner = NSScanner(string: string)
    }

    func scanInt() -&amp;gt; Int? {
        var int : CInt = 0
        let didScan = scanner.scanInt(&amp;amp;int)
        return didScan ? Int(int) : nil
    }

    func scan(token : String) -&amp;gt; Bool {
        return scanner.scanString(token, intoString: nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I hope that these snippets will help a bit in writing cleaner Swift code. Enjoy!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>QuickCheck in Swift</title>
          <link>http://chris.eidhof.nl/post/quickcheck-in-swift/</link>
          <pubDate>Wed, 11 Jun 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/quickcheck-in-swift/</guid>
          <description>&lt;p&gt;This afternoon, I&amp;rsquo;ve been making my first steps in Swift, trying to see how much of my Haskell knowledge I could port. It seems like a lot of cool stuff you can do with types is not yet possible, I already filed some radars.&lt;/p&gt;

&lt;p&gt;As an experiment, this article is also available as a &lt;a href=&#34;http://chris.eidhof.nl/static/quickcheck-in-swift.playground.zip&#34;&gt;playground&lt;/a&gt; and on &lt;a href=&#34;https://github.com/chriseidhof/quickcheck-in-swift-blogpost&#34;&gt;github&lt;/a&gt;. Because we&amp;rsquo;ll need the &lt;code&gt;arc4random&lt;/code&gt; function, we&amp;rsquo;ll start by importing &lt;code&gt;Foundation&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wanted to see if it&amp;rsquo;s possible to implement something like &lt;a href=&#34;http://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt; in Swift. QuickCheck is a really cool library, available in multiple languages, that allows you to quickly check if properties are false. The interface is simple: you give it a property and it tries to falsify that property. Properties are just simple functions that return &lt;code&gt;Bool&lt;/code&gt;s. For example, suppose we have a property that checks whether &lt;code&gt;+&lt;/code&gt; on &lt;code&gt;Int&lt;/code&gt;s is a commutative operation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func prop_plusCommutative(x : Int, y : Int) -&amp;gt; Bool {
    return x + y == y + x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What we can do is just generate a lot of random numbers, and feed them into this property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let numberOfIterations = 100 

for _ in 0..numberOfIterations {
    let valX = Int(arc4random())
    let valY = Int(arc4random())
    assert(prop_plusCommutative(valX,valY))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if we run this, we&amp;rsquo;ll have this checked a hundred times, with different numbers. It&amp;rsquo;s not a guarantee that it&amp;rsquo;s correct, but it&amp;rsquo;s rather a quick way of checking whether there aren&amp;rsquo;t any obvious mistakes. Suppose we try to write a &lt;code&gt;reverse&lt;/code&gt; function for strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension String {
    func reverse() -&amp;gt; String {
        var s = &amp;quot;&amp;quot;
        for char in self {
            s = char + s
        }
        return s
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to check if this is not completely broken, we can take a similar approach:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func prop_doubleReverse(x : String) -&amp;gt; Bool {
    return x.reverse().reverse() == x
}

func random (#from: Int, #to: Int) -&amp;gt; Int {
    return from + (Int(arc4random()) % to)
}

func randomString() -&amp;gt; String {
  let randomLength = random(from: 0, to: numberOfIterations)
  var string = &amp;quot;&amp;quot;
  for i in 0..randomLength {
      let randomInt : Int = random(from: 13, to: 255)
      string += Character(UnicodeScalar(randomInt))
  }
  return string
}

for _ in 0..numberOfIterations {
    assert(prop_doubleReverse(randomString()))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, it&amp;rsquo;s not nice to have to rewrite this &lt;code&gt;0..numberOfIterations&lt;/code&gt; all the time. Instead, we would like to write it like this:&lt;/p&gt;

&lt;pre&gt;
check(prop_doubleReverse)
check(prop_plusCommutative)
&lt;/pre&gt;

&lt;p&gt;How do we get there? It&amp;rsquo;s actually relatively easy. First, we define the &lt;code&gt;Arbitrary&lt;/code&gt; protocol, which generates arbitrary values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Arbitrary {
    class func arbitrary() -&amp;gt; Self
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we can define an instance for &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; (beware, these are just quick and dirty instances):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension String : Arbitrary {
    static func arbitrary() -&amp;gt; String {
      return randomString()
    }
}

extension Int : Arbitrary {
    static func arbitrary() -&amp;gt; Int {
        return random(from: 0, to: 10000)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing left is to define the &lt;code&gt;check&lt;/code&gt; function. First, we define it for a property that takes a single argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func check&amp;lt;X : Arbitrary&amp;gt;(prop : X -&amp;gt; Bool) -&amp;gt; () {
    for _ in 0..numberOfIterations {
        let val = X.arbitrary()
        assert(prop(val))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to overloading, we can also define it for functions that take two arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func check&amp;lt;X : Arbitrary, Y: Arbitrary&amp;gt;(prop: (X,Y) -&amp;gt; Bool) -&amp;gt; () {
    for _ in 0..numberOfIterations {
        let valX = X.arbitrary()
        let valY = Y.arbitrary()
        assert(prop(valX,valY))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s all there is to it. Now we can check our properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;check(prop_doubleReverse)
check(prop_plusCommutative)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can even check closures:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;check({(s : String) -&amp;gt; Bool in countElements(s.reverse()) == countElements(s)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am really looking forward to people taking this idea and implementing QuickCheck for real. I think it could be a very nice addition to the current way of testing.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Intentions</title>
          <link>http://chris.eidhof.nl/post/intentions/</link>
          <pubDate>Tue, 15 Apr 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/intentions/</guid>
          <description>

&lt;p&gt;I&amp;rsquo;m a big fan of lighter view controllers. In the [first issue]() of objc.io, I wrote an article about it. Since then, I&amp;rsquo;ve given a couple of talks about it. Most of the things you can do are very straightforward once you know them, and people seem to generally like it. However, a couple of months ago, I read a &lt;a href=&#34;http://bendyworks.com/single-responsibility-principle-ios/&#34;&gt;great blogpost&lt;/a&gt; explaining how to take the notion of &amp;lsquo;lighter view controllers&amp;rsquo; up a notch. I tried to take the idea, and apply it to a very simple example app.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/person-app.png&#34; style=&#34;width:217px; float: right; overflow: clear;&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-application&#34;&gt;The Application&lt;/h2&gt;

&lt;p&gt;The app is simple: it&amp;rsquo;s an editor for a &lt;code&gt;Person&lt;/code&gt; object, and currently the only editable field is the person&amp;rsquo;s name. There are two buttons: &lt;em&gt;Reverse&lt;/em&gt; reverses the person&amp;rsquo;s name, and &lt;em&gt;Uppercase&lt;/em&gt; makes it all uppercase. If you edit the person&amp;rsquo;s name, and then press &lt;em&gt;Return&lt;/em&gt;, the keyboard should dismiss.&lt;/p&gt;

&lt;p&gt;&lt;div style=&#34;clear: both;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-regular-implementation-of-the-view-controller&#34;&gt;A regular implementation of the View Controller&lt;/h2&gt;

&lt;p&gt;I created the view controller&amp;rsquo;s view in Interface Builder. The text field is hooked up as an &lt;code&gt;IBOutlet&lt;/code&gt;, and the view controller is also the text field&amp;rsquo;s delegate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface ViewController () &amp;lt;UITextFieldDelegate&amp;gt;
@property (nonatomic) IBOutlet UITextField *textField;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the implementation, we create a person and update the text field&amp;rsquo;s text to reflect the newly created person&amp;rsquo;s name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad
{
    [super viewDidLoad];
    self.person = [Person new];
    self.person.name = @&amp;quot;Chris&amp;quot;;
    [self updateTextField];
}

- (void)updateTextField
{
    self.textField.text = self.person.name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each of the buttons is connected to an &lt;code&gt;IBAction&lt;/code&gt;. For example, the reverse button&amp;rsquo;s action takes the name, reverses it (using the category method &lt;code&gt;reversedString&lt;/code&gt;, and updates the person&amp;rsquo;s name. Then it updates the text field accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)reverse:(id)sender {
    self.person.name = 
       self.textField.text.reversedString;
    [self updateTextField];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uppercase works in exactly the same way. Simple enough:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)uppercase:(id)sender {
    self.person.name = 
      self.textField.text.uppercaseString;
    [self updateTextField];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The text field&amp;rsquo;s delegate is implemented in a simple way: it checks if the replacement string is a newline (i.e. the return key was pressed) and if yes, it resigns first responder, which dismisses the keyboard.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)textField:(UITextField*)textField 
   shouldChangeCharactersInRange:(NSRange)range
               replacementString:(NSString*)string
{
    if ([string isEqualToString:@&amp;quot;\n&amp;quot;]) {
        [textField resignFirstResponder];
        return NO;
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, all of this is very simple. The view controller is just under 50 lines. However, as you add more and more logic, the view controller obviously becomes larger.&lt;/p&gt;

&lt;h2 id=&#34;moving-to-intentions&#34;&gt;Moving to Intentions&lt;/h2&gt;

&lt;p&gt;The idea of the article mentioned in the introduction is to take lighter view controllers to a whole new level. A view controller should only do work in the &lt;code&gt;viewDid*&lt;/code&gt; methods, not implement any extra protocols, and not have any &lt;code&gt;IBActions&lt;/code&gt;. That sounded pretty extreme to me, but I wanted to give it a try and see what it feels like.&lt;/p&gt;

&lt;p&gt;I created a sample project of the things below, and put &lt;a href=&#34;https://github.com/chriseidhof/intentions&#34;&gt;on github&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;dismiss-on-enter&#34;&gt;Dismiss on Enter&lt;/h3&gt;

&lt;p&gt;The first thing we can do is to take out the dismiss on enter logic. To do this, we create a new object, which does only this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation DismissOnEnterIntention

- (BOOL)textField:(UITextField *)textField
    shouldChangeCharactersInRange:(NSRange)range
                replacementString:(NSString *)string
{
    if ([string isEqualToString:@&amp;quot;\n&amp;quot;]) {
        [textField resignFirstResponder];
        return NO;
    }
    return YES;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use this object, we can go to the Object library in Interface Builder, and add a new object to our scene.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/select-object.png&#34; style=&#34;width:237px;&#34;&gt;&lt;/p&gt;

&lt;p&gt;We set it&amp;rsquo;s class to &lt;code&gt;DismissOnEnterIntention&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/dismiss-on-enter.png&#34; style=&#34;width:272px;&#34;&gt;&lt;/p&gt;

&lt;p&gt;Now, we can go to the textfield, and change it&amp;rsquo;s delegate and drag it to our new class (we have to make sure that the class declares that it implements the &lt;code&gt;UITextFieldDelegate&lt;/code&gt; protocol, for example in the class extension).
And that&amp;rsquo;s all there is to it. When the view controller is loaded, the storyboard will create a &lt;code&gt;DismissOnEnterIntention&lt;/code&gt; object and hook it up. Of course, having an extra object just to dismiss on enter seems a bit tedious. But think about it: how often have you implemented this yourself in a view controller? If you put this object in your own standard library, you never have to implement it again, but can instead just reuse it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: &lt;a href=&#34;https://twitter.com/toco91/status/456102320649293824&#34;&gt;Several&lt;/a&gt; &lt;a href=&#34;https://twitter.com/christian_beer/status/456134551941566464&#34;&gt;people&lt;/a&gt; on Twitter point out you can use &lt;code&gt;textFieldShouldReturn:&lt;/code&gt; instead, which is of course a lot better.&lt;/p&gt;

&lt;h3 id=&#34;uppercase-a-name&#34;&gt;Uppercase a Name&lt;/h3&gt;

&lt;p&gt;Uppercasing a name is a bit more difficult. We can start by creating a new object, &lt;code&gt;UppercaseIntention&lt;/code&gt;. It will have an outlet called &lt;code&gt;textField&lt;/code&gt;, and an IBAction, &lt;code&gt;uppercase&lt;/code&gt;, which we just copy over from the view controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)uppercase:(id)sender {
  self.person.name = 
    self.textField.text.uppercaseString;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add a custom object to our view controller scene, hook up the text field and the action, but now we face a problem: how do we connect the &lt;code&gt;person&lt;/code&gt; object? It turns out we can&amp;rsquo;t: we don&amp;rsquo;t know yet which person to edit. Instead, we first have to take a small sidestep and introduce an indirection: we create a container class that contains the person object. At first sight, this might seem to only complicate matters, but bear with me.&lt;/p&gt;

&lt;h4 id=&#34;creating-a-person-container&#34;&gt;Creating a Person Container&lt;/h4&gt;

&lt;p&gt;We create a custom object called &lt;code&gt;PersonContainer&lt;/code&gt;, which doesn&amp;rsquo;t do anything, except for having a &lt;code&gt;Person&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;quot;Person.h&amp;quot;
@interface PersonContainer : NSObject
@property (nonatomic) Person *person;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add a new custom object of this class to our Interface Builder scene, and when the view loads, we can use the view controller and set the container&amp;rsquo;s &lt;code&gt;person&lt;/code&gt; property to the person we are currently editing. Then our &lt;code&gt;UppercaseIntention&lt;/code&gt; can use that person container to access the person. In our view controller, we do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)viewDidLoad
{
    [super viewDidLoad];
    Person *person = [Person new];
    person.name = @&amp;quot;Chris&amp;quot;;
    self.personContainer.person = person;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;UppercaseIntention&lt;/code&gt; class, we can add an outlet for the person container, hook it up, and finally we can write our uppercase action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)uppercase:(id)sender {
  self.personContainer.person.name =
    self.textField.text.uppercaseString;
  self.textField.text = 
    self.personContainer.person.name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the reverse action, it&amp;rsquo;s almost exactly the same code.&lt;/p&gt;

&lt;p&gt;Our view controller is now lighter (it only has the &lt;code&gt;viewDidLoad&lt;/code&gt; method left), but the question is: what have we gained? Is this really simpler to read? At this point, I think we have only complicated matters. There is a more clear separation into classes, but it&amp;rsquo;s now harder to understand, and the new classes that we have made are very specific to our view controller. We can do better, and make our classes more reusable.&lt;/p&gt;

&lt;h3 id=&#34;moving-to-a-generic-text-field-uppercase-intention&#34;&gt;Moving to a Generic Text Field Uppercase Intention&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say we want to reuse our uppercase intention in a different place, where we don&amp;rsquo;t have a &lt;code&gt;Person&lt;/code&gt; as the model, but a different class. First, we can change our &lt;code&gt;PersonContainer&lt;/code&gt; to hold any kind of model, and rename it to &lt;code&gt;ModelContainer&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface ModelContainer : NSObject
@property (nonatomic) id model;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in our uppercase intention, we can change the code like this. It still knows that we&amp;rsquo;re editing a person&amp;rsquo;s &lt;code&gt;name&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (IBAction)capitalize:(id)sender {
    [self.modelContainer.model 
         setValue:self.textField.text.uppercaseString
       forKeyPath:@&amp;quot;name&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, we can use a really cool feature of Interface Builder: User Defined Runtime Attributes. We can take the key path &lt;code&gt;@&amp;quot;name&amp;quot;&lt;/code&gt;, and make it a runtime attribute. First, we create an extra property in our &lt;code&gt;UppercaseIntention&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@property (copy, nonatomic) NSString* modelKeyPath;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we change our code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[self.modelContainer.model 
     setValue:self.textField.text.uppercaseString
   forKeyPath:self.modelKeyPath];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, in Interface Builder, we select the Reverse Intention object, and add a runtime attribute:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/runtime-attribute.png&#34; style=&#34;width:273px;&#34;&gt;&lt;/p&gt;

&lt;p&gt;This is quite cool: now, our uppercase intention doesn&amp;rsquo;t know anything about the &lt;code&gt;Person&lt;/code&gt; anymore. The only thing it does: it takes a model object and a text field, and whenever its action is fired, it updates the model with the uppercased string of the text field.&lt;/p&gt;

&lt;h3 id=&#34;observe-intention&#34;&gt;Observe intention&lt;/h3&gt;

&lt;p&gt;If you paid close attention, you noticed that we removed the following line in our uppercase intention:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  self.textField.text = 
    self.personContainer.person.name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How do we get that behavior back? Instead of updating the text field, let&amp;rsquo;s do it with KVO, and create an observer object. We will make it very generic: it is configured with an object to observe and a key path, and also with a target to update, and a key path. For example, the object to observe might be a &lt;code&gt;Person&lt;/code&gt; and the key path might be &lt;code&gt;name&lt;/code&gt;, and the target object might be a &lt;code&gt;UILabel&lt;/code&gt; and the key path might be &lt;code&gt;text&lt;/code&gt;, which will update the label&amp;rsquo;s text whenever the person&amp;rsquo;s name changes.&lt;/p&gt;

&lt;p&gt;First, we need to create properties for the source, target and the two key paths:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface ObserveIntention ()

@property (strong) IBOutlet id sourceObject;
@property (strong) IBOutlet id target;
@property (copy) IBOutlet NSString *sourceKeyPath;
@property (copy) IBOutlet NSString *targetKeyPath;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to register for KVO notifications. We do this in &lt;code&gt;awakeFromNib&lt;/code&gt;, which is called by the framework after the outlets and the runtime attributes are set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; - (void)awakeFromNib
 {
     [super awakeFromNib];
     [self.sourceObject addObserver:self 
                         forKeyPath:self.sourceKeyPath
                            options:0
                            context:nil];
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To handle the change notifications, we implement the standard KVO method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary *)change
                       context:(void *)context
{
    if ([keyPath isEqualToString:self.sourceKeyPath]) {
        [self updateValue];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;updateValue&lt;/code&gt; method does the real work, and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; - (void)updateValue
 {
     id value = [self.sourceObject 
                  valueForKeyPath:self.sourceKeyPath];
     [self.target setValue:value
                forKeyPath:self.targetKeyPath];
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s all there is to it. We can now create this object in Interface Builder, hook up the source to the model container, the target to the text field, set both key paths using runtime attributes, and the textfield automatically updates whenever the model changes.&lt;/p&gt;

&lt;h4 id=&#34;adding-an-extra-label&#34;&gt;Adding an extra label&lt;/h4&gt;

&lt;p&gt;It might still feel like we have done a lot of work for nothing. But to show how simple some things now get: we can add another label in our view controller&amp;rsquo;s scene, duplicate our observe intention, but change the target to be our label. Now our label also automatically updates its text whenever the Person changes.&lt;/p&gt;

&lt;p&gt;It is interesting to now have a look at our final view controller scene, it&amp;rsquo;s very different from most view controllers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/final-scene.png&#34; style=&#34;width:269px;&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I think this might become a very powerful technique. It comes at a cost: instead of having one complicated view controller, you will have a more complicated storyboard. For me, however, the main attraction is the reusability: I can reuse the observe intention in every project. The same holds for the dismiss on enter intention. I can imagine a whole library of these intentions slowly emerging.&lt;/p&gt;

&lt;p&gt;In my next project, I will probably start using intentions, maybe not for everything, but where I see them fit. Building an example project with them was a lot of fun and really opened my mind.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>We launched Deckset</title>
          <link>http://chris.eidhof.nl/post/we-launched-deckset/</link>
          <pubDate>Tue, 08 Apr 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/we-launched-deckset/</guid>
          <description>&lt;p&gt;I couldn&amp;rsquo;t be more proud to share with you that we launched Deckset yesterday. There are a lot of nice stories to tell about how we worked as a team, why it took us 5 times longer than expected to build this, and how we finally shipped. There are so many interesting technical details to share. However, today I won&amp;rsquo;t talk about the process, but why I am so proud of the result. Of course, this is very biased, so here are &lt;a href=&#34;http://www.macstories.net/reviews/deckset-empowers-you-to-create-great-presentations-from-your-text-editor-of-choice/&#34;&gt;some&lt;/a&gt;. &lt;a href=&#34;http://brettterpstra.com/2014/04/07/deckset-1-dot-0-released/&#34;&gt;things&lt;/a&gt;. &lt;a href=&#34;http://brooksreview.net/2014/04/deckset/&#34;&gt;others&lt;/a&gt;. &lt;a href=&#34;https://twitter.com/chockenberry/status/453246589172060160&#34;&gt;are&lt;/a&gt;. &lt;a href=&#34;http://www.heise.de/mac-and-i/meldung/Deckset-Von-Markdown-zur-Praesentation-2165030.html&#34;&gt;thinking&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/deckset-screenshot.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When I draft a talk, I always start with the outline and think about the story that I want to share. These outlines I write in Markdown using my favorite text editor (vim). Generally, I first collect all of the ideas, and then rewrite my outline over and over again until it&amp;rsquo;s perfect.&lt;/p&gt;

&lt;p&gt;Then, at some point, once the outline starts getting very detailed, I start creating slides. Before Deckset existed, I used to have my first big hurdle: I try to make every aspect of my presentation really good, and I also want the slides to reflect that. One of the aspects is having a beautiful theme. When creating a presentation using regular software (such as Keynote or Powerpoint), you have to choose this theme before you do anything else, because it&amp;rsquo;s really hard to change this after you made a few slides. In Deckset, I have the flexibility to change this at almost any time, and hardly have to worry about this upfront.&lt;/p&gt;

&lt;p&gt;Whenever I make slides, I want them to be beautiful and consistent. In Deckset, this is done by default. Because our input is Markdown, which is only structure, I can&amp;rsquo;t spend my time changing fonts, adjusting colors and moving images around. Each theme is very carefully designed, and we iterated many times to make sure they are all great for giving a presentation.&lt;/p&gt;

&lt;p&gt;I love also the speed of creating a presentation with Deckset. I am a fast typist, and once I know what I want to say, I just type it out and my slides are done. For example, I had to create a slide deck for the UIKonf Sponsors, with background info, sponsor offers, and quotes and pictures from last year&amp;rsquo;s edition. In 15 minutes, I had a really impressive looking deck with all the information. The sponsors loved this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://chris.eidhof.nl/static/images/deckset-screenshot2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The last year, in my own public speaking, I&amp;rsquo;ve given similar talks on the same topic at multiple places. Having my presentation in Markdown means that I can very quickly copy and paste specific slides, or code examples, whenever I create a new presentation. Because I only copy Markdown, I don&amp;rsquo;t have to worry about the design.&lt;/p&gt;

&lt;p&gt;Finally, making changes to a Deckset presentation is much easier than in Keynote. For example, we have an option to make the headings &lt;em&gt;fit&lt;/em&gt;: the font size is automatically adjusted so that the text fits perfectly on the slide. We do automatic syntax highlighting. Making these kinds of last-minute changes in a Keynote presentation takes a lot more effort: not only do you change the text, but you also have to re-layout your slides.&lt;/p&gt;

&lt;p&gt;There are so many more things to talk about. But today, we&amp;rsquo;ll celebrate our launch, and hope to ship many more versions. We have a lot of ideas of where we can take Deckset. It&amp;rsquo;s very opinionated software, and not for everybody. But if you love Markdown, check out our &lt;a href=&#34;http://www.decksetapp.com&#34;&gt;website&lt;/a&gt; or head over to the &lt;a href=&#34;http://bit.ly/getdeckset&#34;&gt;Mac App Store&lt;/a&gt; and buy it directly.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Fast Running</title>
          <link>http://chris.eidhof.nl/post/fast-running/</link>
          <pubDate>Wed, 12 Mar 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/fast-running/</guid>
          <description>&lt;p&gt;When I&amp;rsquo;m not working, a lot of my time and energy is spent running. Last year, in preparation for the Berlin Marathon, I was running 4-5 times a week, and also doing strength training 1-2 times a week. Last year, in April, I also ran a PB on the 10K: 37:03. Compared to average runners, this is quite fast (however, in almost every race there are people who are a lot faster).&lt;/p&gt;

&lt;p&gt;Sometimes when I tell people I run a lot, they ask me: how fast are you? And some of the beginning runners are amazed when I tell my numbers. A lot of people have a hard time running under 50 minutes, even when training twice a week.&lt;/p&gt;

&lt;p&gt;The way I did it is very simple, but not easy: I trained diligently for 3 or 4 years. There have been phases where I was injured, and I couldn&amp;rsquo;t train, but during any other time, I trained at least 3 times a week. Working towards my 10K PB, I almost never missed a training, unless I had a really good excuse. It&amp;rsquo;s as simple as that.&lt;/p&gt;

&lt;p&gt;There are a lot of good excuses not to run. However, for me, once I find a good excuse to skip one training, it&amp;rsquo;s going to be even easier to skip the next one. So I made a point of not skipping trainings in preparation for my 10K race. This really helped me. It&amp;rsquo;s not easy: sometimes, you&amp;rsquo;re tired, or you just don&amp;rsquo;t feel like running. You&amp;rsquo;ll have to toughen up and still do it. You&amp;rsquo;ll have to sometimes skip social stuff and go to bed at 10pm, instead of drinking beer until 1am.&lt;/p&gt;

&lt;p&gt;Of course, unless you&amp;rsquo;re a professional athlete, you can&amp;rsquo;t keep a regime like that all through the year. I decide on key races, and be very strict about trainings in the months leading up to it, and loosen up afterwards. And during those months, training is my main priority. Of course I will work and socialize during those months, but I try to organize everything around training. Currently, my focus is on work, and hence I take my training a lot more easy.&lt;/p&gt;

&lt;p&gt;So this is my secret: just put in the effort. If you want to become a fast runner, run a lot. If you want to become a great programmer, program a lot. Most of your motivation should come intrinsically, for the rest you need to set a schedule and stick to it.&lt;/p&gt;

&lt;p&gt;To finish the article, here&amp;rsquo;s a nice quote by Pirsig, which applies to running fast as well:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You’ve got to live right, too. It’s the way you live that predisposes you to avoid the traps and see the right facts. You want to know how to paint a perfect painting? It’s easy. Make yourself perfect and then just paint naturally.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Robert M. Pirsig&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Working for the man</title>
          <link>http://chris.eidhof.nl/post/working-for-the-man/</link>
          <pubDate>Wed, 05 Mar 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/working-for-the-man/</guid>
          <description>&lt;p&gt;I got my first programming job when I was 16. I had made a website for the local library, and one of the two computer companies in the village had gotten my contact details. I went there, and started building a CMS in PHP for him. I was 15 or 16 years old, and loved it. I built and designed a lot of websites for all the local companies (the plumber, the party-rental-service, the truck company, etc.).&lt;/p&gt;

&lt;p&gt;I then had a couple of jobs, always a little bit more serious, until I was 19, and they let me work at a really cool agency. After a while, we started working on a big project for a big client, and I knew my boss charged €175 an hour. I got paid €17. Even after deducting costs, he still made a really nice markup. So after some discussion, I got a project-based raise of €10.&lt;/p&gt;

&lt;p&gt;I was doing a good job (the client we worked for, still asks me every once in a while if I would want to work for them). I also brought on multiple of my friends, some of which are still working at the company. My boss was quite happy. However, during a dinner, I told him that one day, after my studies, I wanted to start a company of my own. That changed things.&lt;/p&gt;

&lt;p&gt;When the project for the client ended, I had to go back to my old wage of €17 an hour, without the bonus. For me, this meant a pay cut of 40%. Naturally, after having made my boss a lot of money, the client happy and bringing on a lot of friends, I thought I deserved a raise. First, it was hard to schedule a meeting, but after a while, we did talk about it, and my boss offered me a raise: I was going to make €17.50 an hour. I was &lt;em&gt;so&lt;/em&gt; offended.&lt;/p&gt;

&lt;p&gt;As happened multiple times over the last 10 years, I managed to turn my frustration into something productive. I knew that time had come to start my own company. I was planning to do it a few years later, but I realized that I didn&amp;rsquo;t want to work for a boss anymore. So I called up my friend Eelco, who I&amp;rsquo;d been talking with about starting a company, and a few months later we were in business.&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t been an employee since, and can&amp;rsquo;t imagine being one. I expect that at some point during my career, I will work for a boss again, and have a “regular” job. However, I&amp;rsquo;m quite afraid of giving up all this freedom: I now decide what to work on, who to work with, how much risk to take, when I want to work, and what I&amp;rsquo;ll be doing next. It&amp;rsquo;s going to be hard to have someone else decide all these things.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Finding designers</title>
          <link>http://chris.eidhof.nl/post/finding-designers/</link>
          <pubDate>Mon, 24 Feb 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/finding-designers/</guid>
          <description>&lt;p&gt;When Florian and me started working on Deckset, we realized we needed the best possible design. In every app, great design is important, but here, it&amp;rsquo;s even more important: we will provide users with themes that have to look really great by default.&lt;/p&gt;

&lt;p&gt;When we started looking for designers, there were a couple of people that came to mind, because we&amp;rsquo;ve worked with them before. However, with the two most serious candidates, we&amp;rsquo;ve had a couple of issues: even though we love what they made, the process of working with them before was not too nice. They kept on missing deadlines and not communicating that. Speaking from a client perspective, it&amp;rsquo;s almost never a problem if a deadline is missed. But not getting a heads up on that is a problem.&lt;/p&gt;

&lt;p&gt;We decided to not work with the people we knew, because we anticipated the same problems. Instead, we started browsing Dribbble, and found somebody who made some really beautiful mockups for Mac apps. We started talking with him, and asked him to make a plan.
The plan was: he had to spend a day or two making wireframes, and then he could make a better plan for the rest. Even though our phone call had been really nice, and we believed he could do it, something just didn&amp;rsquo;t feel right. We couldn&amp;rsquo;t really poinpoint it, but we decided not to work with him.&lt;/p&gt;

&lt;p&gt;We then realized: we wanted to work with the best designers possible. The guy we&amp;rsquo;ve been talking too was already expensive, but the outcome of hiring him felt very uncertain. We knew we had to find the very best that we can afford. We decided that, worst case, one of us would go freelancing to make as much money as possible, so we could afford the very best.&lt;/p&gt;

&lt;p&gt;We then had a talk with Sven from A Color Bright. He got very excited about the project, and offered to help us in many possible ways (not just with the visuals, but with everything involving design: the user experience, the website, the marketing, and so on). We could tell that they had a lot of experience in working with clients. It just felt good.&lt;/p&gt;

&lt;p&gt;A while back, I struggled to explain why it didn&amp;rsquo;t feel good with the first designer. Only later, I realized that the most important thing we were looking for, is not just great design. It&amp;rsquo;s also great communication. Communication is essential during a software project, especially when you don&amp;rsquo;t exactly know what you&amp;rsquo;re building (which, in my experience, is &lt;em&gt;always&lt;/em&gt; the case when building software). I&amp;rsquo;m sometimes freelancing myself, and will need to get better at it too. From now on, I&amp;rsquo;ll try to judge anybody I&amp;rsquo;ll hire on a project-basis on their communication skills.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Aside&lt;/em&gt;:
I noticed that in all projects I&amp;rsquo;ve done over the last years, I preferred to sit on-site with my client. This is probably because I then hardly need to put effort into communication: when somebody has a question, it&amp;rsquo;s as easy as walking over.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Behind the scenes</title>
          <link>http://chris.eidhof.nl/post/how-i-write-for-objcio/</link>
          <pubDate>Mon, 17 Feb 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/how-i-write-for-objcio/</guid>
          <description>&lt;p&gt;headline: How I write my articles for objc.io&lt;/p&gt;

&lt;p&gt;My workflow for writing an &lt;a href=&#34;http://www.objc.io&#34;&gt;objc.io&lt;/a&gt; article is like this:&lt;/p&gt;

&lt;p&gt;Once we release an issue, we often have the topic for the next issue ready. Florian, Daniel and me get together and we discuss and try to distribute the relevant topics among the three of us (in addition to the guest articles that are already planned). For example, for the &lt;a href=&#34;http://www.objc.io/issue-9/&#34;&gt;strings issue&lt;/a&gt;, I knew my topic would be &lt;a href=&#34;http://www.objc.io/issue-9/string-parsing.html&#34;&gt;string parsing&lt;/a&gt;, and that I would talk about scanners, regular expressions and parsers.&lt;/p&gt;

&lt;p&gt;Then there are two possibilities: I know directly what I want to write, or I have no idea yet.&lt;/p&gt;

&lt;p&gt;When I know what to write, I immediately start thinking about an outline. This takes a few weeks, and I think on the train, bike and discuss bits and pieces with Daniel and Florian whenever the topic comes up. I collect notes and ideas in a file or in Evernote. If I decide that I want a sample project (which I really like having most of the time) then I will start with building that and finishing it. This usually takes a day or two.
Mostly, there is no writing during the building of the project (only note-taking).&lt;/p&gt;

&lt;p&gt;However, I do prepare an outline. We share the outlines with each other, also to distribute all the topics and decide who writes about what. And we add things to each other&amp;rsquo;s articles, to make sure we cover everything. Sometimes, we even write parts of each other&amp;rsquo;s article.  After this process, I&amp;rsquo;ll have a sample project and an outline. Once I&amp;rsquo;m happy with the sample project and the outline, I start writing. This also takes a day or two.&lt;/p&gt;

&lt;p&gt;When I don&amp;rsquo;t know what to write, I start with doing a lot of research. I read blogs, try to find the WWDC videos, read the programming guides and other documentation, and see what kinds of problems people have. I ask myself questions and try to answer them. Then I follow the process above.&lt;/p&gt;

&lt;p&gt;Finally, after the project and article are ready, the three of us read each other&amp;rsquo;s articles and try to improve it. We also do this with the guest posts. And once we&amp;rsquo;re all happy (or ran out of time) we send everything to Natalye, our copy-editor, who makes sure things are phrased clearly, that there are no language mistakes and that there&amp;rsquo;s a consistent style.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s amazing how much effort goes into this: at least a few days per article. However, even if nobody reads your article, it&amp;rsquo;s still worth the effort: doing the background research, getting your facts right and trying to put all this stuff into words really teaches me a lot. And the effort becomes even more worthwile when you see that your article is read by tens of thousands of people.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Deckset</title>
          <link>http://chris.eidhof.nl/post/deckset/</link>
          <pubDate>Fri, 27 Dec 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/deckset/</guid>
          <description>&lt;p&gt;One of the things I love is Markdown. Recently, I&amp;#8217;ve also been giving a lot more presentations. Working in Keynote can be really nice, and is very powerful. But most of the time, I don&amp;#8217;t need that power.&lt;/p&gt;

&lt;p&gt;Therefore, &lt;a href=&#34;http://floriankugler.com&#34;&gt;Florian&lt;/a&gt;, me and our awesome friends at &lt;a href=&#34;http://www.acolorbright.com&#34;&gt;A Color Bright&lt;/a&gt; have spent the last months building an app that changes the way you write your presentations. You write a markdown file, separate your slides with dashes, and you get a beautiful presentation out of it. Update your markdown file, and your presentation updates automatically.&lt;/p&gt;

&lt;p&gt;Over the last weeks, we&amp;#8217;ve given multiple presentations with the app, and it&amp;#8217;s awesome. For me, it&amp;#8217;s great that I can just write. Rearranging text is so much easier than rearranging slides. The default themes we have are beautiful by default, and it&amp;#8217;s really hard to mess it up. Changing to a different theme is immediate: you can do this minutes before the presentation, if you feel like it.&lt;/p&gt;

&lt;p&gt;We are not building a replacement for Keynote or Powerpoint, but a different way of creating presentations. In some use cases, traditional tools are the way to go. But for many of the presentations, we think Deckset is much easier.&lt;/p&gt;

&lt;p&gt;Currently, we&amp;#8217;re putting the finishing touches on our app, and are getting it ready for private beta. We are planning to launch early 2014. If this sounds interesting to you, go ahead and sign up for the mailing list at &lt;a href=&#34;http://www.decksetapp.com&#34;&gt;decksetapp.com&lt;/a&gt;, and we&amp;#8217;ll keep you posted.&lt;/p&gt;

&lt;p&gt;Have a great start of the year!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>2013</title>
          <link>http://chris.eidhof.nl/post/2013/</link>
          <pubDate>Sat, 07 Dec 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/2013/</guid>
          <description>&lt;p&gt;It&amp;#8217;s the time of the year to write a recap about the things I&amp;#8217;ve done this year. 2013 has been a really awesome year, maybe my best year so far. I learned tons, worked with really awesome people, made many new friends and travelled a lot.&lt;/p&gt;

&lt;h2&gt;Client work&lt;/h2&gt;

&lt;p&gt;This year, I worked for three big clients (and some smaller ones). The smallest of three was an old employer who wanted a prototype of a new idea (in Ruby on Rails). This prototype evolved into a bigger website, and things got a bit more serious. Because I am not a real Rails developer, and because there was a base level of trust missing, I decided to not continue working on this project. I had written behavior tests using &lt;a href=&#34;http://cukes.info&#34;&gt;Cucumber&lt;/a&gt; for the entire project: this was awesome once I decided to transfer it, because the other developer was able to quickly take it over.&lt;/p&gt;

&lt;p&gt;My other two big clients were &lt;a href=&#34;http://www.aprendo.nl&#34;&gt;Aprendo&lt;/a&gt; and &lt;a href=&#34;http://wearezeta.com&#34;&gt;Zeta&lt;/a&gt;. For Aprendo, we built an in-house app for development of elite athletes. I worked together with &lt;a href=&#34;http://floriankugler.com&#34;&gt;Florian&lt;/a&gt; on this, and our collaboration was so nice we decided to make more things together (more on that later). For Zeta, I can&amp;#8217;t yet tell what I built, but keep an eye on them. It&amp;#8217;ll be awesome.&lt;/p&gt;

&lt;p&gt;I really liked having few bigger clients (rather than a more smaller clients). I&amp;#8217;m currently still wide open in 2014 for client projects, if you have a bigger project that needs a serious developer (or a team): get in touch.&lt;/p&gt;

&lt;h2&gt;Conferences and Events&lt;/h2&gt;

&lt;p&gt;This year was the year of the conferences for me. Almost exactly one year ago, I realized that there&amp;#8217;s no English iOS conference in Berlin, and with all the awesome talent in the city we definitely needed one. So I teamed up with &lt;a href=&#34;http://www.thewavingcat.com&#34;&gt;Peter&lt;/a&gt;, &lt;a href=&#34;http://werkstatt.io&#34;&gt;Matt&lt;/a&gt; and &lt;a href=&#34;http://about.me/max.krueger&#34;&gt;Max&lt;/a&gt;, and we decided to organize &lt;a href=&#34;http://www.uikonf.com&#34;&gt;UIKonf&lt;/a&gt;. This was a lot of hard work, a lot of things learned, and went way better than expected. One of my first lessons in how working in a team can make you achieve that much more. In fact, it was so awesome we decided to do it again, tickets for 2014 are now &lt;a href=&#34;http://www.uikonf.com&#34;&gt;on sale&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because the awesome &lt;a href=&#34;http://nshipster.com&#34;&gt;NSHipster&lt;/a&gt; was in town, we decided to put on an event together with Mattt, and put on an &lt;a href=&#34;http://2013.uikonf.com/2013/03/25/nshipster-quiz-night.html&#34;&gt;NSHipster night&lt;/a&gt;, which turned out to be a great succes.&lt;/p&gt;

&lt;p&gt;Also, after UIKonf, &lt;a href=&#34;http://www.solid-perspective-vision.com&#34;&gt;Stijn Oomes&lt;/a&gt; approached me with the idea of doing a &lt;a href=&#34;http://2013.uikonf.com/2013/06/11/uikonf-training.html&#34;&gt;3D programming workshop&lt;/a&gt;. This went well, we even had two days of workshops. We went over the basics of 3D programming, and took different approaches in getting 3D scenes on the screen, from high-level with SceneKit to low-level-everything-in-OpenGL.&lt;/p&gt;

&lt;p&gt;Finally, a while ago Apple announced &lt;a href=&#34;https://developer.apple.com/tech-talks/&#34;&gt;Tech Talks&lt;/a&gt; in Berlin. After learning that I didn&amp;#8217;t get a ticket, I decided to put my frustration to good use and started organizing &lt;a href=&#34;http://www.alt-tech-talks.com&#34;&gt;Alt Tech Talks&lt;/a&gt;, a free event for everyone who did or did not get a ticket. On Wednesday night I asked on Twitter, on Thursday I had the first 4 speakers confirmed and on Friday I rented a movie theater. The rest isn&amp;#8217;t history yet, because they&amp;#8217;ll happen in a few days from now.&lt;/p&gt;

&lt;h3&gt;Talks&lt;/h3&gt;

&lt;p&gt;Because of starting &lt;a href=&#34;http://www.objc.io&#34;&gt;objc.io&lt;/a&gt; (more about this later), Florian, &lt;a href=&#34;https://twitter.com/danielboedewadt&#34;&gt;Daniel&lt;/a&gt; and me gained a bit of visibility in the iOS and Mac community. And that lead to conferences asking us if we&amp;#8217;d be interested in speaking. I like speaking, so off we went.&lt;/p&gt;

&lt;p&gt;First, there was &lt;a href=&#34;http://nsspain.com/2013&#34;&gt;NSSpain&lt;/a&gt;, which was an English-speaking conference in Logroño. We were quite impressed: it was well organized, great weather, and lots of nice food and wine. I spoke about &lt;a href=&#34;https://speakerdeck.com/chriseidhof/lighter-view-controllers&#34;&gt;Lighter View Controllers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Then, the talk I was most afraid of this year: an hour-long presentation in German (!) at &lt;a href=&#34;http://www.macoun.de&#34;&gt;Macoun&lt;/a&gt;. Fortunately, my German is finally at a level where people don&amp;#8217;t have problems understanding me, and with enough preparation, I think my talk came across well. The subject (&lt;a href=&#34;https://speakerdeck.com/chriseidhof/schlanke-view-controller&#34;&gt;Schlanke View Controller&lt;/a&gt;) was the the same as in Spain, and it seems to be very relevant for all iOS developers.&lt;/p&gt;

&lt;p&gt;About a month later, I spoke at &lt;a href=&#34;http://pragmamark.org&#34;&gt;pragma mark&lt;/a&gt;, an iOS/OS X conference in Milan, Italy. Here, I spoke about &lt;a href=&#34;https://speakerdeck.com/chriseidhof/pragma-mark-simple-concurrent-programming&#34;&gt;async programming&lt;/a&gt;, which went okay. It is quite a hard topic to talk about, but luckily, writing &lt;a href=&#34;http://www.objc.io/issue-2/common-background-practices.html&#34;&gt;the article for objc.io&lt;/a&gt; forced me to dive deep into the topic, and giving me plenty of raw material for the talk.&lt;/p&gt;

&lt;p&gt;The hardest talk format this year was at &lt;a href=&#34;http://igniteberlin.com/category/ignite04/&#34;&gt;Ignite Berlin&lt;/a&gt;; every presentation is 20 slides, and every slide auto-advances every 15 seconds. I prepared this the other way around: normally, I write an outline for a talk, expand that a couple of times and finally make slides. This time, however, I recorded myself telling the story I wanted to tell, and made some slides that loosely reinforced what I wanted to tell.&lt;/p&gt;

&lt;p&gt;I also talked at &lt;a href=&#34;https://speakerdeck.com/chriseidhof/parallele-programmierung-de&#34;&gt;CocoaHeads Dresden&lt;/a&gt; and twice at the &lt;a href=&#34;http://berlin.compilermeet.org&#34;&gt;Berlin Compiler Meetup&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Other&lt;/h2&gt;

&lt;p&gt;In the beginning of the year, I joined &lt;a href=&#34;http://kantberlin.com&#34;&gt;KANT&lt;/a&gt;, a studio full of great people. I spent a couple of months working there, but after being on-site with my client a lot, and having other commitments that didn&amp;#8217;t allow me to be there a lot, I decided to cancel my desk there. Being among them, I learned to appreciate coffee even more.&lt;/p&gt;

&lt;p&gt;I started lots of small new projects, some succesful, most failed. I often spend a day or two building something (sometimes more). It&amp;#8217;s a lot of fun, and in doing so I learned a lot. I hope that I can use some of those ideas in future projects.&lt;/p&gt;

&lt;p&gt;Continuing from last year, we try to meet regularly for our German course. With my fellow Dutchies &lt;a href=&#34;http://alper.nl/dingen/&#34;&gt;Alper&lt;/a&gt; and &lt;a href=&#34;http://iksi.cc&#34;&gt;IKSI&lt;/a&gt; we take lessons from &lt;a href=&#34;https://twitter.com/fraulea&#34;&gt;@fraulea&lt;/a&gt;. I will probably spend the next 10 years improving my German while never getting close to being near-native. But that&amp;#8217;s okay, it&amp;#8217;s a lot of fun and a beautiful language to discover. For the German speakers that read this: if you ever hear me make mistakes, please correct me.&lt;/p&gt;

&lt;p&gt;After having spent most of the year freelancing, I&amp;#8217;ve been working on a product together with Florian and &lt;a href=&#34;http://www.acolorbright.com&#34;&gt;A Color Bright&lt;/a&gt;. We&amp;#8217;re not quite ready to tell you what it is, but are getting close to release a private beta towards the end of this year. And hopefully can submit to the store early January. It&amp;#8217;s going to be a native Mac app (our first) and it&amp;#8217;s going to be very beautiful. Building your own products is lots of fun, I hope to do a lot more of that in 2014.&lt;/p&gt;

&lt;h2&gt;objc.io&lt;/h2&gt;

&lt;p&gt;The last work-related topic: &lt;a href=&#34;http://www.objc.io&#34;&gt;objc.io&lt;/a&gt;. On the morning after UIKonf, on the hackday, I sat outside in the sun, together with Florian, Daniel and &lt;a href=&#34;http://petersteinberger.com&#34;&gt;Peter&lt;/a&gt;. Instead of hacking, we were talking and drinking coffee, and I felt a bit guilty about that. Florian, Daniel and me decided that we should write a blog with the three of us. A few days later, I tried to convince them that we should instead make a magazine: one topic each month, and in-depth articles. We asked &lt;a href=&#34;http://iksi.cc&#34;&gt;IKSI&lt;/a&gt; to make a beautiful design, and asked &lt;a href=&#34;http://deutsch-bitte.net&#34;&gt;Natalye&lt;/a&gt; to do the copy-editing. We started writing and tried to put a lot of effort into the first issue. &lt;a href=&#34;http://www.rickigregersen.com&#34;&gt;Ricki&lt;/a&gt; wrote an article too, as our first guest-writer. After a few weeks, Florian and me sat outside on my balcony, and pressed publish. We posted the link on Twitter, waited a bit, and saw a huge stream of compliments coming in.&lt;/p&gt;

&lt;p&gt;Each month, each of us spends a few days researching and writing my article, as well as coordinating the other things. It&amp;#8217;s a lot of work, especially because we really have to investigate each topic very deeply, as we don&amp;#8217;t want to spread the wrong ideas. But it&amp;#8217;s oh so rewarding. The writing and researching in itself make me a lot more knowledgeable. Before writing, I sometimes don&amp;#8217;t know too much about a topic, and having the article and its deadline force me to learn. It&amp;#8217;s just great. And of course, getting all the positive reactions from our readers is very flattering.&lt;/p&gt;

&lt;h2&gt;Leisure&lt;/h2&gt;

&lt;p&gt;This year, I visited Spain three times: once for running, once for a conference and the third time to spend some time by myself (I&amp;#8217;m writing this article from Seville). I learned how to do exercises at the gym, which was so much fun: I never expected that lifting heavy stuff could be fun, but it&amp;#8217;s great. I ran a new PB on the 10K: 37:03. I ran my first marathon: the &lt;a href=&#34;http://www.skogsmaraton.no&#34;&gt;Oslo Forest Marathon&lt;/a&gt;. It was way too hilly for me to run fast, and while the first 27K went great, the last 15 were very hard. I visited friends and family in The Netherlands, but not as much as I wanted. I ran up the &lt;a href=&#34;http://en.wikipedia.org/wiki/Brocken&#34;&gt;Brocken&lt;/a&gt; a couple of times. Together with Frank, I walked &lt;a href=&#34;http://en.wikipedia.org/wiki/Hadrian&#39;s_Wall&#34;&gt;Hadrian&amp;#8217;s wall&lt;/a&gt;, and spend the week after that running up mountains in the Lake District. I went sailing and camping in Sweden.&lt;/p&gt;

&lt;p&gt;One of my disappointments was not being able to run the Berlin Marathon. I trained for months, aiming to run a fast first road-marathon. However, during the last week of tapering, I got quite sick, and had to stay in bed for a few days. I might have caught a bug, or maybe I trained too hard. It took me a while to recover, and I still haven&amp;#8217;t gotten back to running 5 times a week.&lt;/p&gt;

&lt;h2&gt;Recap&lt;/h2&gt;

&lt;p&gt;It was awesome. I had a blast. I did work too much, and want to change that next year.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Lightweight Key-Value Observing</title>
          <link>http://chris.eidhof.nl/post/lightweight-key-value-observing/</link>
          <pubDate>Wed, 09 Oct 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/lightweight-key-value-observing/</guid>
          <description>&lt;p&gt;In this article, I&amp;#8217;d like to implement a simple class I use for
key-value observing. I think KVO is great, however, for most of what I
do, there are two problems:&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;I don&amp;#8217;t like the dispatching in &lt;code&gt;observeValueForKeyPath:ofObject:change:context:&lt;/code&gt;. I think it gets messy and confusing if you observe more than one object.&lt;/li&gt;
&lt;li&gt;You have to balance each &lt;em&gt;add observer&lt;/em&gt; with a &lt;em&gt;remove observer&lt;/em&gt;,
it would be nice if this can be done automatically.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;So, off we go. The trick we will use is one I first saw in
&lt;a href=&#34;https://github.com/th-in-gs/THObserversAndBinders&#34;&gt;THObserversAndBinders&lt;/a&gt;,
and this post is basically a description of what they did, but in the
most minimalistic way.&lt;/p&gt;

&lt;p&gt;First, we&amp;#8217;ll define the interface for our object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Observer : NSObject
+ (instancetype)observerWithObject:(id)object
                           keyPath:(NSString*)keyPath
                            target:(id)target
                          selector:(SEL)selector;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The observer takes four parameters, which are hopefully self-explanatory. I chose
to use the target/action pattern: an alternative would have been blocks,
but then you would have to do the weakSelf/strongSelf dance, and it&amp;#8217;s
often nice to have a separate method anyway.&lt;/p&gt;

&lt;p&gt;What we will do is set up the KVO inside the initializer, and remove it
in the &lt;code&gt;dealloc&lt;/code&gt; method. What this means is that as long as the
&lt;code&gt;Observer&lt;/code&gt; object is retained, we will have an observer. The way I
typically use this, for example, in a view controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.usernameObserver = [Observer observerWithObject:self.user
                                             keyPath:@&#34;name&#34;
                                              target:self
                                            selector:@selector(usernameChanged)];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By putting it in a property, we are making sure it gets retained. As
soon as our view controller deallocates, it&amp;#8217;ll set the property to nil
and the observer will stop observing.&lt;/p&gt;

&lt;p&gt;In the implementation, it&amp;#8217;s important that we keep a weak reference to
both the observed object and the target. If one of the two gets nil, we
want to stop sending messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Observer ()
@property (nonatomic, weak) id target;
@property (nonatomic) SEL selector;
@property (nonatomic, weak) id observedObject;
@property (nonatomic, copy) NSString* keyPath;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The initializer sets up the KVO notifications. It uses &lt;code&gt;self&lt;/code&gt; as the
context. This is necessary if we would ever have a subclass that adds a
similar observer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)initWithObject:(id)object keyPath:(NSString*)keyPath target:(id)target selector:(SEL)selector
{
  if (self) {
    self.target = target;
    self.selector = selector;
    self.observedObject = object;
    self.keyPath = keyPath;
    [object addObserver:self forKeyPath:keyPath options:0 context:self];
  }
  return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a change happens, we just notify our target, if it still exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)observeValueForKeyPath:(NSString*)keyPath ofObject:(id)object change:(NSDictionary*)change context:(void*)context
{
  if (context == self) {
    id strongTarget = self.target;
    if ([strongTarget respondsToSelector:self.selector]) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &#34;-Warc-performSelector-leaks&#34;
      [strongTarget performSelector:self.selector];
#pragma clang diagnostic pop
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, in the &lt;code&gt;dealloc&lt;/code&gt; we remove the observer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)dealloc
{
    id strongObservedObject = self.observedObject;
    if (strongObservedObject) {
        [strongObservedObject removeObserver:self forKeyPath:self.keyPath];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s all there is to it. There are a lot of ways this could be
extended: add blocks support, or my favorite trick: another convenience
constructor that call the action directly the first time. However, I
wanted to show the core of the technique, adjust it to your needs.&lt;/p&gt;

&lt;p&gt;By using this technique you don&amp;#8217;t have to remember too much when doing KVO.
Just retain the observers, and set them to nil when you&amp;#8217;re done. The
rest will happen automatically.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Status Update</title>
          <link>http://chris.eidhof.nl/post/status-update/</link>
          <pubDate>Mon, 10 Jun 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/status-update/</guid>
          <description>&lt;p&gt;Lots of stuff happened over the last months, so here&amp;#8217;s a partial list:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;I finished my project with &lt;a href=&#34;http://www.aprendo.nl&#34;&gt;Aprendo&lt;/a&gt;. We&amp;#8217;ve
been working on an in-house iPad app for almost a year. At this point,
I can&amp;#8217;t demo anything publicly, but I&amp;#8217;d be happy to talk about it in
private.&lt;/li&gt;
&lt;li&gt;I organized &lt;a href=&#34;http://www.uikonf.com&#34;&gt;UIKonf&lt;/a&gt; together with
&lt;a href=&#34;http://twitter.com/peterbihr&#34;&gt;Peter&lt;/a&gt; and
&lt;a href=&#34;http://twitter.com/fidothe&#34;&gt;Matt&lt;/a&gt;. I think it&amp;#8217;s safe to say that
the conference was a resounding success. We learned a lot of things
that we can do better next year, but all in all, we&amp;#8217;re very happy.&lt;/li&gt;
&lt;li&gt;I started &lt;a href=&#34;http://objc.io&#34;&gt;objc.io&lt;/a&gt;, a new online periodical about
best practices and techniques in Objective-C. The response so far
has been very good, and matches the amount of work we&amp;#8217;ve put in.&lt;/li&gt;
&lt;li&gt;I started work on a small app to track your food intake, based on the
Diet Quality Score system.&lt;/li&gt;
&lt;li&gt;I started planning to build independent apps together with
&lt;a href=&#34;http://floriankugler.com&#34;&gt;Florian&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The running is going well, too, I improved my PB on the 10K in bad
circumstances to 37:03, and will run my &lt;a href=&#34;http://www.skogsmaraton.no&#34;&gt;first
marathon&lt;/a&gt; this weekend (although I have a
slight injury, so depending on how that feels I might pull out at the
last minute).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Depending on the contracting work I might have more time to blog. I have
a lot of topics in my head, some might appear here and some on
&lt;a href=&#34;http://objc.io&#34;&gt;objc.io&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>DONE</title>
          <link>http://chris.eidhof.nl/post/done/</link>
          <pubDate>Mon, 25 Feb 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/done/</guid>
          <description>&lt;p&gt;In case you haven&amp;#8217;t noticed yet, I&amp;#8217;m organizing an English-speaking iOS
Conference in Berlin called &lt;a href=&#34;http://www.uikonf.com&#34;&gt;UIKonf&lt;/a&gt;, together with my
fellow organizers &lt;a href=&#34;http://twitter.com/fidothe&#34;&gt;Matt&lt;/a&gt; and
&lt;a href=&#34;http://twitter.com/peterbihr&#34;&gt;Peter&lt;/a&gt;. If you are in or around Berlin on May 2nd,
get on the &lt;a href=&#34;http://iosinberlin.launchrock.com&#34;&gt;mailing list&lt;/a&gt; and come join us!&lt;/p&gt;

&lt;p&gt;Organizing this conference is really awesome. It started with a question: why doesn&amp;#8217;t this
conference exist? Then I realized that the only way to make it happen is do it yourself.
Starting something like this feels really empowering: we can definitely have an impact
on our direct environment by just doing stuff. I asked some people that are
more awesome and experienced than myself, then we executed.&lt;/p&gt;

&lt;p&gt;While UIKonf is still a few months away, I am getting better at shipping, and I can
recommend you to do the same. Instead of reading this, write an article. Package
up some software or libraries you have lying around. Organize a meetup.
You&amp;#8217;ll see that it&amp;#8217;ll make you happy!&lt;/p&gt;

&lt;p&gt;A good recommendation from my friend &lt;a href=&#34;http://alper.nl/dingen/&#34;&gt;Alper&lt;/a&gt; is the &lt;a href=&#34;http://www.brepettis.com/blog/2009/3/3/the-cult-of-done-manifesto.html&#34;&gt;Cult
of
Done&lt;/a&gt;
manifesto. Take a minute or two to read it, and then get back at building stuff
and shipping things!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>How to keep your classes small and clean</title>
          <link>http://chris.eidhof.nl/post/how-to-keep-your-classes-small-and-clean/</link>
          <pubDate>Sun, 24 Feb 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/how-to-keep-your-classes-small-and-clean/</guid>
          <description>&lt;p&gt;I&amp;#8217;m a little obsessed with trying to write maintainable, clean code. I&amp;#8217;m not
yet really good at it, but try to become better every day. It started to become
more of an obsession than usual when I realized that a lot of the projects I
work on will someday be taken over by other people, and I don&amp;#8217;t want to be embarassed.&lt;/p&gt;

&lt;p&gt;This explains my recent interest in testing (&lt;a href=&#34;http://iosunittesting.com/&#34;&gt;some&lt;/a&gt;
&lt;a href=&#34;http://blog.securemacprogramming.com/&#34;&gt;interesting&lt;/a&gt;
&lt;a href=&#34;http://qualitycoding.org/&#34;&gt;blogs&lt;/a&gt; on that).&lt;/p&gt;

&lt;p&gt;Although I&amp;#8217;m not yet very good at testing everything, I have two other heuristics
that I use to keep my code maintainable: I try to keep my &lt;code&gt;.m&lt;/code&gt; files under a hundred lines (this is hard), and 
try to keep the number of imports small.&lt;/p&gt;

&lt;p&gt;Here are two scripts that I use to achieve this. The first one shows the &lt;code&gt;.m&lt;/code&gt; files
in your project with their line counts, and sorts them by line count. The bottom of the list
(largest files) are top candidates for refactoring:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -path &#39;./Pods&#39; -prune -o -name &#34;*.m&#34; -exec wc -l &#34;{}&#34; \; | sort -n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other script I wrote generates a &lt;code&gt;.dot&lt;/code&gt; file from your imports, and you can
open it with an app like &lt;a href=&#34;http://www.graphviz.org&#34;&gt;GraphViz&lt;/a&gt; to get a quick overview of how your imports are.
(I tried to keep it under 140 characters so it&amp;#8217;s tweetable).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &#34;digraph G {&#34;;grep &#34;import \&#34;&#34; **/*.m|sed &#34;s/.m:#import \&#34;/ /;s/.*\///;s/+/_/g;s/.h\&#34;//&#34;|awk &#34;{print \$2,\&#34;-&amp;gt; \&#34;\$1\&#34;;\&#34;}&#34;;echo &#34;}&#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Put the above line in a file or in a shell alias, run it and pipe the output to
a file that you can open with GraphViz. I&amp;#8217;m pretty sure this can be done even more effectively using just &lt;code&gt;awk&lt;/code&gt;, but
I&amp;#8217;m not an expert yet. Bonus points for the shortest solution!&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>New Things</title>
          <link>http://chris.eidhof.nl/post/new-things/</link>
          <pubDate>Thu, 31 Jan 2013 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://chris.eidhof.nl/post/new-things/</guid>
          <description>&lt;p&gt;Over Christmas, I read &lt;a href=&#34;http://www.amazon.de/Antifragile-Things-That-Gain-Disorder/dp/1400067820&#34;&gt;Antifragile&lt;/a&gt; by Taleb. The book has had quite an impact on me, and I decided to change some things. Long story short: I want to be open to positive black swans. A positive black swan is an event that will happen with a low probability, but if it does happen, it has a big impact.&lt;/p&gt;

&lt;p&gt;Taleb&amp;#8217;s strategy for investing is to invest mostly in very safe things, and
make small bets with a limited downside, but an unlimited upside. He calls this
the dumbbell strategy.  Applied to my own business as a freelance software
developer, this means that I will be continuing and expanding my  freelancing
business for most of the time.  But I am also spending time on projects that
have a limited cost, but an unlimited upside. I&amp;#8217;m not expecting that most of
these projects will be a wild success, but you only have to win big once&amp;#8230;&lt;/p&gt;

&lt;p&gt;One of these projects is organizing a conference. This will definitely not have an unlimited financial upside (best case, we might make a little bit of money, but it would be way more effective to spend that time freelancing). However, I do think that very nice things will happen because of this: meet more people, get known a bit better in the tech scene, and work together with really interesting people.&lt;/p&gt;

&lt;p&gt;Also, I have a renewed focus on building and maintaining my own apps. I&amp;#8217;m working on an update for &lt;a href=&#34;http://eidhof.nl/trackme&#34;&gt;TrackMe&lt;/a&gt; (I know it needs a better website and UI). I have some other interesting ideas for new apps too, hopefully I can move some of these projects forward so they can be released publicly.&lt;/p&gt;

&lt;p&gt;On a personal level, I am planning to go to more parties. This is directly copied from Taleb. At parties, you have a chance of meeting very interesting people. Probably at most parties you&amp;#8217;ll have a good time, but won&amp;#8217;t meet anybody new who&amp;#8217;s interesting. However, when you do, all the other parties will have been worth it.&lt;/p&gt;

&lt;p&gt;Also, I want to work together with more people. One of the ways this will happen is having an office instead of working from home. Another way will be by hiring more people. If you&amp;#8217;re interested in learning iOS Development, or if you&amp;#8217;re a copywriter, get in touch.&lt;/p&gt;

&lt;p&gt;I wonder how this strategy will work. I see it as something long-term, the payoff might only come in a decade. Let&amp;#8217;s see.&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
