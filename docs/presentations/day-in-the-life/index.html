<html>
	<head>
		<meta charset="utf-8"/>
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
		<meta content="width=device-width, initial-scale=1" name="viewport"/>
		<link href="/images/favicon.ico" rel="shortcut icon"/>
		<link href="/css/style.css" rel="stylesheet"/>
		<link href="http://chris.eidhof.nl//index.xml" rel="alternate" title="RSS" type="application/rss+xml"/>
		<title>
			A Day in the Life of a SwiftUI View — Chris Eidhof
		</title>
		<meta content="A Day in the Life of a SwiftUI View — Chris Eidhof" property="og:title"/>
		<meta content="website" property="og:type"/>
	</head>
	<body>
		<section id="content">
			<section id="outer-container">
				<section id="wrapper">
					<header id="header">
						<a href="/" id="title"><img src="/images/logo.png" style="width: 2em"/></a>
					</header>
					<article class="post">
						<header>
							<h1>
								A Day in the Life of a SwiftUI View
							</h1>
							August 12th, 2023
							Toronto, Canada
							SwiftConf.to
						</header>
						<section class="postbody">
							<p>
								My talk is called A Day in the Life of a SwiftUI View because I needed a catchy title. What it is about is understanding the mental model behind SwiftUI, or at least my mental model. I want to share with you how I think this stuff happens. And I learned this by teaching a lot, writing about this, and actually re-implementing large parts of SwiftUI. I tried to re-implement the state system and the layout system. When I say I, I actually mean we. I did a lot of this work together with Florian, who’s my collaborator. I want to focus on how the code we write translates into view trees. And then how these view trees translate into render trees. And I’ll define this a little bit better as we go about it.
							</p>
							<p><img src="/presentations/day-in-the-life/0.png" title/></p>
							<p>
								Let’s imagine we have this kind of content view that we wrote. And actually, we’re going to be writing this MyAsync image ourselves today. Now, what happens when we render a view like this?
							</p>
							<p><img src="/presentations/day-in-the-life/1.png" title/></p>
							<p>
								So the first thing that happens is a render tree node is created. And the render tree is something that doesn’t exist. SwiftUI internally calls this the attribute graph. I call it the render tree because I think it feels a little bit simpler. And I think of it as a tree, even though it is a graph. Now, the attribute graph is something we never deal with directly. This is hidden from us. There is no way to deal with this, at least not currently, and I don’t think there will be ever. But it is essential to understanding how SwiftUI works and how to be effective with SwiftUI. OK, so this looks simple.
							</p>
							<p><img src="/presentations/day-in-the-life/1.png" title/></p>
							<p>
								There is a node in a render tree, and we have this body that we need to expand in order to render a view, right? And SwiftUI does this.
							</p>
							<p><img src="/presentations/day-in-the-life/3.png" title/></p>
							<p>
								It runs the code in the body property, and it creates a view tree with a single node. And there’s the <code>logo.png</code> in that view tree. The view tree is something that we write. So I displayed it here as a tree, but this is just a struct value or multiple struct values. View trees are ephemeral. They go away very quickly. They’re used to render a view, and then they go away. The render tree is different. This behaves feels more like an object. The render tree is persistent. It’s going to be around even when your body re-executes. It’ll be there. And so the view trees are ephemeral, and the render trees are persistent. That’s very important to keep in mind.
							</p>
							<p><img src="/presentations/day-in-the-life/4.png" title/></p>
							<p>
								Now, what happens is once we have this view tree node, the corresponding node in the render tree gets created. So this is a one-to-one translation. So that’s pretty simple, right, so far.
							</p>
							<p><img src="/presentations/day-in-the-life/5.png" title/></p>
							<p>
								Now, the next thing that we need to do is expand the body of MyAsyncImage. The content view is done rendering. It can throw away and discard that entire view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/6.png" title/></p>
							<p>
								Let’s look at <code>MyAsyncImage</code>. This is the same step. We need to expand the body. In fact, we still need to write <code>MyAsyncImage</code>. So I have a very bare-bones prototype here with just a URL property and an empty body.
							</p>
							<p><img src="/presentations/day-in-the-life/7.png" title/></p>
							<p>
								One of the first things we’ll do is add a state property. And we’ll add this to hold the data that we loaded from the network, or that we actually will load from the network.
							</p>
							<p><img src="/presentations/day-in-the-life/8.png" title/></p>
							<p>
								And here’s where the render tree comes into play. When you create a state property like this, what SwiftUI will do, it will allocate memory for that in the render tree. And it needs to, right? Because we want the state property to stay around after we loaded the data. So this needs to be persistent. And this is where SwiftUI stores that in the render tree node. And this is, I think, important to build up that mental model. What we can also see is that the state property is initially nil. So on line 2, we see that we assigned nil as the initial value. This is the value that’s used when the node in the render tree is created. You should only be accessing those state properties inside the body of your view. This is why I also made it private.
							</p>
							<p><img src="/presentations/day-in-the-life/11.png" title/></p>
							<p>
								OK, let’s focus on the body of our view. We still need to write that. So a very first, very naive implementation would just be an image, right? Just force unwrap everything, and we’re done. This would be the view tree for that, just an image. So obviously, that’s wrong. So we need to do a little bit more.
							</p>
							<p><img src="/presentations/day-in-the-life/13.png" title/></p>
							<p>
								Now, we could add an if let around here. So we can load that image data, check if we can convert that into an image, and then display the image. Otherwise, we display a progress view. And this is where it starts to get interesting, I think.
							</p>
							<p>
								SwiftUI creates a conditional content as the root of our view tree. And it has an image and a progress view. And you can see the progress view is actually active. The image is not there. If you look at the type, if you would print the type of this body, you would see that it’s a conditional content with an image and a progress view. And so SwiftUI knows there will always be either an image or a progress view, never both, never neither. So this is all statically encoded into the type system. And this makes SwiftUI so efficient.
							</p>
							<p>
								OK, now we would like to start loading some data, and we want to write an onAppear. But we can’t, because we have an if/else. You cannot write onAppear on an if/else. So we need some kind of wrapper. It doesn’t really matter what you use here.
							</p>
							<p><img src="/presentations/day-in-the-life/15.png" title/></p>
							<p>
								I used the ZStack just because it felt the simplest. And what happens is when you do something like this is that we get a new root node. The ZStack is now the root of our view tree and the conditional content, the child of that ZStack.
							</p>
							<p><img src="/presentations/day-in-the-life/17.png" title/></p>
							<p>
								We’re finally ready to write our onAppear, and we can start loading our data. So here, it’s also quite interesting. So we saw that this container view created a new root node. But if we add a modifier on that, that will be the new root node. So these modifiers, they also turn into sort of parents of the thing they’re applying to.
							</p>
							<p><img src="/presentations/day-in-the-life/19.png" title/></p>
							<p>
								Now, because we have a presentation here, I’d like to load my code with as little code as possible, or load my data with as little code as possible. So I want to use async/await. An onAppear doesn’t play as nicely as task does. So we’re going to change this to a task, and now we can load our data in a single line, which is great for presentations. So this changes our view tree ever so slightly. So now we have a task instead of an onAppear. Otherwise, task and onAppear work exactly the same. They start executing the closure the moment the view appears on screen. And then if the body is re-executed, that task or that onAppear is not going to be executed again. OK, so I think we’re done with our view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/20.png" title/></p>
							<p>
								We’re good now. Now we can turn this into a render tree. And I think this is also very interesting. So this is a one-to-one translation. And we can really see this here.
							</p>
							<p><img src="/presentations/day-in-the-life/21.png" title/></p>
							<p>
								This is a direct copy, but there is a little bit more to it. So internally, of course, as I mentioned, the onAppear runs once, and the task runs once. And so to do that, once the rendering is done, SwiftUI will need to keep track of that.
							</p>
							<p><img src="/presentations/day-in-the-life/23.png" title/></p>
							<p>
								This is probably not how it’s implemented, but you can imagine there’s some kind of didAppear property in the render tree. And then initially, it’s false. So what happens when this view renders? Well, this didAppear turns to true.
							</p>
							<p><img src="/presentations/day-in-the-life/24.png" title/></p>
							<p>
								It’s a little bit hard to see, but you can see that it’s now true in the render tree, and the task is created. The data starts loading.
							</p>
							<p><img src="/presentations/day-in-the-life/26.png" title/></p>
							<p>
								And then once the data is there, it updates this image data property. And this is, again, very interesting what’s happening here. Whenever a property changes, whether that’s a regular property like the URL or a state property, like image data, SwiftUI invalidates the entire body.
							</p>
							<p><img src="/presentations/day-in-the-life/27.png" title/></p>
							<p>
								I made it gray here. It doesn’t throw this away. So remember, the render tree is persistent. It doesn’t throw away these nodes. It invalidates them, which means it needs to re-execute the view tree. And so we can look at the code and re-execute that view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/28.png" title/></p>
							<p>
								And then we get a new view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/29.png" title/></p>
							<p>
								And you can see here that there is a difference, right? In our view tree, we have an image node. And in our render tree, we have this progress view. I think one of the powers of SwiftUI is, of course, that we don’t need to think about adding subviews, removing subviews. This happens automatically. So as we update this render tree, SwiftUI will remove the progress view and all of its associated state and animations, and it will insert the image.
							</p>
							<p><img src="/presentations/day-in-the-life/30.png" title/></p>
							<p>
								And both the removal and the insertions are transitions that happen in parallel. OK, so now we have our updated render tree, and we can discard the view tree. We don’t need it anymore. And all is good.
							</p>
							<TODO>

							<p>
								You can see the progress indicator and the logo loaded. So we’re done, right? Not quite.
							</p>
							<p>
								Let’s rewrite our content view a little bit. I wonder if anybody already knows the problem here. But we will see it very quickly.
							</p>
							<p><img src="/presentations/day-in-the-life/32.png" title/></p>
							<p>
								So I’m going to add a state property here, just a Boolean, so that we can swap out between two images. I’ll add a VStack and a button. And then this button toggles the condition.
								And then based on that condition, we display either the logo or the photo.
							</p>
							<p><img src="/presentations/day-in-the-life/36.png" title/></p>
							<p>
								Now, when we run this, we get a view tree, of course. So we have our VStack with the button and the image. So it’s all fine.
							</p>
							<p><img src="/presentations/day-in-the-life/37.png" title/></p>
							<p>
								And we have a render tree. And initially, the condition will be true. And we have the same nodes as in the view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/38.png" title/></p>
							<p>
								So note that this condition, because it’s a state property, is now memory inside that render tree. So what happens next? So we have this render tree now, and it’s fine, and it’s good. And what happens when we change this condition? So let’s say it changes to false. It’s a bit subtle to see in the slide, but the condition is now false.
							</p>
							<p><img src="/presentations/day-in-the-life/39.png" title/></p>
							<p>
								Whenever this happens, of course, SwiftUI invalidates the entire content view.
							</p>
							<p><img src="/presentations/day-in-the-life/40.png" title/></p>
							<p>
								And so it needs to re-execute the code, come up with a new view tree. And now we can see there’s, again, a difference. In the view tree, it’s photo.jpg, whereas in the render tree, it’s logo.png.
							</p>
							<p><img src="/presentations/day-in-the-life/41.png" title/></p>
							<p>
								So SwiftUI can update the VStack and the button just fine. But of course, the MyAsync image is now invalid because it has a changed property.
							</p>
							<p><img src="/presentations/day-in-the-life/42.png" title/></p>
							<p>
								So we’re going to be re-executing that part. Before we do, let’s see what happens if we try to tap this button. So it doesn’t look like anything is happening. And I can tap this as many times as I want. I tried this when practicing, of course. It doesn’t change. So we have a problem.
							</p>
							 <TODO>

							<p>
								The problem is the implementation of our MyAsync image. So this is where we ended up with. I know it’s a bit much, but this is what we wrote in the previous slide.
							</p>
							<p><img src="/presentations/day-in-the-life/44.png" title/></p>
							<p>
								So we have our MyAsync image. It now has this changed URL property and this image data. So that’s the old data, right, the 8,000 bytes. The task had already appeared. SwiftUI knows to re-execute the body. It looks at this code that we wrote earlier.
							</p>
							<p><img src="/presentations/day-in-the-life/45.png" title/></p>
							<p>
								It executes it, creates a new task, a new ZStack, a new condition of content, and a new image.
							</p>
							<p><img src="/presentations/day-in-the-life/46.png" title/></p>
							<p>
								The thing that it doesn’t do is re-execute our task. The task node is just updated with the previous value, but it doesn’t re-execute this task for us because it only updates the render tree from the new view tree, and it doesn’t execute this task. So it never starts loading that photo data.
							</p>
							<p><img src="/presentations/day-in-the-life/47.png" title/></p>
							<p>
								This is a bit problematic. And we need a way to force SwiftUI to start reloading that data.
							</p>
							<p><img src="/presentations/day-in-the-life/48.png" title/></p>
							<p>
								This is where the problem is. We have a dependency here. We have a URL dependency here that is actually dependent on the URL property in our struct. And whenever you have a dependency like this in an onAppear or in a task, you potentially have a problem. if you’re doing code review, pay extreme attention to these kinds of dependencies. The problem, I think, is even worse because it looked like our code was doing just fine, right? Like our initial implementation of myasync image seemed to work. Like there’s no obvious bugs at first. Only when we used it differently, it stopped working. And so I think that’s very problematic.
							</p>
							<p><img src="/presentations/day-in-the-life/49.png" title/></p>
							<p>
								And so the reason is that we have this dependency. So we need to do something about that. And one thing we could do is actually add an identity modifier. And I add the URL as the identity.
							</p>
							<p><img src="/presentations/day-in-the-life/51.png" title/></p>
							<p>
								And what that will do is it will create a new root node in our view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/52.png" title/></p>
							<p>
								So we now have this identity. And the same for the render tree.
							</p>
							<p><img src="/presentations/day-in-the-life/53.png" title/></p>
							<p>
								This identity is now kept in the render tree. And SwiftUI knows if this ever changes, it needs to do something.
							</p>
							<p><img src="/presentations/day-in-the-life/54.png" title/></p>
							<p>
								So we displayed our logo. We have the data loaded. We have the logo.png as our identity. And now we’re going to change to photo.jpg.
							</p>
							<p><img src="/presentations/day-in-the-life/55.png" title/></p>
							<p>
								So our URL changes to photo.jpg, which means the view tree is invalidated.
							</p>
							<p><img src="/presentations/day-in-the-life/56.png" title/></p>
							<p>
								And this is where it gets a little bit weird. SwiftUI constructs a new view tree with the new identity. And we can see the difference, right? In the render tree, it’s logo.png, whereas in the view tree, it’s photo.jpg.
							</p>
							<p><img src="/presentations/day-in-the-life/57.png" title/></p>
							<p>
								What happens next is pretty brute force. SwiftUI removes all of the nodes in the render tree, everything. This includes any associated state they had, any animations that were running, everything. And so you can really think of this as removing all the subviews in UIKit and any state that they have associated. And these objects are completely gone.
							</p>
							<p><img src="/presentations/day-in-the-life/59.png" title/></p>
							<p>
								So the good thing is that after they’re removed, SwiftUI adds them back again, but sort of as fresh instances. And now our task has the didAppear set to false.
							</p>
							<p><img src="/presentations/day-in-the-life/60.png" title/></p>
							<p>
								So that means that when this view first appears on screen– so let’s say the rendering is complete and the view appears on screen– it will start a new task. So we can see the didAppear is now true. The task has been created.
							</p>
							<p><img src="/presentations/day-in-the-life/62.png" title/></p>
							<p>
								And when it runs, it loads the data. It updates image data, which is now 66 kilobytes.
							</p>
							<p><img src="/presentations/day-in-the-life/64.png" title/></p>
							<p>
								Because the property changed, the render tree is now invalidated, and we need to construct a new view tree.
							</p>
							<p><img src="/presentations/day-in-the-life/65.png" title/></p>
							<p>
								And then SwiftUI constructs a new view tree the same ID in this case, the task and the ZStack and conditional content are the same. What’s hard to see here is that we now have loaded the new image and we can display that.
							</p>
							<p><img src="/presentations/day-in-the-life/66.png" title/></p>
							<p>
								So SwiftUI will update our render tree with this new image and all is good. So let’s see if this works.
							</p>
							<p><img src="/presentations/day-in-the-life/68.png" title/></p>
							<p>
								We have our logo that we load. And if we tap the button, it starts loading the photo. And if we tap the button again, it starts loading the logo and so on. So it seems like now we’re good.
							</p>
							<p>
								One of the problems, of course, is this identity modifier. It’s not nice to destroy all these nodes. It feels wasteful, and we should do better than that. So let’s take a small step back.
							</p>
							<p><img src="/presentations/day-in-the-life/70.png" title/></p>
							<p>
								If we would have used onAppear, you can use exactly the same technique. You would have had the same problem that you depend on the URL, and you can use the same technique to make onAppear work. But for onAppear, there is a simpler solution. You can use onChangeOf. And I always use these two in combination, onAppear and onChangeOf.
							</p>
							<p><img src="/presentations/day-in-the-life/71.png" title/></p>
							<p>
								onAppear runs when my view first appears, and onChangeOf whenever this URL changes. In fact, this is so popular that people have been writing extensions that combine the two, so onAppear or changeOf. And in fact, even Apple saw this. And as of iOS 17, we can write onChange(of:initial:).
							</p>
							<p><img src="/presentations/day-in-the-life/72.png" title/></p>
							<p>
								And that will basically combine both of these two calls at once. Unfortunately, it’s iOS 17 only and macOS 14. But you can easily write this yourself. Now, we were stuck with our task.
							</p>
							<p><img src="/presentations/day-in-the-life/73.png" title/></p>
							<p>
								So for tasks, there’s also a very simple solution. And we can actually move this identity into the task and give the task identity. So we can call a different version of the task modifier and pass in the identity.
							</p>
							<p><img src="/presentations/day-in-the-life/74.png" title/></p>
							<p>
								What that will do is any time this URL changes, it will re-execute the task without having to destroy that entire render tree.
							</p>
							<p><img src="/presentations/day-in-the-life/75.png" title/></p>
							<p>
								So we can check that this works. So here we have our render tree. It’s all photo.jpg. And now we can look at the simulator, see that this still works, our updated version. So yeah, it seems fine.
							</p>
							<TODO>

							<p>
								There’s one more problem with this code, and that has to do with a different subsystem of SwiftUI. If we turn on the blueprint mode of the simulator, we can see that this photo stretches beyond the simulator. It’s much wider, and we want to display the entire photo.
							</p>
							<TODO>

							<p>
								And this is problematic. It looked fine at first, but we want to display that entire photo. And to understand this, we need to look into the layout system. And the first layout slide is a bit boring, because most of these modifiers don’t do anything.
							</p>
							<p><img src="/presentations/day-in-the-life/76.png" title/></p>
							<p>
								But the concept here, when we’re talking about SwiftUI layout, is that SwiftUI proposes sizes to views, and then views report their own size back. And they can do anything they want with this proposal. They can conform to that. They can do their own thing or partly take the proposal into account. So in this case, we’re going to be proposing the entire safe area to our MyAsyncImage node, because let’s say that’s the root node of our render tree.
							</p>
							<p><img src="/presentations/day-in-the-life/77.png" title/></p>
							<p>
								The <code>MyAsyncImage</code> node is layout agnostic, as are most of these modifiers here. And so it’s going to pass on a value unchanged to the identity.
							</p>
							<p><img src="/presentations/day-in-the-life/78.png" title/></p>
							<p>
								The identity is going to pass a value unchanged to the task, to the z-stack, to the conditional content. Finally, the conditional content is going to pass that value to our image node.
							</p>
							<p><img src="/presentations/day-in-the-life/82.png" title/></p>
							<p>
								So it’s going to propose 390 by 763 to our image node. And this is where it gets interesting. image node takes that proposal, and it says, well, I only need 265 by 80.
							</p>
							<p><img src="/presentations/day-in-the-life/83.png" title/></p>
							<p>
								So that’s going to be my size. It’s going to propose that all the way back up. And as these nodes are all layout agnostic, it will go all the way to the body and to the MyAsync image.
							</p>
							<p><img src="/presentations/day-in-the-life/87.png" title/></p>
							<p>
								And the MyAsync image will propose this size or report this size back to its parent.
							</p>
							<p><img src="/presentations/day-in-the-life/88.png" title/></p>
							<p>
								And then SwiftUI sort of takes care of centering that size within the safe area. To understand this a little bit better, I want to focus on the image nodes, because these are the interesting ones.
							</p>
							<p><img src="/presentations/day-in-the-life/89.png" title/></p>
							<p>
								Let’s see what happens when we propose a bunch of different sizes to the image node. Let’s propose the safe area.
							</p>
							<p><img src="/presentations/day-in-the-life/90.png" title/></p>
							<p>
								We saw this already. When we propose the safe area, the image node says, well, I’m just 265 by 80. So it almost ignores this, right?
							</p>
							<p><img src="/presentations/day-in-the-life/91.png" title/></p>
							<p>
								When we propose 200 by 200…
							</p>
							<p><img src="/presentations/day-in-the-life/93.png" title/></p>
							<p>
								The image node says, well, I was 265 by 80. So again, it seems like it ignores it. And then we have this special proposal. So we can propose nil by nil.
							</p>
							<p><img src="/presentations/day-in-the-life/96.png" title/></p>
							<p>
								This means become your ideal size. For the auto layout people, this is the intrinsic content size. So you can propose nil by nil to a view to make it become its ideal size. When we do that, the image says, I’m 265 by 80.
							</p>
							<p><img src="/presentations/day-in-the-life/97.png" title/></p>
							<p>
								So we’re a little bit stuck here, right?
							</p>
							<p>
								There’s only one modifier image node that can change this. And it’s the resizable modifier. So let’s look at that. When we use this, it actually modifies the image node internally. So that’s why we have only a single node in the render tree here.
							</p>
							<p><img src="/presentations/day-in-the-life/99.png" title/></p>
							<p>
								OK, let’s go through these steps again with the proposing and the reporting and see what happens now. When we propose the entire safe area, a resizable image says, OK, fine, I’ll take it.
							</p>
							<p><img src="/presentations/day-in-the-life/101.png" title/></p>
							<p>
								That’s going to be my size. So if you ever need designers who want to have the logo bigger, this is your go-to. When we propose 200 by 200…
							</p>
							<p><img src="/presentations/day-in-the-life/103.png" title/></p>
							<p>
								the image node is going to say, fine, I’ll take it. And it looks a little bit stretched, but it’s a lot better than what we had with the full safe area.
							</p>
							<p><img src="/presentations/day-in-the-life/104.png" title/></p>
							<p>
								And when we propose nil by nil– let’s see.
							</p>
							<p><img src="/presentations/day-in-the-life/106.png" title/></p>
							<p>
								When we propose nil by nil, the image node says, OK, I’m going to be 265 by 80.
							</p>
							<p><img src="/presentations/day-in-the-life/107.png" title/></p>
							<p>
								And this 265 by 80, it’s really the underlying bitmap size. And that’s why it’s reporting that. So then it renders at its original resolution. Now, there is no built-in way to images to do like aspect ratio resizing or anything like that.
							</p>
							<p>
								There is a modifier in SwiftUI, but it works for any SwiftUI view. And it’s the aspect ratio modifier. And we can say <code>aspectRatio(contentMode: .fits)</code>.
							</p>
							<p><img src="/presentations/day-in-the-life/109.png" title/></p>
							<p>
								So this is the render tree that would look– that would be the tree for this code, right? And I think this is really cool how this works, because aspect ratio, as I said, is not tied to images specifically. So when we propose to the aspect ratio, Let’s say we propose the entire safe area.
							</p>
							<p><img src="/presentations/day-in-the-life/110.png" title/></p>
							<p>
								Now it gets really cool, I think. So <code>aspectRatio</code> doesn’t know the underlying aspect ratio of the image. It needs to figure that out. And here’s what it’s doing: it’s going to propose nil by nil to the image.
							</p>
							<p><img src="/presentations/day-in-the-life/111.png" title/></p>
							<p>
								The image says I’m 265 by 80.
							</p>
							<p><img src="/presentations/day-in-the-life/112.png" title/></p>
							<p>
								Then the aspect ratio takes that 265 by 80, and it’s going to fit a rectangle inside the entire safe area, its proposal. It’s going to fit a rectangle with that same aspect ratio inside the safe area.
							</p>
							<p><img src="/presentations/day-in-the-life/113.png" title/></p>
							<p>
								Then it’s going to propose the image again. So it’s proposing twice. You can see this has the same aspect ratio. And so now the image stretches all the way to the bounds of our screen with the correct aspect ratio.
							</p>
							<p><img src="/presentations/day-in-the-life/114.png" title/></p>
							<p>
								I think this is really cool how this works, by proposing nil first. And let’s see what happens at different sizes. So if we had 200 by 200 as our proposal, the aspect ratio will do the same thing.
							</p>
							<p><img src="/presentations/day-in-the-life/116.png" title/></p>
							<p>
								It doesn’t know the underlying aspect ratio because we didn’t specify it. It will propose nil by nil to the image.
							</p>
							<p><img src="/presentations/day-in-the-life/117.png" title/></p>
							<p>
								The image says, well, my underlying size is 265 by 80.
							</p>
							<p><img src="/presentations/day-in-the-life/118.png" title/></p>
							<p>
								Then the aspect ratio takes that aspect ratio, fits it inside the 200 by 200, and it proposes 200 by 60.
							</p>
							<p><img src="/presentations/day-in-the-life/119.png" title/></p>
							<p>
								Now the image is done, and it can report its size back.
							</p>
							<p><img src="/presentations/day-in-the-life/120.png" title/></p>
							<p>
								It’s this two-step proposing in case of the aspect ratio which I think is really cool. Now, let’s look at the photo, see what happens here.
							</p>
							<p><img src="/presentations/day-in-the-life/122.png" title/></p>
							<p>
								We propose the safe area to our photo:
							</p>
							<p><img src="/presentations/day-in-the-life/123.png" title/></p>
							<p>
								And aspect ratio needs to, again, propose nil by nil.
							</p>
							<p><img src="/presentations/day-in-the-life/124.png" title/></p>
							<p>
								The image says: my size is 629 by 271. This, again, stretches beyond the bounds.
							</p>
							<p><img src="/presentations/day-in-the-life/125.png" title/></p>
							<p>
								The aspect ratio then takes a rectangle with that same aspect ratio that fits within the safe area, and it proposes that to the image.
							</p>
							<p><img src="/presentations/day-in-the-life/126.png" title/></p>
							<p>
								This way, we can get an image that displays the full image at the correct aspect ratio.
							</p>
							<p><img src="/presentations/day-in-the-life/127.png" title/></p>
							<p>
								OK, we’re almost done. Now, this is the code we had that we ended up writing.
							</p>
							<p><img src="/presentations/day-in-the-life/129.png" title/></p>
							<p>
								Now we need to build this aspect ratio code into our view. We can just add a resizable property and then modify our image code.
							</p>
							<p><img src="/presentations/day-in-the-life/130.png" title/></p>
							<p>
								So we can just add an if else around this image code. And then in the case that is resizable, we create a resizable image. Otherwise not. Unfortunately, this is the way we’d have to write it because the resizable modifier doesn’t take a Boolean.
							</p>
							<p><img src="/presentations/day-in-the-life/132.png" title/></p>
							<p>
								This is not very nice because now we need to initialize our image with a URL and that resizable Boolean. And that doesn’t look the same way as the image initializer does, where you have the dot resizable modifier. But we can add that very easily as well. To do that, we can make our property private.
							</p>
							<p><img src="/presentations/day-in-the-life/133.png" title/></p>
							<p>
								Then we can add an extension to the image and use the fact that views are value types. We can just create a copy of self, set the property to true, and return that copy without ever having to exposing this underscore resizable property.
							</p>
							<p><img src="/presentations/day-in-the-life/134.png" title/></p>
							<p>
								So that’s how you can have that same API. And let’s update our content view for this. So this is the previous version, the one that’s broken layout-wise, which extends.
							</p>
							<p><img src="/presentations/day-in-the-life/135.png" title/></p>
							<p>
								Now we can change the code a little bit. We can add the resizable modifier and the aspect ratio. And we can already see that it stretches all the way to the edges of the screen.
							</p>
							<p><img src="/presentations/day-in-the-life/136.png" title/></p>
							<p>
								So if we tap it, it reloads, hopefully. And it stretches all the way to the edges of the screen. So now we’re done.
							</p>
							<p>
								There is a lot more I wanted to talk about. And I think the most important concept here is understanding how the code translates into trees and how you can then use those trees for state management, for layout, and many other things.
							</p>
							<p>
								One of the things I wanted to show is that maybe you feel like this nil proposal, that was a little bit weird, right? This nil proposal is everywhere, actually. A vertical scroll view has infinite space vertically. So it can stretch all the way beyond the bounds of the screen. And so what a vertical scroll view does is really cool. It proposes the width it got proposed, so let’s say 320 or something. And it proposes nil for the height, which means the view has to take that 320, but it can become any height it wants.
							</p>
							<p><img src="/presentations/day-in-the-life/137.png" title/></p>
							<p>
								When we talk about stack layouts, it’s also very interesting what happens in terms of proposing and reporting. A stack proposes to its children, and it starts by proposing 0 for the width. Let’s say we have an HStack. The children all report their sizes for that zero. And so it does this for each one of the children.
							</p>
							<p><img src="/presentations/day-in-the-life/139.png" title/></p>
							<p>
								Then it does the same thing again and proposes a very large size. And then for each child, it takes the difference of these two return values. And this is called the flexibility of a view. So it basically means, what is your size at zero? What is your size at a very large number? And this is going to be your flexibility, like your minimum width and your maximum width, in a sense.
							</p>
							<p><img src="/presentations/day-in-the-life/143.png" title/></p>
							<p>
								And then SwiftUI takes all the subviews, and it reorders them according to flexibility.
							</p>
							<p><img src="/presentations/day-in-the-life/144.png" title/></p>
							<p>
								And then it proposes again, and it starts with the least flexible view first, and then goes in that order. That’s why stack views mostly look right and do what you want.
							</p>
							<p>
								I would have also liked to talk about the environment. The environment also works on these trees, on the render trees. And it’s all about information that flows down the render tree.
							</p>
							<p><img src="/presentations/day-in-the-life/149.png" title/></p>
							<p>
								This is at least how I imagine this always. So the environment passes values from the parent to the child and then all the way down. So it’s only information that flows down.
							</p>
							<p><img src="/presentations/day-in-the-life/150.png" title/></p>
							<p>
								If you ever heard about preferences, this is sort of the thing that comes with the environment but in the other direction. With preferences, information flows up the view tree. So children propagate information to their parents.
							</p>
							<p><img src="/presentations/day-in-the-life/153.png" title/></p>
							<p>
								They combine that information, and any preference value can be read by an ancestor. Again, to understand what’s happening there, it’s very important to understand these trees.
							</p>
							<p>
								There is a lot more that has to do with all these trees. If you want to know more about it, you can actually read <a href="https://www.objc.io/books/thinking-in-swiftui/">our book</a>. It’s almost done. We did a complete rewrite. I think this book is really fun to read, and it goes into all the details that you cannot possibly cover in a 30-minute talk.
							</p>
							<p>
								If you have any questions, please feel free to reach out. Thank you!
							</p>
						</section>
					</article>
				</section>
			</section>
		</section>
	</body>
</html>