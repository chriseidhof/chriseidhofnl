<html>
	<head>
		<meta charset="utf-8"/>
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
		<meta content="width=device-width, initial-scale=1" name="viewport"/>
		<script src="//use.typekit.net/bwu1cse.js" type="text/javascript">
		</script>
		<script type="text/javascript">
			try{Typekit.load();}catch(e){}
		</script>
		<link href="/images/favicon.ico" rel="shortcut icon"/>
		<link href="/css/style.css" rel="stylesheet"/>
		<link href="http://chris.eidhof.nl//index.xml" rel="alternate" title="RSS" type="application/rss+xml"/>
		<title>
			Protocols in Swift — Chris Eidhof
		</title>
	</head>
	<body>
		<section id="content">
			<section id="outer-container">
				<section id="wrapper">
					<header id="header">
						<a href="/" id="title"><img src="/images/logo.png" style="width: 2em"/></a>
					</header>
					<article class="post">
						<header>
							<h1>
								Protocols in Swift
							</h1>
							<h2 class="headline">
								Conforming to the Collection protocol
							</h2>
						</header>
						<section class="postbody">
							<p>
								Let’s say we are writing our own data-structure, a singly linked list:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">enum</span> <span class="hljs-identifier">ListNode</span><<span class="hljs-identifier">A</span>> {
    <span class="hljs-keyword">case</span> <span class="hljs-identifier">end</span>
    <span class="hljs-identifier">indirect</span> <span class="hljs-keyword">case</span> <span class="hljs-identifier">cons</span>(<span class="hljs-identifier">A</span>, <span class="hljs-identifier">ListNode</span>)
}
</code></pre>
							<p>
								Today’s goal is to make <code>ListNode</code> conform to the <code>Collection</code> protocol. It’s actually fairly easy, but it’s almost impossible to figure it out by just looking at the types. The documentation tells us which methods to implement, but why is it like that? Even though the protocol is clearly specified, it’s not so easy to see what you need to do. Let’s give it a try without looking at the documentation, and see what the compiler tells us:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">extension</span> <span class="hljs-identifier">ListNode</span>: <span class="hljs-identifier">Collection</span> { }
</code></pre>
							<p>
								The compiler tells us we don’t conform to the following three protocols: <code>Sequence</code>, <code>IndexableBase</code>, and <code>Collection</code>.
							</p>
							<p>
								Looking at all these protocols, you might get overwhelmed. The most complicated one, <code>Collection</code>, comes in at a whopping four associated types, two subscripts, four computed properties and seven methods. A protocol is a formal “todo-list” of all the things your type needs to do in order to conform. I copy/pasted this from the Standard Library, and removed all the documentation comments. With the documentation comments, it gets even harder to see!
							</p>
							<pre><code class="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-identifier">Collection</span> : <span class="hljs-identifier">Indexable</span>, <span class="hljs-identifier">Sequence</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">IndexDistance</span> : <span class="hljs-identifier">SignedInteger</span> = <span class="hljs-identifier">Int</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">Iterator</span> : <span class="hljs-identifier">IteratorProtocol</span> = <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">SubSequence</span> : <span class="hljs-identifier">IndexableBase</span>, <span class="hljs-identifier">Sequence</span> = <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">Indices</span> : <span class="hljs-identifier">IndexableBase</span>, <span class="hljs-identifier">Sequence</span> = <span class="hljs-identifier">DefaultIndices</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>.<span class="hljs-identifier">Element</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">bounds</span>: <span class="hljs-identifier">Range</span><<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">indices</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Indices</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">isEmpty</span>: <span class="hljs-identifier">Bool</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">count</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">IndexDistance</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">first</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>.<span class="hljs-identifier">Element</span>? { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">makeIterator</span>() -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-identifier">upTo</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">suffix</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-identifier">through</span> <span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">IndexDistance</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">IndexDistance</span>, <span class="hljs-identifier">limitedBy</span> <span class="hljs-identifier">limit</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>?
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">distance</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">to</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">IndexDistance</span>
}
</code></pre>
							<p>
								The interesting thing is: all associated types have default values. So if we decide to stick with them, we can cross those off of the todo-list, and fill the other parameters with their types:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-identifier">Collection</span> : <span class="hljs-identifier">Indexable</span>, <span class="hljs-identifier">Sequence</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>.<span class="hljs-identifier">Element</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">bounds</span>: <span class="hljs-identifier">Range</span><<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>>) -> <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">indices</span>: <span class="hljs-identifier">DefaultIndices</span><<span class="hljs-keyword">Self</span>> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">isEmpty</span>: <span class="hljs-identifier">Bool</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">count</span>: <span class="hljs-identifier">Int</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">first</span>: <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>.<span class="hljs-identifier">Element</span>? { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">makeIterator</span>() -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-identifier">upTo</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">suffix</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-identifier">through</span> <span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>, <span class="hljs-identifier">limitedBy</span> <span class="hljs-identifier">limit</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>?
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">distance</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">to</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Int</span>
}
</code></pre>
							<p>
								Many of the properties and methods have default implementations as well. For example, here are the default extensions on <code>Collection</code>:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">extension</span> <span class="hljs-identifier">Collection</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">map</span><<span class="hljs-identifier">T</span>>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">transform</span>: @<span class="hljs-identifier">noescape</span> (<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>.<span class="hljs-identifier">Element</span>) <span class="hljs-keyword">throws</span> -> <span class="hljs-identifier">T</span>) <span class="hljs-keyword">rethrows</span> -> [<span class="hljs-identifier">T</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">dropFirst</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">dropLast</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">maxLength</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">suffix</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">maxLength</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-identifier">upTo</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">suffix</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">prefix</span>(<span class="hljs-identifier">through</span> <span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">split</span>(<span class="hljs-identifier">maxSplits</span>: <span class="hljs-identifier">Int</span> = <span class="hljs-keyword">default</span>, <span class="hljs-identifier">omittingEmptySubsequences</span>: <span class="hljs-identifier">Bool</span> = <span class="hljs-keyword">default</span>, <span class="hljs-identifier">whereSeparator</span> <span class="hljs-identifier">isSeparator</span>: @<span class="hljs-identifier">noescape</span> (<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>.<span class="hljs-identifier">Element</span>) <span class="hljs-keyword">throws</span> -> <span class="hljs-identifier">Bool</span>) <span class="hljs-keyword">rethrows</span> -> [<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-identifier">where</span> <span class="hljs-identifier">predicate</span>: @<span class="hljs-identifier">noescape</span> (<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>.<span class="hljs-identifier">Element</span>) <span class="hljs-keyword">throws</span> -> <span class="hljs-identifier">Bool</span>) <span class="hljs-keyword">rethrows</span> -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>?
}

<span class="hljs-keyword">extension</span> <span class="hljs-identifier">Collection</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">isEmpty</span>: <span class="hljs-identifier">Bool</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">first</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Iterator</span>.<span class="hljs-identifier">Element</span>? { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">underestimatedCount</span>: <span class="hljs-identifier">Int</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">count</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">IndexDistance</span> { get }
}
</code></pre>
							<p>
								These default extensions allow us to cross the <code>prefix</code> and <code>suffix</code> methods off of our list. Our todo-list is now a bit shorter:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-identifier">Collection</span> : <span class="hljs-identifier">Indexable</span>, <span class="hljs-identifier">Sequence</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>.<span class="hljs-identifier">Element</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">bounds</span>: <span class="hljs-identifier">Range</span><<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>>) -> <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">indices</span>: <span class="hljs-identifier">DefaultIndices</span><<span class="hljs-keyword">Self</span>> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">makeIterator</span>() -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>, <span class="hljs-identifier">limitedBy</span> <span class="hljs-identifier">limit</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>?
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">distance</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">to</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Int</span>
}
</code></pre>
							<p>
								There are more extensions that apply, though. For example:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">extension</span> <span class="hljs-identifier">Collection</span> <span class="hljs-keyword">where</span> <span class="hljs-identifier">SubSequence</span> == <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">bounds</span>: <span class="hljs-identifier">Range</span><<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>>) -> <span class="hljs-identifier">Slice</span><<span class="hljs-keyword">Self</span>> { get }
}
<span class="hljs-keyword">extension</span> <span class="hljs-identifier">Collection</span> <span class="hljs-keyword">where</span> <span class="hljs-identifier">Indices</span> == <span class="hljs-identifier">DefaultIndices</span><<span class="hljs-keyword">Self</span>> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">indices</span>: <span class="hljs-identifier">DefaultIndices</span><<span class="hljs-keyword">Self</span>> { get }
}
<span class="hljs-keyword">extension</span> <span class="hljs-identifier">Collection</span> <span class="hljs-keyword">where</span> <span class="hljs-identifier">Iterator</span> == <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">makeIterator</span>() -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>
}
</code></pre>
							<p>
								Because all three apply, we can get rid of three more todos. Our list is getting shorter.
							</p>
							<pre><code class="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-identifier">Collection</span> : <span class="hljs-identifier">Indexable</span>, <span class="hljs-identifier">Sequence</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>.<span class="hljs-identifier">Element</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>, <span class="hljs-identifier">limitedBy</span> <span class="hljs-identifier">limit</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>?
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">distance</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">to</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Int</span>
}
</code></pre>
							<p>
								If we start adding the <code>Indexable</code> requirements to our todo-list, we end up with a long list again. We now also need to conform to IndexableBase.
							</p>
							<pre><code class="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-identifier">Collection</span> : <span class="hljs-identifier">IndexableBase</span>, <span class="hljs-identifier">Sequence</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">IndexingIterator</span><<span class="hljs-keyword">Self</span>>.<span class="hljs-identifier">Element</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-keyword">_</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">offsetBy</span> <span class="hljs-identifier">n</span>: <span class="hljs-identifier">Int</span>, <span class="hljs-identifier">limitedBy</span> <span class="hljs-identifier">limit</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>?
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">distance</span>(<span class="hljs-identifier">from</span> <span class="hljs-identifier">start</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>, <span class="hljs-identifier">to</span> <span class="hljs-identifier">end</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Int</span>
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">Index</span> : <span class="hljs-identifier">Comparable</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">startIndex</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">endIndex</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">_Element</span> { get }
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">SubSequence</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">bounds</span>: <span class="hljs-identifier">Range</span><<span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">SubSequence</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-identifier">after</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">formIndex</span>(<span class="hljs-identifier">after</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">inout</span> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>)
}
</code></pre>
							<p>
								However, after removing all default implementations that are provided by collection, and using all extension that apply to our current protocol, we can cross out almost all the newly added <code>Indexable</code> requirements (many have a default implementation). We can keep playing the game of looking at the extensions, crossing out requirements, adding new ones, until we finally end up with a minimal set of things we need to do:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-identifier">Collection</span> {
    <span class="hljs-keyword">associatedtype</span> <span class="hljs-identifier">Index</span> : <span class="hljs-identifier">Comparable</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">startIndex</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-identifier">endIndex</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span> { get }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-identifier">after</span> <span class="hljs-identifier">i</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-keyword">Self</span>.<span class="hljs-identifier">Index</span>) -> <span class="hljs-identifier">Element</span> { get }
}
</code></pre>
							<p>
								Lo and behold, we can make <code>ListNode</code> conform:
							</p>
							<pre><code class="swift"><span class="hljs-keyword">extension</span> <span class="hljs-identifier">ListNode</span>: <span class="hljs-identifier">Collection</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-identifier">startIndex</span>: <span class="hljs-identifier">Int</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> }
    <span class="hljs-comment">/// This is 0(n), not the expected O(1) from `Collection`.</span>
    <span class="hljs-keyword">var</span> <span class="hljs-identifier">endIndex</span>: <span class="hljs-identifier">Int</span> {
        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
        <span class="hljs-keyword">case</span> .<span class="hljs-identifier">end</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">case</span> .<span class="hljs-identifier">cons</span>(<span class="hljs-keyword">_</span>, <span class="hljs-keyword">let</span> <span class="hljs-identifier">tail</span>): <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-identifier">tail</span>.<span class="hljs-identifier">endIndex</span>
        }
    }
    <span class="hljs-keyword">func</span> <span class="hljs-identifier">index</span>(<span class="hljs-identifier">after</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-identifier">Int</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-identifier">after</span>+<span class="hljs-number">1</span>
    }
    <span class="hljs-comment">/// This is 0(n), not the expected O(1) from `Collection`.</span>
    <span class="hljs-keyword">subscript</span>(<span class="hljs-identifier">position</span>: <span class="hljs-identifier">Int</span>) -> <span class="hljs-identifier">A</span> {
        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>, <span class="hljs-identifier">position</span>) {
        <span class="hljs-keyword">case</span> (.<span class="hljs-identifier">end</span>, <span class="hljs-keyword">_</span>): <span class="hljs-identifier">fatalError</span>(<span class="hljs-string">"</span><span class="hljs-string">Index out of bounds</span><span class="hljs-string">"</span>)
        <span class="hljs-keyword">case</span> (.<span class="hljs-identifier">cons</span>(<span class="hljs-keyword">let</span> <span class="hljs-identifier">x</span>, <span class="hljs-keyword">_</span>), <span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-identifier">x</span>
        <span class="hljs-keyword">case</span> (.<span class="hljs-identifier">cons</span>(<span class="hljs-keyword">_</span>, <span class="hljs-keyword">let</span> <span class="hljs-identifier">tail</span>), <span class="hljs-keyword">_</span>): <span class="hljs-keyword">return</span> <span class="hljs-identifier">tail</span>[<span class="hljs-identifier">position</span>-<span class="hljs-number">1</span>]
        }
    }
}
</code></pre>
							<p>
								Note that we didn’t have to specify the <code>associatedtype</code>, the compiler inferred this for us.
							</p>
							<p>
								Long story short: it’s really hard to see what you need to conform to. Or to be more precise: it’s not that hard, it’s just a <em>lot</em>
								 of manual work. Luckily, all of this can be completely automated. Unfortunately, the tooling in this respect is currently still very immature, even though the standard library isn’t. I have no idea if this will improve soon.
							</p>
							<p>
								Rather than waiting for Apple to fix this, maybe someone in the community could do this? I imagine it’s a few days of hard work: first you need to parse all the protocols in the standard library (or better: use SourceKit, because then you can also make it work on your own protocols). Then you need to have some kind of evaluation system that checks which extensions can be applied. It might need to be interactive, for example, once you specify that the <code>Index</code> associated type will be an <code>Int</code>, it could tell you what you still need to implement.
							</p>
							<p>
								I’d love to build this myself, however, I’m currently too busy writing the update of <a href="https://www.objc.io/books/advanced-swift/">Advanced Swift</a>, and preparing new <a href="https://talk.objc.io">Swift Talk episodes</a>. It would be the perfect procrastination project…
							</p>
							<p>
								Update: Nicola <a href="https://twitter.com/NSalmoria/status/764158023124258817">writes in</a> that “Conforming to the Collection Protocol” is actually a section of the <a href="https://developer.apple.com/reference/swift/collection">API documentation</a>. Very good point. He also raises the point that my <code>endIndex</code> and <code>subscript</code> implementations aren’t <code>O(1)</code>, which is the expected complexity as described in the <code>Collection</code> protocol.
							</p>
						</section>
						<footer class="group" id="post-meta">
							<div>
								<span>Posted on 
									<span><time>Aug 12, 2016</time>
										 by 
										<a href="http://www.twitter.com/chriseidhof/">@chriseidhof</a></span></span>
							</div>
						</footer>
					</article>
					<footer class="group promo" id="post-meta">
						<div>
							<img src="/images/advanced-swift.png" style="width: 90px;"/>
						</div>
						<p>
							<p>
								If you liked this article, check out our book <a href="https://www.objc.io/books/advanced-swift/">Advanced Swift</a>, or check out <a href="https://talk.objc.io">Swift Talk</a>.
							</p>
						</p>
					</footer>
					<footer>
						<nav id="post-nav">
							<span class="prev"><a href="/post/structs-and-mutation-in-swift"><span class="arrow">←</span>
									Structs and mutation in Swift</a></span>
							<span class="next"><a href="/post/responder-chain-alternative">Responder Chain Alternatives
									<span class="arrow">→</span></a></span>
						</nav>
					</footer>
				</section>
			</section>
		</section>
	</body>
</html>