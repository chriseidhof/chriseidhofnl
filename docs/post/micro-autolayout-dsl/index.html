
<html>
	<head>
		<meta charset="utf-8"/>
		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
		<meta content="width=device-width, initial-scale=1" name="viewport"/>
		<script src="//use.typekit.net/bwu1cse.js" type="text/javascript">
		</script>
		<script type="text/javascript">
			try{Typekit.load();}catch(e){}
		</script>
		<link href="/images/favicon.ico" rel="shortcut icon"/>
		<link href="/css/style.css" rel="stylesheet"/>
		<link href="http://chris.eidhof.nl//index.xml" rel="alternate" title="RSS" type="application/rss+xml"/>
		<title>
			Chris Eidhof
		</title>
	</head>
	<body>
		<section id="content">
			<section id="outer-container">
				<section id="wrapper">
					<header id="header">
						<a href="/" id="title"><img src="/images/logo.png" style="width: 2em"/></a>
					</header>
					<article class="post">
						<header>
							<h1>
								A Micro Auto Layout DSL
							</h1>
							<h2 class="headline">
								Three Methods To Make Life Easier
							</h2>
						</header>
						<section class="postbody">
							<p>
								These days, I&apos;m using fewer external libraries. First, I don&apos;t like most Swift libraries out there, they&apos;re often implemented in a complicated way and contain too many protocols for my taste. Second, I&apos;m not sure how they&apos;ll be maintained in the future, and most libraries are pretty big -- I don&apos;t really want to own that code. Third, I&apos;m too lazy to set up a dependency manager, so I&apos;ll keep my projects dependency-free.
							</p>
							<p>
								However, the other day as I was writing some UIKit code, I found myself annoyed at the verbosity of Auto Layout. Here&apos;s some code that I wrote over and over again:
							</p>
							<pre><code class="swift">let view = UIView()
let label = UILabel()
view.addSubview(label)
label.translatesAutoresizingMaskIntoConstraints = false
NSLayoutConstraint.activate([
    label.leadingAnchor.constraint(equalTo: view.leadingAnchor),
    label.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
    label.trailingAnchor.constraint(equalTo: view.trailingAnchor)
])
</code></pre>
							<p>
								It&apos;s always the same pattern: adding the subview, setting <code>translatesAutoresizingMaskIntoConstraints</code> to false, and then activating the constraints. The first anchor and the second anchor are almost always the same, and on the left-hand side we always have the child and on the right-hand side we always have the parent view. Often, when I write the code above, I forget to active the constraints or forget to set <code>translatesAutoresizingMaskIntoConstraints</code>. Let&apos;s try to solve as many of these problems as we can in as little code as possible.
							</p>
							<p>
								Rather than pulling in a library, I decided to write my own. The first bit of my micro-library is a function that, given a child and a parent, returns a layout constraint:
							</p>
							<pre><code class="swift">typealias Constraint = (_ child: UIView, _ parent: UIView) -&gt; NSLayoutConstraint
</code></pre>
							<p>
								Ideally, we would now write a method <code>equal</code> which allows us to write following:
							</p>
							<pre><code class="swift">let constraint: Constraint = equal(\.topAnchor, \.safeAreaLayoutGuide.topAnchor)
</code></pre>
							<p>
								Note that <code>constraint</code> is just a description of a layout constraint -- it&apos;s still waiting for a concrete child and parent view. It says that, given a child and parent, the child&apos;s top anchor should be equal to the parent&apos;s <code>safeAreaLayoutGuide.topAnchor</code>.
							</p>
							<p>
								We can implement <code>equal</code> with a little bit of keypath magic:
							</p>
							<pre><code class="swift">func equal&lt;Axis, Anchor&gt;(_ keyPath: KeyPath&lt;UIView, Anchor&gt;, _ to: KeyPath&lt;UIView, Anchor&gt;, constant: CGFloat = 0) -&gt; Constraint where Anchor: NSLayoutAnchor&lt;Axis&gt; {
    return { view, parent in
        view[keyPath: keyPath].constraint(equalTo: parent[keyPath: to], constant: constant)
    }
}
</code></pre>
							<p>
								Most of the time, the two layout anchors are the same (e.g. <code>leadingAnchor</code> and <code>leadingAnchor</code>), so let&apos;s write a small helper for that case:
							</p>
							<pre><code class="swift">func equal&lt;Axis, Anchor&gt;(_ keyPath: KeyPath&lt;UIView, Anchor&gt;, constant: CGFloat = 0) -&gt; Constraint where Anchor: NSLayoutAnchor&lt;Axis&gt; {
    return equal(keyPath, keyPath, constant: constant)
}
</code></pre>
							<p>
								Finally, let&apos;s solve the last two problems: we don&apos;t want to forget to set <code>translatesAutoresizingMaskIntoConstraints</code> to false, and we don&apos;t want to forget to activate the constraints. What if we create another version of <code>addSubview</code> that does this for us?
							</p>
							<pre><code class="swift">extension UIView {
    func addSubview(_ child: UIView, constraints: [Constraint]) {
        addSubview(child)
        child.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate(constraints.map { $0(child, self) })
    }
}
</code></pre>
							<p>
								We now have everything in place to rewrite our initial example:
							</p>
							<pre><code class="swift">let view = UIView()
let label = UILabel()
view.addSubview(label, constraints: [
   equal(\.leadingAnchor),
   equal(\.topAnchor, \.safeAreaLayoutGuide.topAnchor),
   equal(\.trailingAnchor)
])
</code></pre>
							<p>
								The code is shorter and much more to the point. The <code>translatesAutoresizingMaskIntoConstraints</code> is set automatically, and all constraints are activated. Instead of depending on a big library, we wrote three methods; 15 lines of code in total. Obviously, there are many things you can&apos;t do with this: for example, you can&apos;t easily keep a reference to a specific constraint and change the <code>constant</code> property. That&apos;s fine, we can keep using the regular Auto Layout API for this.
							</p>
							<p>
								There are a few obvious extensions that are left as an exercise:
							</p>
							<ul>
								<li>
									<p>
										Add a way to constrain an anchor to a constant (instead of another anchor and a constant)
									</p>
								</li>
								<li>
									<p>
										Add a way to constrain to a different view than the parent (e.g. the content view of a <code>UIVisualEffectView</code>)
									</p>
								</li>
							</ul>
							<p>
								Thanks to Florian Kugler for helping me simplify the code a lot. We also made a <a href="https://talk.objc.io/episodes/S01E75-auto-layout-with-key-paths" title>Swift Talk</a> episode about the code above, check it out.
							</p>
						</section>
						<footer class="group" id="post-meta">
							<div>
								<span>Posted on 
									<span><time>Oct 27, 2017</time>
										 by 
										<a href="http://www.twitter.com/chriseidhof/">@chriseidhof</a></span></span>
							</div>
						</footer>
					</article>
					<footer class="group promo" id="post-meta">
						<div>
							<img src="/images/advanced-swift.png" style="width: 90px;"/>
						</div>
						<p>
							<p>
								If you liked this article, check out our book <a href="https://www.objc.io/books/advanced-swift/" title>Advanced Swift</a>, or check out <a href="https://talk.objc.io" title>Swift Talk</a>.
							</p>
						</p>
					</footer>
					<footer>
						<nav id="post-nav">
							<span class="prev"><a href="/post/swift-analytics"><span class="arrow">←</span>
									Swift Analytics</a></span>
							<span class="next"><a href="/post/references">Struct References
									<span class="arrow">→</span></a></span>
						</nav>
					</footer>
				</section>
			</section>
		</section>
	</body>
</html>