<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Chris Eidhof</title>
		<description>
			Personal Blog
		</description>
		<link>http://chris.eidhof.nl</link>
		<atom:link href="http://chris.eidhof.nl/feed.xml" rel="self" type="application/rss+xml"/>
		<item>
			<title>Weeknotes № 3</title>
			<description>
				&lt;p&gt;
	Last week was really busy, but in a relatively balanced way. We got fresh snow and spent a bunch of time pulling sledges. I also ran every single day of the week, without problems (92km in total). One more week until my 12-week marathon preparation starts. This week I’m hoping to do the same but with a bit more volume. I went to two local meetings (one for the day care and one town-wide gathering). We also went to a demonstration with the whole family yesterday, as I think it’s important that we all become a bit more tolerant and open for diversity.
&lt;/p&gt;
&lt;p&gt;
	Together with Nicholas (the designer) I made a lot of progress on the new SwiftUI explanations website. I think we’re getting to a point where it’s almost ready to make it public. My goal is to have this out before the end February. There are still a few design issues that need to be solved and a bunch of content that needs to be written, but it’s all really starting to come together now. I hope to make a list of everything that needs to be done before launch within the next few days.
&lt;/p&gt;
&lt;p&gt;
	I also started to prepare two in-person workshops in Germany that’ll happen within the next months. I’m really looking forward to the in-person part, as it’s been quite a while since I last did that.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 22 Jan 2024 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2024-03</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2024-03</guid>
		</item>
		<item>
			<title>Weeknotes № 2</title>
			<description>
				&lt;p&gt;
	The persistent cough I’ve had for weeks is finally getting better. I started running again (small steps). Originally, I wanted to start my marathon preparation a few weeks ago, but I had to postpone to get healthy again first. This means I can’t do a 16-week prep as usual, so I’ll do a 12-week version. While it won’t get me in the shape I want yet, it’s definitely going to be a good place to then build from.
&lt;/p&gt;
&lt;p&gt;
	We spent a day preparing for Swift Talk episodes, and I spent the rest of the week working on the new project (explaining SwiftUI in the browser). I made some really good progress: I separated updating views from laying views out, I added initial support for animations and transitions and implemented matched geometry effect. Some of the explanations we’re hoping to achieve are way better with animations, and this seemed like the easiest way to achieve that.
&lt;/p&gt;
&lt;p&gt;
	I also incorporated a new company. Or to be more precise: I took the first steps to being incorporated, as this process is quite elaborate in Germany, involving multiple in-person meetings. While the existing company I run with Florian is going to stay around, this new project will run under the new company.
&lt;/p&gt;
&lt;p&gt;
	Finally, I did a few smaller home improvement projects. For the first time, I worked with aluminum. It was pretty basic: just cutting stuff and drilling holes. The only tricky bit is that I wanted to tap threads, but that didn’t really work out the way I wanted (three of the holes ended up great, but on one of them I made a mistake and the bolts wouldn’t grip in the threads. I kind of want to learn to weld as well, but I’ve read that welding aluminum is pretty tricky.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 15 Jan 2024 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2024-02</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2024-02</guid>
		</item>
		<item>
			<title>Weeknotes № 1</title>
			<description>
				&lt;p&gt;
	Last week the kids were still at home, so my week was mostly filled with care tasks.
&lt;/p&gt;
&lt;p&gt;
	I had officially started my marathon plan on Dec 18th, and while the first day or two went great, I then got a pretty intense cough which is still not completely gone. I only managed to put in a few runs. Last week, I only ran once. I was planning to prepare well for a late April marathon, but that’s not possible anymore (I could still run if I can get in some decent training, but not at the level I was hoping for).
&lt;/p&gt;
&lt;p&gt;
	I did make a bunch of progress on the layout explanation website. I now have fully working HStack explanations (visualizations that explain the internals of how an HStack lays out its children). While we’re still working on the design, the basic case is now visualized really well.
&lt;/p&gt;
&lt;p&gt;
	I’m still enjoying TypeScript. While I prefer Swift, it’s nice to have integrated Copilot support. The other day I pasted in a Swift snippet that I wrote a while ago and started translating it line-by-line, and Copilot did most of that work. I don’t really trust it generating more than one line (or more than I can immediately parse in my head), but when I’m on the train with no internet connection, I do miss it.
&lt;/p&gt;
&lt;p&gt;
	TypeScript’s structural types are both great and annoying. I miss Swift’s enums, which you have to simulate through tagged unions. The thing I miss the most is value semantics: in TypeScript (which is just types on top of Javascript), everything is an object, and almost everything is passed by reference. I’ve definitely seen my share of “spooky action at a distance”, where a value would all of a sudden change underneath me. As the code base matures, I’m adding more and more &lt;code&gt;clone&lt;/code&gt; or &lt;code&gt;copy&lt;/code&gt; methods to my types (giving me a new instance of an object with the same properties).
&lt;/p&gt;
			</description>
			<pubDate>Mon, 08 Jan 2024 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2024-01</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2024-01</guid>
		</item>
		<item>
			<title>SwiftUI Binding Tips</title>
			<description>
				&lt;p&gt;
	When working with bindings in SwiftUI, it can be useful to modify bindings. For example, in a Slack I’m part of, someone had a binding to a Boolean and wanted to negate it. This was (roughly) the code they had:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension Binding where Value == Bool {
    func toggled() -&amp;gt; Self {
        Self(
            get: {
                !wrappedValue
            },
            set: { newValue in
                wrappedValue = !newValue
            }
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	While the code works great, it always feels a bit cumbersome to write. There’s a simpler way to achieve this. We can start by creating a computed property on &lt;code&gt;Bool&lt;/code&gt; that’s both &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension Bool {
    var flipped: Self {
        get { !self }
        set { self = !newValue }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Because &lt;code&gt;Binding&lt;/code&gt; supports dynamic member lookup, we can use our &lt;code&gt;flipped&lt;/code&gt; property directly where we use our binding:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;$myBinding.flipped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We’ve also used this pattern sometimes when projecting into a binding. For example, let’s imagine we want to display a control that enables us to select edges. Our state looks like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;@State private var edges: Set&amp;lt;Edge&amp;gt; = [Edge.top, Edge.bottom]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	If we want to enable and disable a specific edge through a &lt;code&gt;Toggle&lt;/code&gt;, we’ll need to turn the binding from a &lt;code&gt;Set&amp;lt;Edge&amp;gt;&lt;/code&gt; into a &lt;code&gt;Bool&lt;/code&gt; binding. We can again achieve this using dynamic member lookup, but this time through a subscript:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension Set {
    subscript(contains el: Element) -&amp;gt; Bool {
        get { contains(el) }
        set {
            if newValue {
                insert(el)
            } else {
                remove(el)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Now we can write &lt;code&gt;$edges[contains: .top]&lt;/code&gt; or &lt;code&gt;$edges[contains: .bottom]&lt;/code&gt; and get a &lt;code&gt;Bool&lt;/code&gt; binding out. The reason why we need a &lt;code&gt;subscript&lt;/code&gt; is that dynamic member lookup uses key paths, and both subscripts and computed properties can be part of key paths. A regular method cannot be part of a key path. While the technique is a little obscure, I still find it easier to read than writing all that logic inside a custom binding.
&lt;/p&gt;
&lt;p&gt;
	In general, I much prefer components that take a &lt;code&gt;Binding&lt;/code&gt; over components that observe all kinds of complicated view models, global stores or other things. They are easier to test and reuse and don’t require complicated architectures. Hopefully the two tricks above help you turn the bindings that you have into the bindings that you need.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 07 Jan 2024 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/swiftui-binding-tricks</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/swiftui-binding-tricks</guid>
		</item>
		<item>
			<title>Weeknotes № 51-52</title>
			<description>
				&lt;p&gt;
	In between Christmas and New Years I’ve been slowly making progress on my layout explanations website. Nicholas (the designer) has been putting out different possible designs, and I’ve been trying to implement some of it (both in SwiftUI as well as in my web port).
&lt;/p&gt;
&lt;p&gt;
	I also spent a few days trying to figure out what happens when SwiftUI performs animations. I learned a few things:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			When you start an animation for a property while another animation for that property is already running, the results of these two animations get combined. The combined animation will always have the duration of the new animation. Also, at the end of the (new) animation, the value will be the result of the new animation. In between, these two values get interpolated. I’m hoping to write up some of my experiments soon.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			When you create multiple transactions (e.g. change one property, animate a change to a second property and then change another property) in one go (e.g. in a button action) these cause SwiftUI to reevaluate the body multiple times (once per transaction). This is necessary to figure out which views should be animated and which should update immediately.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	My goal is to understand animations so well that I can reimplement them without problems. I’m planning to also port the animation system to the web, so that I can use them for my visualizations in the layout explanations. Hopefully, at a later point, I can also use that to explain how animations work.
&lt;/p&gt;
&lt;p&gt;
	Depending on when you’re reading this: happy new year!
&lt;/p&gt;
			</description>
			<pubDate>Sun, 31 Dec 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-52</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-52</guid>
		</item>
		<item>
			<title>Weeknotes № 49-50</title>
			<description>
				&lt;p&gt;
	We recorded some Swift Talk episodes about tweakable values. We also continued implementing the new design for our website (and Swift Talk). It’s still not finished, hopefully soon.
&lt;/p&gt;
&lt;p&gt;
	I also spent a bunch of time on my SwiftUI layout explanation site. It’s not so easy to figure out the right visualizations, but I think we’re making progress there. I also want to have some animations in there, which means I’m going to attempt to clone SwiftUI’s animation system. I’ve reimplemented (parts of) the layout system a few times, but have never tried doing the animation system. I think the main challenge will be to make sure additive animations work as expected. I’m not too worried about performance — it’s something that should work correctly in a real implementation, but for my purposes, I only want to be able to animate a few views at the time.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 18 Dec 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-50</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-50</guid>
		</item>
		<item>
			<title>Weeknotes № 48</title>
			<description>
				&lt;p&gt;
	We held two workshops last week, one in PT and one in ET. This meant staying up (quite) late for five days in a row. It always takes some getting used to. But the advantage is that I had lots of daylight time to do other stuff.
&lt;/p&gt;
&lt;p&gt;
	I built a large wooden horse for my daughter. I finally took the time to set up my basement workshop (beyond the essentials). Got my dust collection going, which makes a massive difference (without dust collection, it isn’t much fun to spend longer than a few minutes there).
&lt;/p&gt;
&lt;p&gt;
	After a chat with my friend I moved my SwiftUI in the browser project over to next.js. This took a few days (during which the code didn’t compile). I feel a bit out of my depth in the entire modern web ecosystem, but I’ll manage. The nice thing is that now I can wrap up my functionality in React components, which is definitely an improvement over doing everything by hand.
&lt;/p&gt;
&lt;p&gt;
	I started slightly ramping up my running mileage and am hoping to start another 18-week marathon preparation in about a week from now. This should get me in shape for an April marathon. While it’s not realistic yet to train for a PB (I need a longer and more intensive buildup for that) I think I could aim for a second-best time. It depends a bit on how the next months go, training-wise.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 04 Dec 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-48</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-48</guid>
		</item>
		<item>
			<title>Weeknotes № 46-47</title>
			<description>
				&lt;p&gt;
	Here are the combined weeknotes for the last two weeks.
&lt;/p&gt;
&lt;p&gt;
	I visited my friend in London and met up with a bunch of friends. The NSLondon folks were nice enough to organize a drinks night, was great to see many old and new friends. London feels almost like the opposite of where we live (both in good and bad ways). One of my highlights was zipping through the streets in the dark rush hour on a rental E-bike (while being used to driving on the other side of the road). Felt dangerous but lots of fun.
&lt;/p&gt;
&lt;p&gt;
	I made more progress on the SwiftUI web port. I’m starting to write out explanations of modifiers and views. I think in a few weeks we can start on the design work as well. I think I’d like to do the HTML/CSS myself for this one. While I did do lots of front-end web development years ago, I feel quite out of touch with modern front-end development. There are so many new things! I like a lot of it, but the one thing I’m trying to avoid for as long as I can is all those dependencies (bundlers, npm packages, etc.).
&lt;/p&gt;
&lt;p&gt;
	We finished preparing two workshops (one in EST, one in PST, both in a single week). We also started some working on implementing the redesign of objc.io. This has been “ready” (that is, implemented in HTML/CSS) for over half a year, but we hadn’t gotten around to actually integrating it into our main website. So far, we only spent a day on this, but already made considerable progress.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 27 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-47</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-47</guid>
		</item>
		<item>
			<title>Weeknotes № 44</title>
			<description>
				&lt;p&gt;
	The first half of last week I was still away, so nothing much happened.
&lt;/p&gt;
&lt;p&gt;
	The second half of the week we started preparing two more workshops. We prepare each workshop specifically for the company we teach, so it’s always quite a bit of work. We believe it’s useful for the company we work with (as they work on problems directly related to their day-to-day work). Oftentimes, we also learn something ourselves.
&lt;/p&gt;
&lt;p&gt;
	In the odd hour I had available I worked on improving the SwiftUI layout port to the web. I think I’ve got enough of the SwiftUI part implemented, now it’s time to see how we can use this to create better explanations.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 06 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-44</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-44</guid>
		</item>
		<item>
			<title>Weeknotes № 45</title>
			<description>
				&lt;p&gt;
	On Monday I was excited to finally have a regular week of work again without any travel or other big things. Little did I know. On Monday we all got really sick. It knocked the whole family out for multiple days.
&lt;/p&gt;
&lt;p&gt;
	In the end, I did get a few days of solid work in last week. After finishing the projects we’ll build for our workshops, we split those up into individual exercises and write all the descriptions. We’ve gotten a lot more efficient at this, but it still takes a few iterations per workshop, even now.
&lt;/p&gt;
&lt;p&gt;
	I also went and cleaned up a little bit of the Workshop app (our Mac app that the attendees use). I added a few small features. For example, all examples have live previews, I added support for better resizing that feels more native on the Mac. We have “fake” simulators in the app that show the solution in context, and I improved some of our fake iOS components (e.g. our simulation of a navigation view).
&lt;/p&gt;
&lt;p&gt;
	In the evenings I kept tinkering with my web port of SwiftUI’s layout. Text layout now behaves almost exactly as SwiftUI’s Text view (which is based on CTFrameSetter). I added support for dark mode, and support to visualize a view’s origin and size. I added variables that allow you to change values in the source code by dragging them (similar to Bret Victor’s demos). There are so many more possibilities, but of course, my goal is for the end result to be very simple. So far TypeScript has really delivered on its promise, I feel confident making both small and large refactorings and having the type checker guide me through it.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 06 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-45</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-45</guid>
		</item>
		<item>
			<title>Weeknotes № 43</title>
			<description>
				&lt;p&gt;
	I think a lot of Apple’s documentation could be improved. For example, I think SwiftUI’s layout system could be explained in a much better way. We try to do so in our workshops and books, but I think interactive explanations on a public website would be even better. A few years ago we reimplemented large parts of SwiftUI’s layout system in Swift. I started porting this to Javascript.
&lt;/p&gt;
&lt;p&gt;
	While in The Netherlands, I also met up with my friends from university. We had a very close-knit group of students during our Master’s and ended up all going super deep on Haskell and functional programming. When everyone at the table immediately recommended I switch to TypeScript I took their word for it. The switch was &lt;em&gt;so&lt;/em&gt;
	 worth it.
&lt;/p&gt;
&lt;p&gt;
	I installed the TypeScript compiler and VS Code. I also (based on my friends’ recommendations) enabled copilot and had such an incredibly productive time. I don’t have to worry too much about my implementation’s performance or feature-completeness, as the goal is to only use this for teaching. I just focus on adding the subset of views that I want to explain and make sure they behave in exactly the same way as the real SwiftUI does. Luckily, we have already done most of the hard work in Swift, I only need to port it. I currently have stacks, frames, shapes, padding, background/overlay, images, geometry readers and a basic version of text working.
&lt;/p&gt;
&lt;p&gt;
	There are a bunch of things missing before we can release this in some form. It needs better pretty printing (generating the code from the views), tracing (so that we can show the layout process), design (the surrounding explanations need to have at least some kind of design that goes beyond the browser’s default Times font).
&lt;/p&gt;
			</description>
			<pubDate>Mon, 30 Oct 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-43</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-43</guid>
		</item>
		<item>
			<title>Weeknotes № 42</title>
			<description>
				&lt;p&gt;
	Still on my time off. We’re away in a holiday park, so I’m keeping the laptop mostly shut. I’ve done a tiny bit of work at the beginning of the week, hopefully I can share some of that soon. Mainly writing this post as to not break the streak.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 23 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-42</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-42</guid>
		</item>
		<item>
			<title>Weeknotes № 41</title>
			<description>
				&lt;p&gt;
	As a short break from my time off, we ran a workshop last week. I also took the opportunity to finally (after we moved in a few months ago) get my desk set up. I switched the saw horses for my standing desk base, added cable management and brought out all the gear I use when running a workshop: proper lighting, DSLR mount, HDMI converter, and so on. (It turned out my micro HDMI cable broke and I had to use my phone as a camera instead).
&lt;/p&gt;
&lt;p&gt;
	Because we ran the workshop in PST, we had to stay up quite late (I’m an early riser and not much of an evening person by default). A few days before these PST workshops I’ll start by adjusting my rhythm. The hardest part for me is sleeping in — even though I’m tired, I can’t help but wake up early. The other weird thing is my energy level throughout the day: I’m typically very awake early in the morning and get progressively more tired during the day. This kind of felt the other way around.
&lt;/p&gt;
&lt;p&gt;
	During the workshop, one of the attendees mentioned that it was nice to actually work on getting a very simple view to be pixel-perfect. In their own app, they often blame things on the complexity of their app, whereas here it’s just a few small components and there’s no hiding behind complexity. It also made me feel that, as iOS developers writing SwiftUI, any time invested in understanding SwiftUI is very well spent. We’ll probably be using this framework every single day for the next ten years or longer, any investment we make now will probably pay off many times over.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 16 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-41</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-41</guid>
		</item>
		<item>
			<title>Weeknotes № 40</title>
			<description>
				&lt;p&gt;
	I’m taking some time off this month to focus on the family and get the final home improvement bits done before winter is here. I am working on some small side-projects and we will run a workshop this week.
&lt;/p&gt;
&lt;p&gt;
	One of the things I experimented with is a generic programming library. This allows you to view your structs and enums as sums of products, and makes it relatively easy to write algorithms that operate on the structure of these types. For example, I’ve written a binary encoder/decoder, a method that generates a simple SwiftUI view for a type, a method that generates an editor (form) for a type, and a bunch more. I’m currently trying a few different approaches and am planning to blog a bit more about this soon. If you’re interested, &lt;a href=&quot;https://github.com/chriseidhof/generic-programming-tests&quot;&gt;here’s a repo&lt;/a&gt; with some of my experiments.
&lt;/p&gt;
&lt;p&gt;
	In the typing recorder project that I wrote about in previous weeknotes, I started with a simple enum-based model layer. I was too lazy to make my model values &lt;code&gt;Identifiable&lt;/code&gt; but just had an array of enum values with the array index as the identifier. As always, this came back to haunt me. I finally changed my representation to include a stable identifier. This would have been much less work if I had done it from the beginning.
&lt;/p&gt;
&lt;p&gt;
	I went for a quick dip in the lake after my long run on Sunday — it’s doable, but far from comfortable. Part of me wants to keep doing that, but I’m not sure how long I’ll last this year.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 09 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-40</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-40</guid>
		</item>
		<item>
			<title>Weeknotes № 39</title>
			<description>
				&lt;p&gt;
	We shipped &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt; last week! It’s now available in PDF and print. We’re very happy with the result (and open for suggestions, of course).
&lt;/p&gt;
&lt;p&gt;
	One thing that’s currently missing which we might add (depending on how hard it is) is an ePub version. Without having implemented it, it’s a bit hard to predict how much work this is. I’m sure we can get an 80% solution in a few days, but actually shipping it will definitely be harder.
&lt;/p&gt;
&lt;p&gt;
	My typing recording app is seeing some good progress. I’ve been bitten once again by the fact that I prototyped something without making my model values conform to &lt;code&gt;Identifiable&lt;/code&gt;. I stored them in an array and just used the array index as the identity. This works fine for a while, but will always come back to haunt you.
&lt;/p&gt;
&lt;p&gt;
	We’ve also been busy with preparing new workshops. We updated the content in our workshop app to reflect what we learned from writing the book, and are also preparing some client-specific exercises.
&lt;/p&gt;
&lt;p&gt;
	At home, we started some work on renovating the exterior walls. Big holes were cut to allow for new windows and larger windows. We had to reinsulate some parts, add corner rails for the plastering, and all kinds of other small jobs I’d never done before. In the end, none of it is very hard, but it all takes a while to figure out. The hardest part for me is that I don’t know how to do things the right way, both at a theoretical level (what insulation or products do I use) and at a practical level (how do I make sure this is attached correctly). YouTube can help a lot but is no replacement for actual experience and expertise.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 02 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-39</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-39</guid>
		</item>
		<item>
			<title>Weeknotes № 38</title>
			<description>
				&lt;p&gt;
	Last week we recorded a bunch of episodes around building a small marquee component. We wanted to make it interactive (similar to a scroll view) which makes the underlying implementation a bit different from how you would normally write SwiftUI components. The animations are driven by a &lt;code&gt;TimelineView&lt;/code&gt; so we can also easily do some math around the gesture velocity.
&lt;/p&gt;
&lt;p&gt;
	We also got our proof copy of the print book, so close to release now. We made a few final adjustments to this as well.
&lt;/p&gt;
&lt;p&gt;
	In the evenings I spent some more time on my recording app. I hope to use it for a presentation next week (not sure yet if the presentation will happen). My goal is to make it very easy for me to make these kind of interactive text animations so that I can easily prototype and ship high-quality code animations. I’m currently mostly just trying to get that recording workflow perfect.
&lt;/p&gt;
&lt;p&gt;
	I swam a bunch more, also with a wetsuit (it’s not necessary yet, just to try what it’s like). I feel like my fear of open-water swimming is definitely getting a lot less. As always, one of the best ways to deal with fear is confronting it, which is definitely working in this case.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 25 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-38</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-38</guid>
		</item>
		<item>
			<title>Weeknotes № 37</title>
			<description>
				&lt;p&gt;
	Last week we finalized the layout for Thinking in SwiftUI. Now we need to check the (print) proof copy and verify everything is okay before we can finally release it! I also spent some more time on my typing recorder app, it’s really starting to take shape. Hopefully I can demo it soon.
&lt;/p&gt;
&lt;p&gt;
	I spent another day working on better understanding and analyzing what’s happening with &lt;code&gt;UIViewRepresentable&lt;/code&gt; and state, and typed these notes up into &lt;a href=&quot;http://chris.eidhof.nl/post/view-representable&quot;&gt;a blog post&lt;/a&gt;. After some initial confusion around processing multiple events (both from people who read it as well as myself) I also added some more explanations and diagrams to that post. Being able to quickly embed SwiftUI views in posts is starting to pay off, it’s almost no extra work. I’d like to look into how to do layout with view representables as well. Not sure yet how to tackle that and what use cases exist, but we’ll find out!
&lt;/p&gt;
&lt;p&gt;
	I also ran a race on Saturday which was pretty tough! After about half a minute I was in second position and it stayed that way throughout the race. I lost contact with the winner very quickly. Even throughout the half-way point he just kept on increasing the lead which ultimately was a little bit demotivating. I still enjoyed the running, I just wasn’t motivated to really push hard.
&lt;/p&gt;
&lt;p&gt;
	After the race there was a nice clear lake to swim in (a five minute walk from the finish line). Yesterday, I swam with a friend (so much more fun than swimming alone). We swam across our local lake and back, making it my farthest swim yet.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 18 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-37</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-37</guid>
		</item>
		<item>
			<title>Working With UIViewRepresentable</title>
			<description>
				&lt;p&gt;
	When we work with SwiftUI, we can always drop down to UIKit level by using &lt;code&gt;UIViewRepresentable&lt;/code&gt;, &lt;code&gt;NSViewRepresentable&lt;/code&gt; or &lt;code&gt;UIViewControllerRepresentable&lt;/code&gt;. The documentation around these protocols is still pretty sparse, and it can be hard to get them to work exactly the way we want. I tried to come up with some rules and patterns for using them. These patterns are &lt;em&gt;not&lt;/em&gt;
	 final, if you have feedback about missing things or mistakes, please let me know.
&lt;/p&gt;
&lt;p&gt;
	There are a few different challenges. In this article, I want to focus on communicating state between SwiftUI and UIKit/AppKit. Communication can happen in either direction: we’ll need to update our &lt;code&gt;UIView&lt;/code&gt; when SwiftUI’s state changes, and we’ll need to update our SwiftUI state based on UIView changes.
&lt;/p&gt;
&lt;p&gt;
	Here are two rules for working with representables. (&lt;a href=&quot;https://www.cocoawithlove.com&quot;&gt;Matt&lt;/a&gt; helped me with this, thank you):
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			When updating a UIView in response to a SwiftUI state change, we need to go over all the representable’s properties, but only change the UIView properties that need it.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			When updating SwiftUI in response to a UIKit change, we need to make sure these updates happen asynchronously.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	If we don’t follow these rules, there are a few issues we might see:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			The dreaded “Modifying state during view update, this will cause undefined behavior” warning
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Unnecessary redraws of our &lt;code&gt;UIViewRepresentable&lt;/code&gt;, or even infinite loops
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Strange behavior where the state and the view are a little bit out of sync
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	In my testing, these issues are becoming less relevant with UIKit, but are very relevant when dealing with AppKit. My guess is that UIKit components have seen some internal changes to make writing view representables simpler. However, as we’ll see, this isn’t the case for every UIKit view.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Building a MapView wrapper&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	MapKit’s &lt;code&gt;Map&lt;/code&gt; view for SwiftUI used to be very limited, and a popular target for wrapping in a representable. As of iOS 17 it gained a lot of new capabilities, but we’ll still use it as our first example.
&lt;/p&gt;
&lt;p&gt;
	We’ll be writing a simple wrapper that takes a binding to the map view’s center coordinate. As a first step, we’ll create an &lt;code&gt;MKMapView&lt;/code&gt; and set the delegate to be our coordinator.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct HybridMap: UIViewRepresentable {
    @Binding var position: CLLocationCoordinate2D

    // ...

    func makeUIView(context: Context) -&amp;gt; MKMapView {
        let view = MKMapView()
        view.delegate = context.coordinator
        view.preferredConfiguration = MKHybridMapConfiguration()
        return view
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	For the coordinator, there is a nice technique to pass in all properties of &lt;code&gt;HybridMap&lt;/code&gt; directly (this is especially useful when we have more than one property). You can simply pass a copy of &lt;code&gt;self&lt;/code&gt;, as &lt;code&gt;HybridMap&lt;/code&gt; is a struct:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;// ...
class Coordinator: NSObject, MKMapViewDelegate {
    var parent: HybridMap
    init(parent: HybridMap) {
        self.parent = parent
    }

    func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
        parent.position = mapView.centerCoordinate
    }
}

func makeCoordinator() -&amp;gt; Coordinator {
    Coordinator(parent: self)
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Finally, here’s our &lt;code&gt;updateUIView&lt;/code&gt; method:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    context.coordinator.parent = self
    view.centerCoordinate = position
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can now create a simple view with a state property for the position:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let initialPosition = CLLocationCoordinate2D(latitude: 52.518611, longitude: 13.408333)

struct ContentView: View {
    @State private var position = initialPosition

    var body: some View {
        VStack {
            Text(&amp;quot;\(position.latitude) \(position.longitude)&amp;quot;)
            Button(&amp;quot;Reset Position&amp;quot;) { position = initialPosition }
            HybridMap(position: $position)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we launch the above app, we’ll immediately get a runtime warning: “Modifying state during view update, this will cause undefined behavior.”. To debug this, we can add print statements to the beginning and ending of both our &lt;code&gt;updateUIView&lt;/code&gt; as well as &lt;code&gt;mapViewDidChangeVisibleRegion&lt;/code&gt; methods:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    print(&amp;quot;Begin updateUIView&amp;quot;, position)
    defer { print(&amp;quot;End updateUIView&amp;quot;) }
    context.coordinator.parent = self
    view.centerCoordinate = position
}
// ...
func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
    print(&amp;quot;Begin didChange&amp;quot;, mapView.centerCoordinate)
    defer { print(&amp;quot;End didChange&amp;quot;) }
    parent.position = mapView.centerCoordinate
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we launch the app, we get the following print statements:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Begin updateUIView CLLocationCoordinate2D(latitude: 52.518611, longitude: 13.408333)
End updateUIView
Begin didChange CLLocationCoordinate2D(latitude: 51.117027, longitude: 10.333652000000006)
End didChange
Begin didChange CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
End didChange
Begin updateUIView CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
Begin didChange CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
[SwiftUI] Modifying state during view update, this will cause undefined behavior.
End didChange
End updateUIView
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Here’s what happens: first, the view is rendered and put on screen. After that, the &lt;code&gt;didChange&lt;/code&gt; runs. We can see that map views don’t store their center coordinate directly, my guess is that they only store the visible region as their source of truth. This is why the values in the print statements are different from our initial value. Towards the end, we see that a &lt;code&gt;didChange&lt;/code&gt; runs from within our &lt;code&gt;updateUIView&lt;/code&gt; method, updating our SwiftUI state. This causes the “Modifying state” error.
&lt;/p&gt;
&lt;p&gt;
	As far as I know, the only reliable way I know of to get rid of this warning is by doing this state change asynchronously. The simplest way is by enqueueing another block on the main queue:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
    DispatchQueue.main.async {
        self.parent.position = mapView.centerCoordinate
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This makes the runtime warning go away. However, we can’t drag the map anymore, after a single drag movement it halts. There is one more step left to make this representable work:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    context.coordinator.parent = self
    if view.centerCoordinate != position {
        view.centerCoordinate = position
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	By only doing the view update when necessary we’re not triggering another &lt;code&gt;didChange&lt;/code&gt;. Both of these changes are specific instances of the rules at the beginning of the article:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			We need to change our SwiftUI state asynchronously in response to UIKit changes.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We need to only update properties of UIKit views when absolutely necessary
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Building a Text View wrapper&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	As a second example, we’ll build an &lt;code&gt;NSTextView&lt;/code&gt; wrapper. My goal is to write a &lt;code&gt;MyTextView&lt;/code&gt; component that takes a binding for both the text and the selected range. This is for the Mac, so we’ll be using &lt;code&gt;NSView&lt;/code&gt; instead of &lt;code&gt;UIView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	Here’s the (broken) initial version, with a structure very similar to our map view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyTextView: NSViewRepresentable {
    @Binding var text: String
    @Binding var selection: NSRange

    final class Coordinator: NSObject, NSTextViewDelegate {
        var parent: MyTextView
        unowned var textView: NSTextView!
        init(parent: MyTextView) {
            self.parent = parent
        }

        func textDidChange(_ notification: Notification) {
            self.parent.text = textView.string
        }

        func textViewDidChangeSelection(_ notification: Notification) {
            self.parent.selection = textView.selectedRange()
        }
    }

    func makeCoordinator() -&amp;gt; Coordinator {
        Coordinator(parent: self)
    }

    func makeNSView(context: Context) -&amp;gt; NSTextView {
        let t = NSTextView()
        context.coordinator.textView = t
        t.delegate = context.coordinator
        return t
    }

    func updateNSView(_ t: NSTextView, context: Context) {
        t.textStorage?.setAttributedString(text.highlight())
        t.selectedRanges = [.init(range: selection)]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we run the example above, we can see that we get the dreaded “Modifying state during view update, this will cause undefined behavior” warning. This happens because when we set the attributed string from within &lt;code&gt;updateNSView&lt;/code&gt;, the text view will fire a &lt;code&gt;textViewDidChangeSelection&lt;/code&gt; notification. This notification isn’t posted asynchronously, but actually does happen during the &lt;code&gt;updateNSView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updating SwiftUI in Response to an NSView Change&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	Similar to the map view, we can now wrap our update by enqueueing it on the main queue:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func textViewDidChangeSelection(_ notification: Notification) {
    let r = self.textView.selectedRange()
    DispatchQueue.main.async {
        self.parent.selection = r
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Unfortunately, things are still broken: we don’t get a runtime warning anymore, but the cursor behaves weirdly. (The insertion point is rendered at the start of the current selection whenever the length of the selection is zero).
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updating an NSView in Response to a SwiftUI State Change&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	In principle, this is simple. Whenever something changes, SwiftUI will call &lt;code&gt;updateNSView(:context:)&lt;/code&gt;. However, we don’t know &lt;em&gt;what&lt;/em&gt;
	 changed, it could be any number of properties. In the above implementation, we simply set the two properties, but that’s not enough.
&lt;/p&gt;
&lt;p&gt;
	In our update method, we should take care to inspect each property, but only set the corresponding &lt;code&gt;NSView&lt;/code&gt; value if it’s really necessary. For example:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateNSView(_ t: NSTextView, context: Context) {
    context.coordinator.parent = self
    if t.string != text {
        t.textStorage?.setAttributedString(text.highlight())
    }
    if t.selectedRange() != selection {
        t.selectedRanges = [.init(range: selection)]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This solves almost all our problems. However, there is still a weird issue. When I’m typing at the end of the text field, some characters get inserted just before the last character, instead of at the end.
&lt;/p&gt;
&lt;p&gt;
	Here’s what happens (bear with me):
&lt;/p&gt;
&lt;p&gt;
	When I type a character at the end of the string, the selection changes. A &lt;code&gt;self.parent.setSelection…&lt;/code&gt; is enqueued. The main queue now looks like this:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/1-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/1.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Before that runs, however, the text is updated, and &lt;code&gt;updateNSView&lt;/code&gt; happens. It will set the attributed string, which in turn causes the selection to change, which adds another &lt;code&gt;setSelection&lt;/code&gt; to the queue (with the old selection value). The main queue now looks like this:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/3-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/3.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	The main queue then runs the first (correct) block to set the selection, and then the second (incorrect) block.
&lt;/p&gt;
&lt;p&gt;
	To keep the order of events correct, this means we also have to enqueue the changing of our text. That way, all events will happen in the order we expect:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func textDidChange(_ notification: Notification) {
    let str = textView.string
    DispatchQueue.main.async {
        self.parent.text = str
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This is tricky to find and tricky to debug. A simple rule of thumb would be that once we start enqueueing one change asynchronously, we probably need to do all of the other updates asynchronously as well.
&lt;/p&gt;
&lt;p&gt;
	Now, when the user types a character, the following happens. First, the selection event is enqueued:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/5-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/5.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Then, the text setting event is enqueued:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/7-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/7.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	The main queue is a first-in, first-out serial queue. During the next iteration of the run loop, the first block runs while the other is still in the queue:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/9-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/9.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Because the &lt;code&gt;setSelection&lt;/code&gt; changes the internal SwiftUI view, the view is marked as needing to redraw. This causes the &lt;code&gt;updateView&lt;/code&gt; to be enqueued:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/11-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/11.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	After the &lt;code&gt;setSelection&lt;/code&gt; block is done, the &lt;code&gt;setText&lt;/code&gt; is removed from the queue:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/13-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/13.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	This &lt;code&gt;setText&lt;/code&gt; also wants the view to redraw. However, because the view is already flagged as “dirty” by the &lt;code&gt;setSelection&lt;/code&gt; block, no further block will be enqueued. So after &lt;code&gt;setText&lt;/code&gt; runs, the queue looks like this:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/15-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/15.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Then the &lt;code&gt;updateView&lt;/code&gt; runs and because we have the if-conditions in our method, no further changes will happen. So in practice, even though we enqueued multiple blocks asynchronously, these got coalesced into a single &lt;code&gt;updateView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More Issues and Gotchas&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	As mentioned, we need to check each property in &lt;code&gt;updateNSView(:context:)&lt;/code&gt; and make sure to only update the &lt;code&gt;NSView&lt;/code&gt; when it’s really needed. This relies on us being able to compare values.  Sometimes this isn’t possible. For example, when dealing with the map view, we saw that the center coordinate conversion is lossy. In the cases where we can’t read out the current value, we can cache each value that we set. Inside our coordinator, we could add a helper like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;private var previousValues: [String: Any] = [:]
func setIfNeeded&amp;lt;Value: Equatable&amp;gt;(value: Value, name: String, update: (NSTextView) -&amp;gt; ()) {
    if let previous = previousValues[name] as? Value, previous == value {
        return
    }
    previousValues[name] = value
    update(textView)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we set the new value, we first check whether or not we’ve previously set this value. Only if it’s different, we proceed to update the underlying platform view. In a way, this is similar to SwiftUI’s &lt;code&gt;onChange(of:)&lt;/code&gt; modifier (only run the closure when something changed).
&lt;/p&gt;
&lt;p&gt;
	Similarly, when we want to start animations in SwiftUI, we’ll need to have some kind of state, and our coordinator needs to track when that state changes and only start a new animation then. You could use a method similar to &lt;code&gt;setIfNeeded&lt;/code&gt; to achieve this.
&lt;/p&gt;
&lt;p&gt;
	Sometimes, we want to communicate events back from an NSView to SwiftUI. If the event modifies a value, we could simply modify the corresponding binding. For example, if the event would be &lt;code&gt;scrollViewDidScroll&lt;/code&gt;, we can change the &lt;code&gt;scrollPosition&lt;/code&gt; binding. However, for other events it’s more appropriate to just call a closure (this is what &lt;code&gt;Button&lt;/code&gt; does each time the user taps). Of course, this closure could have parameters as well.
&lt;/p&gt;
&lt;p&gt;
	I’m sure there are many more issues when doing this in practice, if you have any feedback or comments I’d love to hear about it.
&lt;/p&gt;
&lt;p&gt;
	If you want to learn more about SwiftUI, check out our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updates&lt;/strong&gt;
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			After some discussion on Mastodon (and some research) I added a section on multiple events (which includes the main queue diagrams).
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
			</description>
			<pubDate>Wed, 13 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/view-representable</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/view-representable</guid>
		</item>
		<item>
			<title>Weeknotes № 36</title>
			<description>
				&lt;p&gt;
	It feels like last week was the last warm week of summer, and so as a family, we took advantage of that every afternoon and went swimming in one of the lakes nearby. Our new house is a short walk to one of those lakes, and one of my dreams since we moved here half a year ago was swimming across the lake. I’ve been swimming all my life, but never any long distances or with good technique.
&lt;/p&gt;
&lt;p&gt;
	On Wednesday I saw the calm water, hot sun and no boats so I decided on a whim that this was the day. Armed with goggles and a tow float I decided to swim across. The unknown of it was pretty scary for me (which did give me a nice speed boost). It’s a large lake, there are boats, I might cramp up or unknown other stuff might happen. In the end, it took less than ten minutes to swim across. After only two minutes my elastic watch strap came loose, so I had to change to breast stroke until I figured out I could just shove my watch all the way up to my elbow. Those ten minutes felt a lot longer than normal!
&lt;/p&gt;
&lt;p&gt;
	I swam across another time a few days later (in eight minutes), wearing a cap as well (for visibility). My last swimming lesson was thirty years ago, and the freestyle part I never learned was that, most of the time, your face is below the surface. You basically only tilt your head out of the water a bit to get in some fresh air and then continue, looking down towards the bottom. For some reason this is pretty scary to me as well, even more so in a very clear lake. But after a few more “longer” swims I’m starting to get used to it. Next season, I’d love to build up to really long swims, maybe crossing the lake length-wise.
&lt;/p&gt;
&lt;p&gt;
	Florian was away last week, I worked on the “typing recorder” app that I plan to use to record myself typing and play back in a smooth way (for presentations, workshops and videos). As part of this, I needed to do another &lt;code&gt;NSViewRepresentable&lt;/code&gt; implementation for &lt;code&gt;NSTextField&lt;/code&gt;. I had yet another one of these “Modifying state during view update” runtime warnings and decided it was time to fully understand these. I’ve written down a bunch of notes already that I hope to turn into a blog post soon.
&lt;/p&gt;
&lt;p&gt;
	We finalized the copy editing for &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;, &lt;a href=&quot;http://www.natalye.com&quot;&gt;Natalye&lt;/a&gt; went through the last bunch of edits so now it’s time to typeset everything. We’ll need to do this once for print and once for the PDF version.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 11 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-36</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-36</guid>
		</item>
		<item>
			<title>Weeknotes № 35</title>
			<description>
				&lt;p&gt;
	We finally recorded the final bits of our &lt;a href=&quot;https://talk.objc.io/episodes/S01E366-building-keyframe-animations-part-1&quot;&gt;keyframe reimplementation&lt;/a&gt;, including a Catmull-Rom implementation that turned out to be extremely simple and matches exactly what SwiftUI does. I’ve used our reimplementation in a macOS 13 app successfully.
&lt;/p&gt;
&lt;p&gt;
	We also went over the entire &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;book&lt;/a&gt; and made it ready for a final copy-editing pass. The next steps after that is to do a little bit of typesetting for the PDF version and possible a bit more for the printed version. Then we can release it!
&lt;/p&gt;
&lt;p&gt;
	I’ve been playing around with a new project that lets me record me typing code and then replay it in a smoother and animated way. This should be useful for making videos and when giving presentations (in SwiftUI).
&lt;/p&gt;
&lt;p&gt;
	Last week, &lt;a href=&quot;https://www.swiftconf.to&quot;&gt;Swift TO&lt;/a&gt; released the videos of all the presentations. I created an annotated version of my presentation &lt;a href=&quot;http://chris.eidhof.nl/presentations/day-in-the-life&quot;&gt;A Day in the Life of a SwiftUI View&lt;/a&gt;. This definitely took a few hours here and there, but hopefully it’s useful to those of you that don’t want to or can’t watch videos.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 04 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-35</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-35</guid>
		</item>
	</channel>
</rss>