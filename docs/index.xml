<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Chris Eidhof</title>
		<description>
			Personal Blog
		</description>
		<link>http://chris.eidhof.nl</link>
		<atom:link href="http://chris.eidhof.nl/feed.xml" rel="self" type="application/rss+xml"/>
		<item>
			<title>Weeknotes #5</title>
			<description>
				&lt;p&gt;
	During the first three days of this week we ran a workshop in PST. This was actually a two-day workshop, split into three days because of the timezone difference. I’m an early riser by nature, and staying up until midnight isn’t really my strength. While it’s pretty easy during the workshop as we are constantly either helping people work through exercises or explaining things, I did have to take some extra rest the day after.
&lt;/p&gt;
&lt;p&gt;
	It is always kind of nice to start working at 6pm, as the day before is very long. I do find it hard to relax before work, my natural mode is to do all the things I need to do before early afternoon. I didn’t manage to really do nothing, so instead I spent a lot of time doing things around the new house, sorting out things in our current house.
&lt;/p&gt;
&lt;p&gt;
	The house renovation has been pretty stressful for me, as there are so many dependencies and things going on that I don’t have a clue about. I think we mostly have been pretty lucky with the contractors. I also learned so much during the build, doing plastering, building drywalls, bricklaying, and so on. It’s a lot of fun but stressful. Luckily there’s a very clear end in sight.
&lt;/p&gt;
&lt;p&gt;
	To me, having built and helped with many parts of our house gives the house a lot of “personal quality”. In our current house, I designed and built a very simple kitchen completely from scratch. Any store bought kitchen is probably better, but for me personally, having built the kitchen all by myself brings me much more satisfaction than the nicest store bought kitchen could ever give me. Of course, my wife doesn’t agree and so we bought a proper kitchen for the new house.
&lt;/p&gt;
&lt;p&gt;
	Since the birth of our second daughter (and the house renovation) I cut down my running a lot. Instead of running twice a day most days, now I’m not even running every day. I’m not sure what I’ll do with that once we’ve moved. Part of me wants to get back into the groove of high mileage marathon training, and part of me wants to have more breadth: running, cycling, swimming, canoeing are all activities that we have the perfect surroundings for.
&lt;/p&gt;
&lt;p&gt;
	Last week we started working on a different kind of server-side library (it’s super small, actually) that will look familiar if you have used SwiftUI. The big advantage is that the SwiftUI style of building views (or endpoints, or static site pages, or…) allows you to automatically inject the environment without any effort on the side of the framework user. For server-side pages, this would often contain the current session, the database connection (or an abstraction), and possibly a bunch of other stuff. We have currently solved this in our Swift Talk using &lt;a href=&quot;https://talk.objc.io/episodes/S01E141-functional-dependencies&quot;&gt;a reader pattern&lt;/a&gt;, but the SwiftUI way is much nicer to use.
&lt;/p&gt;
&lt;p&gt;
	I didn’t cook many fancy things, but I did make bagels. Last time, my bagels turned out to be really tasty but didn’t look right. This time around, the bagels looked perfect but were a bit bland. I’ll try again this weekend.
&lt;/p&gt;
			</description>
			<pubDate>Fri, 03 Feb 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-05</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-05</guid>
		</item>
		<item>
			<title>Variadic Views</title>
			<description>
				&lt;p&gt;
	This week’s post about how the SwiftUI view protocol &lt;a href=&quot;http://chris.eidhof.nl/post/swiftui-views-are-lists/&quot;&gt;really represents lists&lt;/a&gt; stirred a bit of controversy on Mastodon. But I think we all learned a bit from the discussion that followed (I definitely did).
&lt;/p&gt;
&lt;p&gt;
	To deal with these lists of views (e.g. during layout) we can use the underscored variadic view API. I learned about variadic views through the &lt;a href=&quot;http://movingparts.io/variadic-views-in-swiftui&quot;&gt;Moving Parts&lt;/a&gt; blog. I don’t know whether this API is going to change in the future, whether it’s App-Store-proof, and so on. It’s probably underscored for a good reason. With that out of the way, let’s get started!
&lt;/p&gt;
&lt;p&gt;
	First, I wanted to get a way to iterate over the view list and turn them into views. This code is a bit weird, but we only need to write it once. To get access to the view list, we need to construct a type that conforms to &lt;code&gt;_VariadicView_MultiViewRoot&lt;/code&gt;
&lt;sup&gt;&lt;a href=&quot;#fnref1&quot; name=&quot;fnref-rev1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
. The only requirement we need to implement is the &lt;code&gt;body&lt;/code&gt; method. We can provide that using a closure:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct Helper&amp;lt;Result: View&amp;gt;: _VariadicView_MultiViewRoot {
    var _body: (_VariadicView.Children) -&amp;gt; Result

    func body(children: _VariadicView.Children) -&amp;gt; some View {
        _body(children)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The &lt;code&gt;_VariadicView.Children&lt;/code&gt; type is a random access collection we can loop over. The elements conform to &lt;code&gt;Identifiable&lt;/code&gt; and &lt;code&gt;View&lt;/code&gt;. In addition, we can access the &lt;em&gt;traits&lt;/em&gt;
	 of the elements (more about this later).
&lt;/p&gt;
&lt;p&gt;
	To use our &lt;code&gt;Helper&lt;/code&gt; above, we can provide an extension on &lt;code&gt;View&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension View {
    func variadic&amp;lt;R: View&amp;gt;(@ViewBuilder process: @escaping (_VariadicView.Children) -&amp;gt; R) -&amp;gt; some View {
        _VariadicView.Tree(Helper(_body: process), content: { self })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Again, the code above is pretty obscure but we only need to write it once. Before we start using this, let’s create a list of views:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;@ViewBuilder var subviews: some View {
    Rectangle()
        .frame(width: 30, height: 30)
    ForEach(0..&amp;lt;3) { ix in
        Text(&amp;quot;Hello \(ix)&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The above view builder defines a list containing four views: a rectangle and three text labels. We can use these in a container view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;HStack { subviews }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/variadic-views/1-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/variadic-views/1.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Using our &lt;code&gt;variadic&lt;/code&gt; method, we can write more helper methods. For example, we could intersperse views in between the elements:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension View {
    @ViewBuilder
    func intersperse&amp;lt;V: View&amp;gt;(@ViewBuilder _ divider: () -&amp;gt; V) -&amp;gt; some View {
        let el = divider()
        variadic { children in
            if let c = children.first {
                c
                ForEach(children.dropFirst(1)) { child in
                    el
                    child
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This lets us create an &lt;code&gt;HStack&lt;/code&gt; with dividers in between the elements:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;HStack {
    subviews.intersperse {
        Divider().fixedSize()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/variadic-views/3-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/variadic-views/3.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	We can also write a more low-level abstraction like &lt;code&gt;reduce&lt;/code&gt; (which unfortunately requires &lt;code&gt;AnyView&lt;/code&gt;):
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension View {
    func reduce&amp;lt;R: View&amp;gt;(@ViewBuilder _ combine: @escaping (AnyView, AnyView) -&amp;gt; R) -&amp;gt; some View {
        variadic { children in
            if let c = children.first {
                children.dropFirst(1).reduce(AnyView(c), { l, r in
                    AnyView(combine(l, AnyView(r)))
                })
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We could use this to render the list of views in reverse order, with circles in between for good measure:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;HStack {
    subviews.reduce { view1, view2 in
        view2
        Circle().frame(width: 5, height: 5)
        view1
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/variadic-views/5-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/variadic-views/5.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Variadic views are also very useful when you want to write reusable components that take a list of views with different types. For example, you could write your own picker that has an interface like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct Sample: View {
    @State private var selection: Int? = 0

    var body: some View {
        MyPicker(selection: $selection) {
            Text(&amp;quot;One&amp;quot;).myTag(1)
            Image(systemName: &amp;quot;doc&amp;quot;).myTag(2)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	To implement this, we’ll use traits and variadic views. The tags are stored as traits. These are similar to preferences, but don’t bubble up as high. For example, they won’t bubble up out of a container view.
&lt;/p&gt;
&lt;p&gt;
	Here’s the helper to tag views:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;fileprivate struct MyTag: _ViewTraitKey {
    static var defaultValue: AnyHashable? = Optional&amp;lt;Int&amp;gt;.none
}

extension View {
    func myTag&amp;lt;Value: Hashable&amp;gt;(_ value: Value) -&amp;gt; some View {
        _trait(MyTag.self, value)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	In our picker, we loop over all the views and put them in an &lt;code&gt;HStack&lt;/code&gt;. We add a tap gesture to make the items tappable. We use the custom tag to check whether the item is selected. Except for the variadics and tags, the code is straightforward SwiftUI:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyPicker&amp;lt;Selection: Hashable, Content: View&amp;gt;: View {
    @Binding var selection: Selection?
    @ViewBuilder var content: Content

    var body: some View {
        HStack {
            content.variadic { children in
                ForEach(children) { child in
                    let tag: Selection? = child[MyTag.self].flatMap { $0 as? Selection }
                    let selected = tag == selection
                    child
                        .onTapGesture {
                            selection = tag
                        }
                        .padding(.bottom, 5)
                        .overlay(alignment: .bottom) {
                            if selected {
                                Color.accentColor
                                    .frame(height: 1)
                            }
                        }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	I think variadic views are essential if we want to write components that mimic the first-party components. They’re useful for small things (intersperse) and bigger things (components that want to be flexible about the types of the child views).
&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
	&lt;hr/&gt;
	&lt;ol&gt;
		&lt;li id=&quot;fnref1&quot;&gt;
			&lt;p&gt;
				You can find more information about this by spelunking into the &lt;code&gt;.swiftinterface&lt;/code&gt; file that SwiftUI provides. Using your Terminal, go to /Applications/Xcode.app, type &lt;code&gt;find . -name &amp;quot;SwiftUI.swiftmodule&amp;quot;&lt;/code&gt; and go to that folder. Inside you’ll find &lt;code&gt;.swiftinterface&lt;/code&gt; files which contain &lt;em&gt;a lot&lt;/em&gt;
				 of interesting things.
				 &lt;a href=&quot;#fnref-rev1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
			</description>
			<pubDate>Fri, 27 Jan 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/variadic-views</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/variadic-views</guid>
		</item>
		<item>
			<title>Weeknotes #4</title>
			<description>
				&lt;p&gt;
	While Florian was away the first few days this week to hold a workshop, I prepared some more things for next week’s workshop. During the workshop, we use an internal Mac app to present things to the attendees. For example, we show layout trees, render trees and have an interactive alignment visualization. Some of these only worked well in dark mode, and I fixed that. I used a combination of &lt;code&gt;.background(.background)&lt;/code&gt; to set the background to the current background style, as well as &lt;code&gt;.backgroundStyle(colorScheme == .light ? …)&lt;/code&gt; to set the current background style.
&lt;/p&gt;
&lt;p&gt;
	In the workshop app that our attendees receive, I also added interactive render tree examples:
&lt;/p&gt;
&lt;picture&gt;
   &lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/images/workshop-app-dark.png 2x&quot;&gt;
   &lt;img srcset=&quot;http://chris.eidhof.nl/images/workshop-app.png 2x&quot; style=&quot;width: auto;&quot;&gt;
&lt;/picture&gt;

&lt;p&gt;
	In our alignment demos, I used &lt;a href=&quot;https://www.fivestars.blog/articles/reverse-masks-how-to/&quot;&gt;&lt;code&gt;.reversedMask&lt;/code&gt;&lt;/a&gt; to obscure parts of a view. You can see this in the screenshot below: the alignment guides are continuous lines with the text (+ padding) cut out:
&lt;/p&gt;
&lt;picture&gt;
   &lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/images/alignment-screenshot-dark.png 2x&quot;&gt;
   &lt;img srcset=&quot;http://chris.eidhof.nl/images/alignment-screenshot.png 2x&quot; style=&quot;width: auto;&quot;&gt;
&lt;/picture&gt;

&lt;p&gt;
	In recent years, I only wrote up to three posts a year, this week I wrote three posts (including this one). First, I wrote about how &lt;a href=&quot;http://chris.eidhof.nl/post/swiftui-views-are-lists&quot;&gt;SwiftUI views are lists&lt;/a&gt; and about &lt;a href=&quot;http://chris.eidhof.nl/post/variadic-views/&quot;&gt;Variadic Views&lt;/a&gt;. The variadic view posts includes rendered SwiftUI views that are automatically generated at compile time of this blog. The images automatically switch between light mode and dark mode (similar to the screenshots in this post).
&lt;/p&gt;
&lt;p&gt;
	At home, I made two of my favorite left over recipes: we used left over pasta sauce for empanada filling. Also, we used left over risotto and made a small batch of air fried mozarella arancinis.
&lt;/p&gt;
			</description>
			<pubDate>Fri, 27 Jan 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-04</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-04</guid>
		</item>
		<item>
			<title>SwiftUI Views are Lists</title>
			<description>
				&lt;p&gt;
	When you write SwiftUI, all your views conform to the &lt;code&gt;View&lt;/code&gt; protocol. The name of this protocol is a bit misleading: I it could be called &lt;code&gt;Views&lt;/code&gt; or &lt;code&gt;ViewList&lt;/code&gt;, or something else that suggests plurals
&lt;sup&gt;&lt;a href=&quot;#fnrefdiscussion&quot; name=&quot;fnref-revdiscussion&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
.
&lt;/p&gt;
&lt;p&gt;
	For example, consider the following view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyView: View {
     var body: some View {
         Text(&amp;quot;Hello&amp;quot;)
         Text(&amp;quot;World&amp;quot;)
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The type of &lt;code&gt;body&lt;/code&gt; is &lt;code&gt;some View&lt;/code&gt; (an opaque type), and &lt;code&gt;MyView&lt;/code&gt; itself conforms to the &lt;code&gt;View&lt;/code&gt; protocol. So how does the above view render? &lt;em&gt;It depends&lt;/em&gt;
	. When you create an &lt;code&gt;HStack&lt;/code&gt; containing &lt;code&gt;MyView&lt;/code&gt;, the text will be on a single line, but when you create a &lt;code&gt;VStack&lt;/code&gt; the two texts will be below each other. Try this!
&lt;/p&gt;
&lt;p&gt;
	This is not a gimmick: it is essential to how SwiftUI works. When we write views, we’re always constructing &lt;em&gt;lists of views&lt;/em&gt;
	. For example, we could even do something like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyOtherView: View {
    var body: some View {
        Text(&amp;quot;Another Text&amp;quot;)
        MyView()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	You can create a &lt;code&gt;VStack&lt;/code&gt; with &lt;code&gt;MyOtherView&lt;/code&gt;, and will see the three views below each other, and when you create an &lt;code&gt;HStack&lt;/code&gt; they’re laid out on a single line.
&lt;/p&gt;
&lt;p&gt;
	In general, we can say that anything that conforms to the &lt;code&gt;View&lt;/code&gt; protocol really represents a list of &lt;code&gt;View&lt;/code&gt;s. In the case of &lt;code&gt;MyOtherView&lt;/code&gt;, we could say the list has a single &lt;code&gt;Text&lt;/code&gt; view and another list (&lt;code&gt;MyView&lt;/code&gt;). These lists get flattened. In the case of &lt;code&gt;MyOtherView&lt;/code&gt;, the &lt;code&gt;body&lt;/code&gt; flattens down to a list containing three views.
&lt;/p&gt;
&lt;p&gt;
	Container views such as &lt;code&gt;HStack&lt;/code&gt; and &lt;code&gt;VStack&lt;/code&gt; take these lists, iterate over them and lay them out. Using the &lt;code&gt;Layout&lt;/code&gt; protocol, you can also see these flattened lists. For example, you could construct your own &lt;code&gt;Layout&lt;/code&gt; implementation to print the number of subviews:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyLayout: Layout {
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -&amp;gt; CGSize {
        .zero
    }

    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        print(subviews.count)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When you have a &lt;code&gt;MyLayout { MyOtherView() }&lt;/code&gt; you’ll see that it will always print 3.
&lt;/p&gt;
&lt;p&gt;
	To create lists with a dynamic size, you can use conditionals such as &lt;code&gt;if&lt;/code&gt;. Note that constructs like &lt;code&gt;ForEach&lt;/code&gt; produce a list as well. These can even be combined with other lists. For example, the code below creates a vertical stack with eight children:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt; VStack {
     MyOtherView()
     ForEach(0..&amp;lt;5) {
         Text(&amp;quot;Label \($0)&amp;quot;)
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	As mentioned, the &lt;code&gt;Layout&lt;/code&gt; protocol lets you work with these view lists directly as of iOS 16 and macOS 13. You can also use &lt;a href=&quot;https://movingparts.io/variadic-views-in-swiftui&quot;&gt;variadic views&lt;/a&gt; — a non-public, but stable API — to loop over view lists. The variadic view API is really powerful (for example, you can write things like &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; on view lists) but also quite low-level. I have a gist &lt;a href=&quot;https://gist.github.com/chriseidhof/5ff6ef8786f5635c18b20304ab9d9b01&quot;&gt;here&lt;/a&gt; with some examples, and plan to also write this up soon
&lt;sup&gt;&lt;a href=&quot;#fnrefvariadics&quot; name=&quot;fnref-revvariadics&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
.
&lt;/p&gt;
&lt;blockquote&gt;
	&lt;p&gt;
		This article was inspired by the section that Florian wrote for our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui&quot;&gt;Thinking in SwiftUI&lt;/a&gt;. We’re currently rewriting the book and hope to get it out soon.
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;footnotes&quot;&gt;
	&lt;hr/&gt;
	&lt;ol&gt;
		&lt;li id=&quot;fnrefdiscussion&quot;&gt;
			&lt;p&gt;
				Not everyone agrees with this, the &lt;a href=&quot;https://m.objc.io/@chris/109751198846392579&quot;&gt;discussion on Mastodon&lt;/a&gt; was quite interesting.
				 &lt;a href=&quot;#fnref-revdiscussion&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
		&lt;li id=&quot;fnrefvariadics&quot;&gt;
			&lt;p&gt;
				I did write this up, and &lt;a href=&quot;http://chris.eidhof.nl/post/variadic-views&quot;&gt;the post is here&lt;/a&gt;.
				 &lt;a href=&quot;#fnref-revvariadics&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
			</description>
			<pubDate>Wed, 25 Jan 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/swiftui-views-are-lists</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/swiftui-views-are-lists</guid>
		</item>
		<item>
			<title>Weeknotes #3</title>
			<description>
				&lt;p&gt;
	After a super busy week last week, I took things a bit easier, especially on the house renovation part. Lots of family time instead!
&lt;/p&gt;
&lt;p&gt;
	Work-wise, I started the week by improving the README for our &lt;a href=&quot;https://github.com/objcio/attributed-string-builder&quot;&gt;attributed string builder&lt;/a&gt; project, and also added support for &lt;a href=&quot;https://github.com/objcio/attributed-string-builder/blob/main/Sources/Tests/Environment.swift&quot;&gt;custom environment keys&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	I worked on adding alignment to the &lt;a href=&quot;https://talk.objc.io/episodes/S01E308-the-layout-protocol&quot;&gt;flow layout&lt;/a&gt; we built on Swift Talk. This turned out to be quite tricky: while the code isn’t that hard to write, writing it without duplication was already quite a bit harder and took a few tries. Then I tried to refactor it and use &lt;code&gt;HStack&lt;/code&gt; to layout the rows, but I learned the hard way that &lt;code&gt;Layout&lt;/code&gt;s in SwiftUI aren’t very composable. For example, I can’t seem to get the individual frames out of an existing layout. In any case, I am writing up my experience, both in the form of a blog post and as part of our book update.
&lt;/p&gt;
&lt;p&gt;
	The second half of the week we spent finishing up the details for an upcoming workshop. As we prepare each workshop individually to tailor it to the team, this always takes a lot of time. However, the end product is something we’re always really proud of.
&lt;/p&gt;
&lt;p&gt;
	I really enjoyed this essay about &lt;a href=&quot;https://buttondown.email/hillelwayne/archive/use-the-wrong-tool-for-the-job/&quot;&gt;using the wrong tool for the job&lt;/a&gt;. I always struggled a bit to explain why we like to use Swift for almost everything, despite other languages being more fit for the job. The link explains this extremely well, much better than I could articulate myself. In short, there’s a massive gain for us when we do write things in Swift, because we know the ecosystem and don’t have to learn other tools, even though some problems are better solved using different languages.
&lt;/p&gt;
			</description>
			<pubDate>Fri, 20 Jan 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-03</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-03</guid>
		</item>
		<item>
			<title>Weeknotes #2</title>
			<description>
				&lt;p&gt;
	At the end of last week, we recorded some &lt;a href=&quot;https://talk.objc.io&quot;&gt;Swift Talk&lt;/a&gt; episodes that build up our new &lt;a href=&quot;https://github.com/objcio/attributed-string-builder&quot;&gt;attributed string builder&lt;/a&gt; library. This project allows you to build up an attributed string using result builders, from a number of different sources. For example, you can write Markdown, plain strings, use NSImages or even embed SwiftUI views, all combining into a single attributed string with uniform styling.
&lt;/p&gt;
&lt;p&gt;
	We plan to use this as the basis for laying out our books. These are mainly written in Markdown, but we want to be able to intersperse the Markdown with SwiftUI views (rendered as vector graphics), other images, and we’d like to have some more layout possibilities. For example, we’d like to have multiple columns for some parts, call-out boxes, tables, and so on. Being able to “drop down” to custom attributed strings allows us to do this while still mainly having our text in Markdown.
&lt;/p&gt;
&lt;p&gt;
	I also added support to this blog to render images of inline SwiftUI views inside my posts, although I’m not using that feature yet. Hopefully soon!
&lt;/p&gt;
&lt;p&gt;
	We rewrote the start of the &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui&quot;&gt;Thinking in SwiftUI&lt;/a&gt; chapter on view trees. In essence, one of the big insights we had is to start out with describing how view builders construct lists of views, and how almost everything in SwiftUI is a list of (lists of) views. When you have a value that conforms to the &lt;code&gt;View&lt;/code&gt; protocol, it’s always a list of views — it being a single view is the exception. We also worked a bit on explaining the two roles of &lt;code&gt;@State&lt;/code&gt; in SwiftUI: it’s used to both initialize a state property as well as update it (and these are two very different things!). Finally, we started a rewrite of the Advanced Layout chapter (covering the &lt;code&gt;Layout&lt;/code&gt; protocol, preferences, and geometry readers)
&lt;/p&gt;
&lt;p&gt;
	I used &lt;a href=&quot;http://nushell.sh&quot;&gt;Nushell&lt;/a&gt; for the first time. I saw this in Mastodon a while ago and had it installed. I used it to read a JSON file containing all of our episode metadata, projected only the title and synopsis for each episode, and wrote them to a CSV in reverse order. The code was easy to write and is easy to read. I can totally see myself use this shell every once in a while for odd jobs:
&lt;/p&gt;
&lt;blockquote&gt;
	&lt;p&gt;
		open episodes.json | select title synopsis | reverse | to csv
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
	This week, we again prepared and recorded a few episodes about attributed strings, and put &lt;a href=&quot;https://github.com/objcio/attributed-string-builder&quot;&gt;the code&lt;/a&gt; on GitHub. We also have some more things we’d like to add (table support) and possibly some extras we could do in a separate package (e.g. syntax highlighting, as this pulls in a bunch of dependencies that most people might not need). Currently, the package is only designed to work on Mac and works with TextKit, not sure whether we’ll have bigger ambitions at some point. We would like to add a nice readme and some samples.
&lt;/p&gt;
&lt;p&gt;
	In our new house, I continued renovating and helping out the professionals where I could. I spent a day cleaning the entire construction site, did some final demo, spent two afternoons helping out with the drywall for the bathroom, and a day helping out with bricklaying (even laying some bits myself). We needed to get a bit more done this week, which of course came at the expense of family time. Luckily, busy weeks like this are the absolute exception. (I really enjoy renovating, but lots and lots of family time is more important to me.)
&lt;/p&gt;
&lt;p&gt;
	I continued my fermenting process, last week’s ginger bug was ready and bubbling, so I used it to start making a big batch of ginger beer. I also started mead and made overnight bagels (turned out great and the family loved them).
&lt;/p&gt;
&lt;p&gt;
	I’m reading &lt;a href=&quot;https://www.amazon.com/dp/1469266822&quot;&gt;Crucial Conversations&lt;/a&gt; in the evenings, which is very interesting to me. I’m not sure if I’ll be able to apply the ideas without having a lot of practice, only time will tell.
&lt;/p&gt;
			</description>
			<pubDate>Fri, 13 Jan 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-02</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-02</guid>
		</item>
		<item>
			<title>Weeknotes #1</title>
			<description>
				&lt;p&gt;
	I’d like to write more this year, so here’s an attempt at a proven format that’s new to me: a weekly log of the stuff I’ve worked on. New year, new format!
&lt;/p&gt;
&lt;p&gt;
	I started the week continuing to work on the update to our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;. We’ve basically rewritten it from scratch. We chose to do this not only because we understand SwiftUI better, but also because we learned so much through the workshops we’ve been organizing over the last few years. Working with small groups we get a lot of direct feedback and questions, and that has improved our explanations a lot.
&lt;/p&gt;
&lt;p&gt;
	Our current publishing setup generates two PDFs (one for screen, one for print) and an ePub. We input our own extended Markdown, convert this using a bunch of homegrown tooling, then generate Markdown as the output. This gets read by Pandoc, turned into LaTeX and finally into PDFs and ePub. The setup is a brittle, large, has many dependencies, takes a long time and is hard to debug or finetune for us.
&lt;/p&gt;
&lt;p&gt;
	Instead, we are now experimenting with generating attributed strings and rendering those using TextKit. This is much faster (less than a second versus minutes) and gives us a lot more control (we’re good at Swift and not good at LaTeX). This week, I worked on adding footnotes, roughly laying things out, highlighting code and adding figures and diagrams that are automatically generated using SwiftUI (&lt;a href=&quot;https://m.objc.io/@chris/109621086933102165&quot;&gt;here’s an example&lt;/a&gt;). To construct the attributed strings we came up with a result builder that lets us build them from different sources (Markdown, plain strings, SwiftUI, highlighted code, etc.). We’ll probably make some episodes about this or open-source this
&lt;sup&gt;&lt;a href=&quot;#fnref†&quot; name=&quot;fnref-rev†&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
.
&lt;/p&gt;
&lt;p&gt;
	I also worked on turning some of our interactive demos from the workshop into non-interactive diagrams for our book. &lt;a href=&quot;https://twitter.com/objcio/status/1494635294133522433&quot;&gt;Here’s an old version&lt;/a&gt; of one of those diagrams. We’ll probably turn this into a tree with numbers at the vertices and explanations in the text.
&lt;/p&gt;
&lt;p&gt;
	I read a bit about the &lt;a href=&quot;https://gist.github.com/DougGregor/4f3ba5f4eadac474ae62eae836328b71&quot;&gt;new macro system in Swift&lt;/a&gt;. Very interesting stuff, but as of yet I understand very little about it. I’ll definitely look into this in more detail sometime soon.
&lt;/p&gt;
&lt;p&gt;
	I have only logged into Twitter maybe once this week, and basically moved to Mastodon. There’s a lot less activity, but also much less noise. I like it there.
&lt;/p&gt;
&lt;p&gt;
	At home, I had fun building a simple marble track out of scrap wood with the 4yo. In the house we’re renovating, I took down a wall and now we’re erecting a new wall (with a much larger door opening).
&lt;/p&gt;
&lt;p&gt;
	Over the holidays I made a ginger bug (which started to foam), but the ginger soda I tried making from it didn’t start carbonating. I’m not sure if it’s turning into vinegar or alcohol now, but it doesn’t taste right. To get better at fermentation, I bought &lt;a href=&quot;https://www.wildfermentation.com/the-art-of-fermentation/&quot;&gt;The Art of Fermentation&lt;/a&gt;. I haven’t read too much yet, but at least the book is very well designed and I love the typography.
&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
	&lt;hr/&gt;
	&lt;ol&gt;
		&lt;li id=&quot;fnref†&quot;&gt;
			&lt;p&gt;
				&lt;strong&gt;Update&lt;/strong&gt;
				 we just released the &lt;a href=&quot;https://talk.objc.io/episodes/S01E337-attributed-string-builder-part-1&quot;&gt;first episode&lt;/a&gt; about this
				 &lt;a href=&quot;#fnref-rev†&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
			</description>
			<pubDate>Thu, 05 Jan 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-01</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-01</guid>
		</item>
		<item>
			<title>Lifetime of State Properties in SwiftUI</title>
			<description>
				&lt;p&gt;
	This post is a look inside how (a small part of) SwiftUI works. I’m mainly writing this as part of my extended memory, so that I can go back to it and read about how it works. We’re currently in the process of updating our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt; and figuring out some of the obscure behaviors of SwiftUI. While this might not make it into the book (we keep the book concise on purpose) I figured it’s worth writing up.
&lt;/p&gt;
&lt;p&gt;
	One of the challenging parts of SwiftUI is really understanding the way it manages view state (for example, through &lt;code&gt;@State&lt;/code&gt; and &lt;code&gt;@StateObject&lt;/code&gt;). In theory, it’s pretty simple: anytime you want associated view state you just create a property with &lt;code&gt;@State&lt;/code&gt; and you’re done. For example, here’s a simple view with associated state:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct Item: View {
    var id: Int
    @State private var counter = 0
    var body: some View {
        VStack {
            Text(&amp;quot;Item \(id)&amp;quot;)
            Button(&amp;quot;Counter: \(counter)&amp;quot;) {
                counter += 1
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When SwiftUI renders this view, it creates associated storage to hold the value of &lt;code&gt;counter&lt;/code&gt;. As long as the view exists, the memory for &lt;code&gt;counter&lt;/code&gt; is there, and once the view stops existing, the memory is gone.
&lt;/p&gt;
&lt;p&gt;
	However, when you have worked with &lt;code&gt;@State&lt;/code&gt; (or &lt;code&gt;@StateObject&lt;/code&gt;), you will notice that there might be some strange behavior. Sometimes your state disappears, especially when working with a &lt;code&gt;List&lt;/code&gt; (or to be precise: any view that uses &lt;code&gt;ForEach&lt;/code&gt; directly or indirectly).
&lt;/p&gt;
&lt;p&gt;
	To understand this better, we have to ask ourselves an existential question:
&lt;/p&gt;
&lt;blockquote&gt;
	&lt;p&gt;
		What does it mean for a view to exist?
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
	Joking aside, here’s what I think happens:
&lt;/p&gt;
&lt;p&gt;
	When a &lt;code&gt;List&lt;/code&gt; is rendered on screen, it only allocates memory for the children that are directly on screen (on iOS, anyway). We can quickly verify this by initializing a &lt;code&gt;@State&lt;/code&gt; property with a value expression that prints a line:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct StateItemTest: View {
    @State var item: Int = {
        print(&amp;quot;Initing&amp;quot;)
        return 0
    }()
    let body = Text(&amp;quot;Hello&amp;quot;)
}

// Later:
List(0..&amp;lt;1000) { id in
    StateItemTest()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we show the list view, we’ll see a print statement for every row that’s on screen. But these are created lazily: as we scroll down more and more print statements appear. So we have now established at least one thing:
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;List creates its subviews lazily&lt;/em&gt;
	. By the way, this is the same for &lt;code&gt;ForEach&lt;/code&gt; in other lazy contexts. For example, when you put a &lt;code&gt;ForEach&lt;/code&gt; inside a &lt;code&gt;LazyVStack&lt;/code&gt; and that inside a &lt;code&gt;ScrollView&lt;/code&gt;, you get the same effect.
&lt;/p&gt;
&lt;p&gt;
	My next question was: &lt;em&gt;when do these state values get destroyed again?&lt;/em&gt;
	 Is this when we scroll the views out of sight? We can verify this by having a long list of views with modifiable state properties. For example, we can put our &lt;code&gt;Item&lt;/code&gt; view from above inside a long list:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;List(0..&amp;lt;1000) { id in
    Item(id: id)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we run the above list, we can change some state at the top of the list, scroll to the very bottom, and scroll back up. The state will still be there. So we have established another thing:
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The children of a &lt;code&gt;List&lt;/code&gt; will be kept around&lt;/em&gt;
	. The lifetime of a &lt;code&gt;@State&lt;/code&gt;‘s property is directly tied to the lifetime of a view. Once a list child is created, it never goes away again, unless the list goes away itself. (You can verify this by putting the list inside a navigation link and navigating back). Again, this doesn’t just apply to &lt;code&gt;List&lt;/code&gt; but any lazy &lt;code&gt;ForEach&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	However, this behavior puzzled me. I’ve written many SwiftUI lists, and I swear that I have seen state objects go away. What gives? In my case, I’ve seen this behavior when loading a list that contains images for each cell, and the images would get reloaded after scrolling back up.
&lt;/p&gt;
&lt;p&gt;
	It turns out that while the children of a &lt;code&gt;List&lt;/code&gt; will be kept around (including their associated state), the bodies of those views will get destroyed. These will get recreated lazily once the view appears on screen again. If we run the same example as before, but wrap our &lt;code&gt;Item&lt;/code&gt; view in another layer, we’ll see that our state goes away as the view disappears:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct ItemWrapper: View {
    var id: Int
    
    var body: some View {
        ZStack {
            Item(id: id)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This is the behavior in the version of SwiftUI that comes with Xcode 13. The full code is &lt;a href=&quot;https://gist.github.com/chriseidhof/440dbdbe9a5fa21ff5439b5f42582a44&quot;&gt;available as a gist&lt;/a&gt;. The behavior might change in the future, as none of this is documented.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 28 Mar 2022 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/swiftui-state-lifetime</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/swiftui-state-lifetime</guid>
		</item>
		<item>
			<title>2021</title>
			<description>
				&lt;p&gt;
	The year is almost over, so time for a quick recap.
&lt;/p&gt;
&lt;p&gt;
	Work-wise, we started the year by releasing a new app called &lt;a href=&quot;https://www.buildandshipapps.com&quot;&gt;Narrated&lt;/a&gt;. It’s a Mac app to create more personal screen recordings by including your camera. It was really fun to build and ship, but it hasn’t been a success commercially at all by any means. Our goal was to actually get the entire app out within a few months, and we did manage to go from prototype to finished app within about three months.
&lt;/p&gt;
&lt;p&gt;
	At the beginning of the year, we started preparing a &lt;a href=&quot;https://www.objc.io/workshops/swiftui/&quot;&gt;SwiftUI workshop&lt;/a&gt;. We tried to think hard about what parts are difficult to learn, and focus on that. For example: everyone can figure out how to create a button, but hardly anyone actually understands the layout system.
&lt;/p&gt;
&lt;p&gt;
	It’s been incredibly rewarding running these workshops for teams both with and without SwiftUI experience at companies across the globe. At first, I was a bit hesitant about running an online workshop, but it turned out to work really well. I think part of it was preparing better than we ever did before. We have well thought-out exercises that all build on top of each other, as well as a Mac app that describes all the exercises and has a large number of interactive explanations. With each workshop we ran, we were able to iterate on this, improving the exercises, explanations and structure.
&lt;/p&gt;
&lt;p&gt;
	At some point in the first half of the year, we got fed up with our website build system (Middleman/Ruby and some Javascript build systems) that had been in place for (eight?) years. Over the years, it stopped working on more and more of our computers until we only had one machine left that was able to build it. We decided to bite the bullet, and rewrote it in Swift. It only took us a few days to rewrite, and we should be set for the next few years. No more strange gem installs that stop working or npm dependencies that break. As a bonus, our site now builds in 2 seconds rather than multiple minutes (I think it took about 13 minutes on CI). We extract most of the code into a &lt;a href=&quot;https://github.com/objcio/StaticSite&quot;&gt;simple framework&lt;/a&gt;. I also rewrote &lt;a href=&quot;https://github.com/chriseidhof/chriseidhofnl&quot;&gt;this website&lt;/a&gt; with it.
&lt;/p&gt;
&lt;p&gt;
	In the middle of last year we started on a new edition of &lt;a href=&quot;https://www.objc.io/books/advanced-swift/&quot;&gt;Advanced Swift&lt;/a&gt; (we’re hoping to ship it early 2022). We decided to revisit and update every single chapter, as well as adding a new chapter on Swift’s new concurrency system. The new concurrency stuff took us a while to understand, but I’m very impressed by its design. Concurrency is still hard, but this new system definitely helps to boil down concurrent and asynchronous code to its essential complexity, rather than complex code that’s further obfuscated by lots of nested callbacks and/or reactive programming.
&lt;/p&gt;
&lt;p&gt;
	Of course, we also continued Swift Talk. I personally learned a ton &lt;a href=&quot;https://talk.objc.io/collections/swiftui-layout-explained&quot;&gt;reimplementing SwiftUI’s layout system&lt;/a&gt;. We also built a simple &lt;a href=&quot;https://talk.objc.io/collections/swiftui-path-builder&quot;&gt;vector drawing app&lt;/a&gt;, reimplemented &lt;a href=&quot;https://talk.objc.io/episodes/S01E260-matched-geometry-effect-part-3&quot;&gt;matchedGeometryEffect&lt;/a&gt; and SwiftUI’s &lt;a href=&quot;https://talk.objc.io/collections/swiftui-state-explained&quot;&gt;state handling&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	Running-wise, it was a pretty good year. Having two clear running goals (a spring marathon and a fall marathon) gave me purpose and meaning every single day. Even when all races were cancelled, I ran a solo marathon in April in &lt;a href=&quot;https://www.strava.com/activities/5188278197#10959190775&quot;&gt;2:36&lt;/a&gt;. This was a massive PB. In preparation, I also ran PBs on the 10k (33 min) and HM (1:13). In the second half of the year I didn’t run any PBs, but did manage to win a few races. One of the most fun races for me was the Usedom Marathon where I finished in second place. I essentially ran that as a long run at 80% effort (just like the winner, who finished multiple minutes ahead of me). The Berlin marathon result (my main goal for the year) was disappointing for me as I don’t think I got anywhere close to what my training predicted.
&lt;/p&gt;
&lt;p&gt;
	As a family, I think we managed to get through the pandemic relatively well. We leased a plot in a community garden, which helped: we spent a lot of our free time outside doing physical labour and playing. I actually have good hopes for the future, but if anything, we’ll just have to take things as they come.
&lt;/p&gt;
			</description>
			<pubDate>Tue, 28 Dec 2021 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2021</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2021</guid>
		</item>
		<item>
			<title>Dependencies</title>
			<description>
				&lt;p&gt;
	Over the last years, I’ve noticed a change when programming. I used to liberately add third-party dependencies to my code. I would use libraries, or even build on top of frameworks like Ruby on Rails. These days, I tend to use few or no third-party dependencies.
&lt;/p&gt;
&lt;p&gt;
	It’s not that I don’t like third-party code. However, a lot of the projects I’ve worked on have been around for quite a few years — which also means keeping their dependencies up to date. Sometimes the API breaks, sometimes there are security issues, sometimes a dependency is just not maintained anymore, and very often, a dependency somehow stops working when I upgrade my machine.
&lt;/p&gt;
&lt;p&gt;
	I hate dealing with this. My app was working fine, and now I have to debug why Nokogiri does not install, or making sure that my app works with the most recent version of Rails, or seeing one of those Javascript libraries pull in hundreds of additional dependencies. And once I do get everything working again, it turns out one of the dependencies updated itself and doesn’t work with my code anymore.
&lt;/p&gt;
&lt;p&gt;
	A few years ago, we rewrote our &lt;a href=&quot;http://talk.objc.io&quot;&gt;Swift Talk&lt;/a&gt; backend from Ruby on Rails to Swift (&lt;a href=&quot;https://github.com/objcio/swift-talk-backend&quot;&gt;here’s the code&lt;/a&gt;). Our Ruby backend had over 70 gem dependencies. The Swift version has fewer than ten dependencies, only two of which we don’t maintain ourselves (SourceKitten and SwiftNIO). We can always compile this without any problems, even after we haven’t worked on it for a while. (As an aside, rewriting from Ruby to Swift also made everything much faster and way less resource-intensive.)
&lt;/p&gt;
&lt;p&gt;
	A few weeks ago, we also rewrote the code that generates objc.io (a static site) into Swift
&lt;sup&gt;&lt;a href=&quot;#fnref1&quot; name=&quot;fnref-rev1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
. Previously, we used an old version of Middleman with a whole bunch of gems, which themselves come with their &lt;em&gt;own&lt;/em&gt;
	 dependencies. Additionaly, there were git submodules, Bower, NPM and CSS compilation steps. Bit by bit, it stopped building on all but one of our machines, even the Docker version somehow didn’t work anymore.
&lt;/p&gt;
&lt;p&gt;
	At some point, we were tired of it, and wanted to change something on our website. We decided to bite the bullet and just rewrite it in Swift with very few dependencies
&lt;sup&gt;&lt;a href=&quot;#fnref2&quot; name=&quot;fnref-rev2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
. While we might still have issues whenever these dependencies change, at least we’ll probably get type errors and won’t have any silent issues. The rewrite took us only about a week and a half. I expect that, for the next few years, we can just keep updating and expanding our site with minimal effort spent on maintaining dependencies. While were at it, we also ripped out almost all Javascript, keeping only a few essential bits. (As an aside, the Ruby version used to take minutes to generate, whereas the Swift version is done within two seconds).
&lt;/p&gt;
&lt;p&gt;
	There’s a fine line between minimizing dependencies and &lt;a href=&quot;https://en.wikipedia.org/wiki/Not_invented_here&quot;&gt;NIH syndrome&lt;/a&gt;. I’m not sure that our approach is the best way to do things, but I’m really happy that we have full control over our code, and — more importantly — that everything fits into our heads.
&lt;/p&gt;
&lt;p&gt;
	There are many upsides to fewer dependencies: we understand the code, it’s written in our own style, we don’t have to spend time keeping the dependencies up to date, and we can fix any issues ourselves without having to wait for something to be approved. However, there are some downsides as well. For example: our code isn’t as battle-tested as other code out there. (This is why we used cmark rather than our own half-working Markdown parser that only parses an extended subset of Markdown.) Another drawback is that there are some really useful features in existing frameworks that we had to write ourselves. We wanted to have asset hashing, and while this is a single flag in most static site generators, we instead spent a morning implementing this.
&lt;/p&gt;
&lt;p&gt;
	All in all, I do have to say that minimizing dependencies works really well for us. We have done this with a number of projects, and it’s just so nice to be able to just run a project that you’ve left alone for weeks, months or even years, and everything still works.
&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
	&lt;hr/&gt;
	&lt;ol&gt;
		&lt;li id=&quot;fnref1&quot;&gt;
			&lt;p&gt;
				We took a very &lt;em&gt;practical&lt;/em&gt;
				 approach and just wanted to get it done before our holidays. We did pull out some of the code into a library, and this very site is generated using that same code. &lt;a href=&quot;https://github.com/objcio/StaticSite&quot;&gt;Here’s&lt;/a&gt; the library.
				 &lt;a href=&quot;#fnref-rev1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
		&lt;li id=&quot;fnref2&quot;&gt;
			&lt;p&gt;
				To be fair, we did end up depending on &lt;a href=&quot;https://github.com/jpsim/Yams&quot;&gt;Yams&lt;/a&gt;, &lt;a href=&quot;https://github.com/apple/swift-syntax&quot;&gt;SwiftSyntax&lt;/a&gt;, &lt;a href=&quot;https://github.com/robb/Swim&quot;&gt;Swim&lt;/a&gt; and &lt;a href=&quot;https://github.com/jgm/cmark&quot;&gt;cmark&lt;/a&gt;.
				 &lt;a href=&quot;#fnref-rev2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
			</description>
			<pubDate>Tue, 06 Jul 2021 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/fewer-dependencies</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/fewer-dependencies</guid>
		</item>
		<item>
			<title>2019</title>
			<description>
				&lt;p&gt;
	This was my first full year of being a dad (my daughter was born at the end of March in 2018), and to accomodate for that, I did not plan anything big. I focused on spending lots of time with the family, working and running (in that order). Compared to 2018, I got a lot better at spending time at home while doing nothing: I used to feel a bit guilty for not being “productive”, but I do believe just being there and spending time with my daughter is one of the best things I can do for her.
&lt;/p&gt;
&lt;p&gt;
	The best month was September: I took a month off of work (except for maintenance things here and there), and also really drastically &lt;a href=&quot;https://www.calnewport.com/books/digital-minimalism/&quot;&gt;limited social media&lt;/a&gt; (I mainly use Twitter) and other digital entertainment (Youtube, Hacker News, etc.). I still spent an average of 30 minutes on my phone every day, but that mostly consisted of things like Google Maps, Spotify and browsing/reading recipes. The rest of the time I spent running and hanging around with my daughter. I did miss work, after a month, and I was glad to get back to it in October.
&lt;/p&gt;
&lt;p&gt;
	As part of getting adjusted to being a family, we also decided to go on a few trips together: I spoke and gave a workshop in Montreal at &lt;a href=&quot;https://nsnorth.ca/&quot;&gt;NSNorth&lt;/a&gt;, and brought the rest of the family. We learned that flying such a long distance is quite doable, and are glad we did it, but we wouldn’t do it again anytime soon. Instead, in June, we went on a train trip to Vienna, Krakow, and Warsaw, which was lots of fun. My daughter loved crawling around the train and saying hi to all the other passengers.
&lt;/p&gt;
&lt;p&gt;
	As an experiment, I also traveled to Argentina to speak, and combined it with a hiking holiday in Patagonia, together with my brother. Being away from the family for two weeks was hard, but I did have a great time nonetheless. Another lesson learned: I wouldn’t want to travel for that long without the family anytime soon.
&lt;/p&gt;
&lt;p&gt;
	Work-wise, it was a really interesting year, despite not shipping big new things ourselves. SwiftUI came out, and it’s been a lot of fun learning about it. So much fun that we even decided to write a short book about it (the official announcement for this will come soon). For a few weeks in October/November, I spent the weekdays in a holiday apartment a short bike ride away from where we live. With no internet connection and no distractions, I managed to be extremely productive. I would get started at 7:30 in the morning, and leave by 15:00, leaving lots of time for everything that isn’t work.
&lt;/p&gt;
&lt;p&gt;
	I decided to run a higher mileage in 2019. I ran 4386 kilometers (2725 miles), and really enjoyed it. While it didn’t bring immediate results in the Rotterdam marathon, it worked really, really well for the Berlin marathon. I smashed my PB and ran 2:48. Here’s my &lt;a href=&quot;http://chris.eidhof.nl/post/race-report-berlin-marathon/&quot;&gt;race report&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	For 2020, in reverse order, my goal is to run an even higher mileage so I can further improve my marathon PB. I might get injured doing that, but at least I want to give it a real try. Work-wise, we’re writing the new book, and we also really want to ship an app again (Mac, iOS or something hybrid). While we have some ideas about what it’s going to be, we haven’t fully decided yet. Personally, I want to keep spending lots of quality time with the family.
&lt;/p&gt;
&lt;p&gt;
	I plan to do another month (or maybe even longer) without digital entertainment, and also plan to again take a full month off to just be at home. Finally, I’ll fly as little as possible in 2020 (at the very least not for speaking at conferences or going on holidays).
&lt;/p&gt;
			</description>
			<pubDate>Mon, 30 Dec 2019 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2019</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2019</guid>
		</item>
		<item>
			<title>Race Report: Berlin Marathon</title>
			<description>
				&lt;p&gt;
	In 2015, I ran the Berlin Marathon in just under three hours: 2:59:41. It was my fourth attempt at the marathon. Even though I hit the wall at km 34, I had run the first bit fast enough to still make it under three hours. Before the race, I believed I could run under three hours, but actually doing so was a really magical feeling.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/berlin2015.png&quot; title/&gt;&lt;em&gt;Berlin 2015: Still ran 2:59&lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
	In the years after, I kept on training, and kept running marathons about twice a year. Even though I felt I could run under three hours, I never managed again. Sometimes, I had a good excuse: in Seville in 2018 I felt prepared, but it was too hot and I came down with a stomach bug after. I didn’t expect to hit the wall so early, though:
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/seville2018.png&quot; title/&gt;
	&lt;br/&gt;&lt;em&gt;Seville 2018: 3:28&lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
	After four years of decent training, and no personal bests in the marathon, I felt a bit like a &lt;em&gt;Trainingsweltmeister&lt;/em&gt;
	 (literal translation: world champion in training). Even though I would run a PB on the 10k or half marathon every once in a while, I always failed hard at keeping my pace during the marathon, even though I felt prepared most of the times I ran.
&lt;/p&gt;
&lt;p&gt;
	In September 2018, I decided to change things around a bit. First of all, I had read &lt;a href=&quot;https://www.goodreads.com/book/show/363482.Advanced_Marathoning&quot;&gt;Advanced Marathoning&lt;/a&gt; and decided to follow one of their schedules later that year. In the second week of the schedule, there was a 26k run with 13k at marathon pace. Because I still had a few months before the start of the schedule, I started working my way towards that goal (when I started that September, I could barely manage 1 kilometer at my goal marathon pace).
&lt;/p&gt;
&lt;p&gt;
	I really enjoyed running the schedules, even though the mileage was much higher than I normally ran. I only had a few days of being ill, and managed to do my key workouts well (for example, running &lt;a href=&quot;https://www.strava.com/activities/2187511089&quot;&gt;26k with 23k at marathon pace&lt;/a&gt;). I even ran very close to my PB during a local 10k race at the end of the biggest week of training (120k).
&lt;/p&gt;
&lt;p&gt;
	I felt more prepared than every for the 2019 Rotterdam Marathon. There were friends and family along the course, I was excited, and despite being sleep-deprived, I felt like running 2:55 or similar should be very doable. The first 15k felt easy, but towards the half-way point it already felt a bit too difficult. Hoping for a bad patch, I slowed down a little bit, but from km 27 onwards I really had to slow down, finishing in a time of 3:16.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/rotterdam2019.png&quot; title/&gt;&lt;/p&gt;
&lt;p&gt;
	After Rotterdam, I was disappointed, frustrated, and a confused: why doesn’t the hard work pay off? In the preparation, I sometimes got up at 5am, running in the dark with a headlight. I even ran in snow storms, rain, and temperatures below the freezing point.  I still don’t know what went wrong exactly, but I think there were two main factors at play: first of all, it was warm that day (compared to the months before). Second: I had some really rough nights in the months (and specificaly the days) before the marathon. My then 1-year old daughter would be awake for multiple hours during the night, and I would sit at her bedside, comforting her and gently getting her back to sleep. Even today, I think I had maybe ten full nights of sleep since the beginning of the year.
&lt;/p&gt;
&lt;p&gt;
	After four years of working hard but getting no results, I started to doubt myself. If you see a discrepancy between what you expect (running under 3 hours) and reality (running way slower) for long enough, at some point, you start to believe reality. Am I getting too old? Am I overestimating myself? Is it something else?
&lt;/p&gt;
&lt;p&gt;
	Rather than giving up, I made a few changes at the end of April. I started running with a more accurate heart rate monitor (a strap, rather than Garmin’s built-in optical monitor). I hired a personal trainer for intensive weekly strength sessions. I started running my long sessions before breakfast, often without eating anything during the run. I increased my mileage to an average of 110k per week, topping at 140k. I focused more on recovery: immediately get some carbs and protein in after the run (a glass of chocolate milk after a short run, and after longer runs, I make myself a raspberry/banana/protein milkshake). I do a bit more stretching and lots of foam rolling. In the summer, I took ice baths after my long runs (or sometimes I just sat in one of the lakes).
&lt;/p&gt;
&lt;p&gt;
	Going into the 2019 Berlin Marathon, I felt more prepared than ever: I only missed about 3 days of training during my 18-week schedule, I managed to get to my goal weight, and during the last weeks, I was working very little (spending lots of time with my daughter instead). During the week before the marathon, my daughter had a bad week sleep-wise, which meant I had to get up a few times a night. For the last two nights before the marathon, I slept on a sofa in the office, rather than at home.
&lt;/p&gt;
&lt;p&gt;
	On the morning of the marathon, I felt tired and slightly hungry (I had carb-loaded for a few days, but the last meal the night before was a bit lighter). On the train, I was annoyed at all the people around me, and I was sweating because it was too hot. Only about half an hour before the start I actually looked forward to running/
&lt;/p&gt;
&lt;p&gt;
	I decided to run the first km just a tiny bit slower than my goal pace, and then run the rest of the race based on heart rate (trying to keep it around 170bpm for most of the race). This went really well, and my split times were much faster than I had expected. Knowing from my training that I can maintain that heart rate for a long time (usually without breakfast!) helped me a lot, mentally. Except for one or two people, I hadn’t told anyone my goal time, but I hoped to run 2:53 or 2:52. My plan was to run around 1:25 for the first half, and then run a slower second half. I ran &lt;a href=&quot;https://berlin.r.mikatiming.com/2019/?content=detail&amp;fpid=search&amp;pid=search&amp;idp=99999905C9AF82000049A6FD&amp;lang=EN&amp;event=MAL&amp;search%5Bname%5D=eidhof&amp;search_event=MAL&quot;&gt;1:25:01&lt;/a&gt;, felt great, and decided to keep pushing during the second half. The crowd support was great, and I saw many friends along the course (this helped me a lot, mentally).
&lt;/p&gt;
&lt;p&gt;
	At 32km, with 10k left, it felt like my legs slowly started filling with concrete. However, I did the math, and realized that even if I dramatically slowed down my pace (from 4:00/km to around 4:30/km), I would still manage to run a 2:52. From then on, I kept on biting off small chunks: off towards km 36. Throughout the race, I had been eating a gel every 6km, and tried to drink a bit at every aid station. At 36k, I had my final gel, and realized it was only 2 more kilometers until my daughter, wife, and parents would be cheering me on (I took them by surprise, they expected me much later and only saw me at the last moment). From km 40 onwards, I realized I could run under 2:50. I kept pushing, and managed to finish in 2:48 (just barely under 2:49).
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/berlin2019.png&quot; title/&gt;
	&lt;br/&gt;&lt;em&gt;Berlin 2019: 2:48:51&lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
	Going into the race, I didn’t really believe I could run faster than 2:52. Let alone run 4:00/km for an entire marathon. I knew I’d be happy if I would break the 3-hour mark. This result completely took me by surprise, and even now, a few days later, I have trouble believing that I actually did it. I even mis-tweeted my finish time: I wrote I had run 2:52, but instead, it was 2:48!  At 32k, I already had to push back the tears in my eyes, and after the finish, I sobbed for the longest time. I think I managed to squeeze everything out of myself, as both my body and mind felt completely depleted (way more than normally).
&lt;/p&gt;
&lt;p&gt;
	Running a marathon isn’t necessarily the healthiest thing to do (although training for one probably isn’t the worst thing you could do, either). I mostly really like the preparation: feeling both your body and mind adapt, getting fitter and faster. I am pretty relieved that after four years, I now know I wasn’t a complete fool to feel like I could run under three hours again: all the hard work paid off.
&lt;/p&gt;
&lt;p&gt;
	I’m not sure what my running goals for the future will be. I feel like there’s still some room for improvement (better sleep, better conditions on race day (no rain), more strength and an improved running technique). However, for now, I’ll just enjoy the autumn running, with no specific goals. (Okay, I will admit I have been looking at spring marathons in 2020…)
&lt;/p&gt;
			</description>
			<pubDate>Tue, 01 Oct 2019 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/race-report-berlin-marathon</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/race-report-berlin-marathon</guid>
		</item>
		<item>
			<title>Swift Analytics</title>
			<description>
				&lt;p&gt;
	There have been a number of blog posts about the best way to do analytics in Swift:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			John writes about using &lt;a href=&quot;https://www.swiftbysundell.com/posts/building-an-enum-based-analytics-system-in-swift&quot;&gt;enums&lt;/a&gt;.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Matt writes about using &lt;a href=&quot;http://matt.diephouse.com/2017/12/when-not-to-use-an-enum/&quot;&gt;structs&lt;/a&gt;.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Dave writes about using &lt;a href=&quot;https://davedelong.com/blog/2017/12/07/misusing-enums/&quot;&gt;protocols&lt;/a&gt;.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Soroush writes about &lt;a href=&quot;http://khanlou.com/2017/12/misusing-subclassing/&quot;&gt;subclasses&lt;/a&gt;.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	Krzysztof &lt;a href=&quot;https://twitter.com/kprofic/status/938910246810062848&quot;&gt;asked&lt;/a&gt; about whether I would do a function-based version.
&lt;/p&gt;
&lt;p&gt;
	I think all solutions are valid. They’re different embeddings of the same problem. Another version to consider is the simplest one: just inlining the network calls into your code. Maybe that already does the job, and you’re set.
&lt;/p&gt;
&lt;p&gt;
	Now imagine that you find you make mistakes when writing the code. For example, you forget to provide the name, or you mistype the metadata keys. To prevent this, you could wrap up the network calls in functions. Functional programmers call this a &lt;em&gt;shallow embedding&lt;/em&gt;
	: you express your domain logic in a very thin wrapper. It’s the easiest way to add type-safety to an untyped domain.
&lt;/p&gt;
&lt;p&gt;
	A &lt;em&gt;deep embedding&lt;/em&gt;
	 is when you can also inspect (and possibly modify) the data. This is useful when you write tests, or when you need to change the structure at a later point. Matt’s struct-based solution provides the most minimal way to inspect the data: he just bundles up the analytics parameters. By providing type-safe initializers, the construction is made type-safe, even though the actual embedding (a string and a dictionary) loses the type-safety. This is a great choice, unless you need to transform the data afterwords.
&lt;/p&gt;
&lt;p&gt;
	John’s enum-based approach is another deep embedding: by providing cases for each possible event, he maintains the structure and type-safety. If you need to transform analytic events (for example, merging multiple events, or changing them in some other way) the enum approach is great: as long as you get out an enum value at the end, you know the data is well-formed.
&lt;/p&gt;
&lt;p&gt;
	Dave’s protocol-based approach allows you to have multiple different representations for your analytics events. For example, you could use Dave’s approach with John’s enums, Matt’s structs, and Soroush’s subclasses, at the same time, as long as they all conform to the protocol.
&lt;/p&gt;
&lt;p&gt;
	Another approach would be to group all the function wrappers in a protocol that you can send events to. Then you could have two implementations: one for testing/serialization, and for direct sending of the events. This is often used with dependency injection.
&lt;/p&gt;
&lt;p&gt;
	Each approach above adds a little bit of complexity to the code.
&lt;/p&gt;
&lt;p&gt;
	I’m a big fan of using the simplest possible solution for your problem and team:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			If you’re a precise programmer and don’t care about testing, just inline your network calls
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			If you want more type-safety, wrap your network calls in functions
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			If you use Matt’s struct-based initializer, you know the result is well-formed.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			If you plan to transform your values and want this to be safe, use John’s enums
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			If you need ultimate flexibility, use Dave’s protocols
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
			</description>
			<pubDate>Fri, 08 Dec 2017 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/swift-analytics</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/swift-analytics</guid>
		</item>
		<item>
			<title>A Micro Auto Layout DSL</title>
			<description>
				&lt;p&gt;
	These days, I’m using fewer external libraries. First, I don’t like most Swift libraries out there, they’re often implemented in a complicated way and contain too many protocols for my taste. Second, I’m not sure how they’ll be maintained in the future, and most libraries are pretty big – I don’t really want to own that code. Third, I’m too lazy to set up a dependency manager, so I’ll keep my projects dependency-free.
&lt;/p&gt;
&lt;p&gt;
	However, the other day as I was writing some UIKit code, I found myself annoyed at the verbosity of Auto Layout. Here’s some code that I wrote over and over again:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let view = UIView()
let label = UILabel()
view.addSubview(label)
label.translatesAutoresizingMaskIntoConstraints = false
NSLayoutConstraint.activate([
    label.leadingAnchor.constraint(equalTo: view.leadingAnchor),
    label.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
    label.trailingAnchor.constraint(equalTo: view.trailingAnchor)
])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	It’s always the same pattern: adding the subview, setting &lt;code&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt; to false, and then activating the constraints. The first anchor and the second anchor are almost always the same, and on the left-hand side we always have the child and on the right-hand side we always have the parent view. Often, when I write the code above, I forget to active the constraints or forget to set &lt;code&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt;. Let’s try to solve as many of these problems as we can in as little code as possible.
&lt;/p&gt;
&lt;p&gt;
	Rather than pulling in a library, I decided to write my own. The first bit of my micro-library is a function that, given a child and a parent, returns a layout constraint:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;typealias Constraint = (_ child: UIView, _ parent: UIView) -&amp;gt; NSLayoutConstraint
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Ideally, we would now write a method &lt;code&gt;equal&lt;/code&gt; which allows us to write following:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let constraint: Constraint = equal(\.topAnchor, \.safeAreaLayoutGuide.topAnchor)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Note that &lt;code&gt;constraint&lt;/code&gt; is just a description of a layout constraint – it’s still waiting for a concrete child and parent view. It says that, given a child and parent, the child’s top anchor should be equal to the parent’s &lt;code&gt;safeAreaLayoutGuide.topAnchor&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	We can implement &lt;code&gt;equal&lt;/code&gt; with a little bit of keypath magic:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func equal&amp;lt;Axis, Anchor&amp;gt;(_ keyPath: KeyPath&amp;lt;UIView, Anchor&amp;gt;, _ to: KeyPath&amp;lt;UIView, Anchor&amp;gt;, constant: CGFloat = 0) -&amp;gt; Constraint where Anchor: NSLayoutAnchor&amp;lt;Axis&amp;gt; {
    return { view, parent in
        view[keyPath: keyPath].constraint(equalTo: parent[keyPath: to], constant: constant)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Most of the time, the two layout anchors are the same (e.g. &lt;code&gt;leadingAnchor&lt;/code&gt; and &lt;code&gt;leadingAnchor&lt;/code&gt;), so let’s write a small helper for that case:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func equal&amp;lt;Axis, Anchor&amp;gt;(_ keyPath: KeyPath&amp;lt;UIView, Anchor&amp;gt;, constant: CGFloat = 0) -&amp;gt; Constraint where Anchor: NSLayoutAnchor&amp;lt;Axis&amp;gt; {
    return equal(keyPath, keyPath, constant: constant)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Finally, let’s solve the last two problems: we don’t want to forget to set &lt;code&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt; to false, and we don’t want to forget to activate the constraints. What if we create another version of &lt;code&gt;addSubview&lt;/code&gt; that does this for us?
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension UIView {
    func addSubview(_ child: UIView, constraints: [Constraint]) {
        addSubview(child)
        child.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate(constraints.map { $0(child, self) })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We now have everything in place to rewrite our initial example:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let view = UIView()
let label = UILabel()
view.addSubview(label, constraints: [
   equal(\.leadingAnchor),
   equal(\.topAnchor, \.safeAreaLayoutGuide.topAnchor),
   equal(\.trailingAnchor)
])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The code is shorter and much more to the point. The &lt;code&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt; is set automatically, and all constraints are activated. Instead of depending on a big library, we wrote three methods; 15 lines of code in total. Obviously, there are many things you can’t do with this: for example, you can’t easily keep a reference to a specific constraint and change the &lt;code&gt;constant&lt;/code&gt; property. That’s fine, we can keep using the regular Auto Layout API for this.
&lt;/p&gt;
&lt;p&gt;
	There are a few obvious extensions that are left as an exercise:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			Add a way to constrain an anchor to a constant (instead of another anchor and a constant)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Add a way to constrain to a different view than the parent (e.g. the content view of a &lt;code&gt;UIVisualEffectView&lt;/code&gt;)
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	Thanks to Florian Kugler for helping me simplify the code a lot. We also made a &lt;a href=&quot;https://talk.objc.io/episodes/S01E75-auto-layout-with-key-paths&quot;&gt;Swift Talk&lt;/a&gt; episode about the code above, check it out.
&lt;/p&gt;
			</description>
			<pubDate>Fri, 27 Oct 2017 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/micro-autolayout-dsl</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/micro-autolayout-dsl</guid>
		</item>
		<item>
			<title>Struct References</title>
			<description>
				&lt;blockquote&gt;
	&lt;p&gt;
		The full code for this is available as a &lt;a href=&quot;http://chris.eidhof.nl/snippets/2019-07-24-struct-references/&quot;&gt;snippet&lt;/a&gt; or  &lt;a href=&quot;https://gist.github.com/chriseidhof/3423e722d1da4e8cce7cfdf85f026ef7&quot;&gt;gist&lt;/a&gt;.
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
	Recently I was trying to find a good use for Swift’s new keypaths. This post shows one example that accidentally came up. This is something I’ve researched, and not something I’ve used in production code. That said, I think it’s very cool and I’d like to show it.
&lt;/p&gt;
&lt;p&gt;
	Consider a simple address book application. It contains a table view with people, and a detail view controller which shows a &lt;code&gt;Person&lt;/code&gt; instance. If &lt;code&gt;Person&lt;/code&gt; were defined as a class, it’d look like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;class Person {
    var name: String
    var addresses: [Address]
    init(name: String, addresses: [Address]) {
        self.name = name
        self.addresses = addresses
    }
}

class Address {
    var street: String
    init(street: String) {
        self.street = street
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The definition for our (fake) view controller has a single person property, which gets passed in through the initializer. It also has a &lt;code&gt;change&lt;/code&gt; method which changes a property of the person.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;final class PersonVC {
    var person: Person
    init(person: Person) {
        self.person = person
    }
    
    func change() {
        person.name = &amp;quot;New Name&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Let’s consider the problems with &lt;code&gt;Person&lt;/code&gt; being an object:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			Because &lt;code&gt;person&lt;/code&gt; is a reference, a different part of the code might change it. This is very useful as it allows communication. At the same time, we need to make sure that we stay notified of those changes (for example, through KVO) otherwise we might be displaying data that’s out of sync. Making sure we stay notified is not straightforward.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Getting notified when &lt;code&gt;addresses&lt;/code&gt; change is even harder. Observing nested properties that are objects is difficult.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			If we need an independent local copy of &lt;code&gt;Person&lt;/code&gt;, we’d need to implement something like &lt;code&gt;NSCopying&lt;/code&gt;. This is quite a bit of work. Even when we have that, we still have to think: do we want a deep copy (e.g. should the addresses also be copied) or a shallow copy (the &lt;code&gt;addresses&lt;/code&gt; array is independent, but the addresses inside still point to the same objects)?
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			If we think of &lt;code&gt;Person&lt;/code&gt; as being in an array inside &lt;code&gt;AddressBook&lt;/code&gt;, we might want to know when the address book changes (for example, to serialize it). Knowing when something inside your object graph changes either requires a lot of boilerplate, or a lot of observing.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	If &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt; were structs, we’d have different issues:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			Each struct is an independent copy. This is useful, because we know it’s always consistent and can’t change underneath us. However, after we change a &lt;code&gt;Person&lt;/code&gt; in the detail view controller, we’d need a way to communicate those changes back to the table view (or to the address book). With objects, this happens /automatically (by changing the &lt;code&gt;Person&lt;/code&gt; in place).
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We can observe the root address book struct, and know of any changes that happen within. Still, we can’t easily observe parts of it (e.g. observe the first person’s name).
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	The solution that I present combines the best of both worlds:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			We have mutable shared references
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			The underlying data is structs, so we can always get our own independent copy
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We can observe any part: either at the root level, or observe individual properties (e.g. the first person’s name)
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	I’ll first show how to use it, then how it works and finally discuss some of the limitations and gotchas.
&lt;/p&gt;
&lt;p&gt;
	Let’s create an address book using structs:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct Address {
    var street: String
}
struct Person {
    var name: String
    var addresses: [Address]
}

typealias Addressbook = [Person]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Now we can use our &lt;code&gt;Ref&lt;/code&gt; type (short for &lt;code&gt;Reference&lt;/code&gt;). We create a new &lt;code&gt;addressBook&lt;/code&gt; reference with an initial empty array. Then we append a &lt;code&gt;Person&lt;/code&gt;. Now for the cool part: by using subscripts, we can get a &lt;em&gt;reference&lt;/em&gt;
	 to the first person, and then a &lt;em&gt;reference&lt;/em&gt;
	 to their name. We can change the value of the reference to &lt;code&gt;&amp;quot;New Name&amp;quot;&lt;/code&gt; and verify that we’ve changed the original address book:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let addressBook = Ref&amp;lt;Addressbook&amp;gt;(initialValue: [])
addressBook.value.append(Person(name: &amp;quot;Test&amp;quot;, addresses: []))
let firstPerson: Ref&amp;lt;Person&amp;gt; = addressBook[0]
let nameOfFirstPerson: Ref&amp;lt;String&amp;gt; = firstPerson[\.name]
nameOfFirstPerson.value = &amp;quot;New Name&amp;quot;
addressBook.value // shows [Person(name: &amp;quot;New Name&amp;quot;, addresses: [])]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The types for &lt;code&gt;firstPerson&lt;/code&gt; and &lt;code&gt;nameOfFirstPerson&lt;/code&gt; can be omitted, they’re just there for readability.
&lt;/p&gt;
&lt;p&gt;
	If at any point we want to get our own independent value of &lt;code&gt;Person&lt;/code&gt;, we can do that. From there on, we can work with &lt;code&gt;myOwnCopy&lt;/code&gt; and be sure it’s not changed from underneath us. No need to implement &lt;code&gt;NSCopying&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;var myOwnCopy: Person = firstPerson.value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can observe any &lt;code&gt;Ref&lt;/code&gt;. Just like with reactive libraries, we get a disposable back which controls the lifetime of an observer:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;var disposable: Any?
disposable = addressBook.addObserver { newValue in
    print(newValue) // Prints the entire address book
}

disposable = nil // stop observing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can also observe &lt;code&gt;nameOfFirstPerson&lt;/code&gt;. In the current implementation, this gets triggered anytime anything changes in the address book, but more about that later.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;nameOfFirstPerson.addObserver { newValue in
    print(newValue) // Prints a string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Let’s go back to our &lt;code&gt;PersonVC&lt;/code&gt;. We can change its implementation to use a &lt;code&gt;Ref&lt;/code&gt;. The view controller can now subscribe to changes. In reactive programming, a signal is typically read-only (you only receive changes), and you need to figure another way to communicate back. In the &lt;code&gt;Ref&lt;/code&gt; approach, we can write back using &lt;code&gt;person.value&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;final class PersonVC {
    let person: Ref&amp;lt;Person&amp;gt;
    var disposeBag: Any?
    init(person: Ref&amp;lt;Person&amp;gt;) {
        self.person = person
        disposeBag = person.addObserver { newValue in
            print(&amp;quot;update view for new person value: \(newValue)&amp;quot;)
        }
    }
    
    func change() {
        person.value.name = &amp;quot;New Name&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The &lt;code&gt;PersonVC&lt;/code&gt; doesn’t know where the &lt;code&gt;Ref&amp;lt;Person&amp;gt;&lt;/code&gt; comes from: a person array, a database, or somewhere else. In fact, we can add undo support to our address book by wrapping our array inside a &lt;a href=&quot;http://chris.eidhof.nl/post/undo-history-in-swift/&quot;&gt;&lt;code&gt;History&lt;/code&gt; struct&lt;/a&gt;, and we don’t need to change the &lt;code&gt;PersonVC&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let source: Ref&amp;lt;History&amp;lt;Addressbook&amp;gt;&amp;gt; = Ref(initialValue: History(initialValue: []))
let addressBook: Ref&amp;lt;Addressbook&amp;gt; = source[\.value]
addressBook.value.append(Person(name: &amp;quot;Test&amp;quot;, addresses: []))
addressBook[0].value.name = &amp;quot;New Name&amp;quot;
print(addressBook[0].value)
source.value.undo()
print(addressBook[0].value)
source.value.redo()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	There’s a lot of other things we could add to this: caching, &lt;a href=&quot;https://gist.github.com/chriseidhof/40fde6c2be5519d5bb341fc65b3029ad&quot;&gt;serialization&lt;/a&gt;, automatic synchronization (e.g. only modify and observe on a private queue), but that’s future work.
&lt;/p&gt;
&lt;h3&gt;
	Implementation Details
&lt;/h3&gt;
&lt;p&gt;
	Let’s look at how this thing is implemented. We’ll start by defining the &lt;code&gt;Ref&lt;/code&gt; class. A &lt;code&gt;Ref&lt;/code&gt; consists of a way to get and set a value, and a way to add an observer. It has an initializer that asks for just those three things:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;final class Ref&amp;lt;A&amp;gt; {
    typealias Observer = (A) -&amp;gt; ()
    
    private let _get: () -&amp;gt; A
    private let _set: (A) -&amp;gt; ()
    private let _addObserver: (@escaping Observer) -&amp;gt; Disposable
    
    var value: A {
        get {
            return _get()
        }
        set {
            _set(newValue)
        }
    }
    
    init(get: @escaping () -&amp;gt; A, set: @escaping (A) -&amp;gt; (), addObserver: @escaping (@escaping Observer) -&amp;gt; Disposable) {
        _get = get
        _set = set
        _addObserver = addObserver
    }    

    func addObserver(observer: @escaping Observer) -&amp;gt; Disposable {
        return _addObserver(observer)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can now add an initializer that observers a single struct value. It creates a dictionary of observers and a variable. Whenever the variable changes, all observers get notified. It uses the initializer defined above and passes on &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, and &lt;code&gt;addObserver&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension Ref {
    convenience init(initialValue: A) {
        var observers: [Int: Observer] = [:]
        var theValue = initialValue {
            didSet { observers.values.forEach { $0(theValue) } }
        }
        var freshId = (Int.min...).makeIterator()
        let get = { theValue }
        let set = { newValue in theValue = newValue }
        let addObserver = { (newObserver: @escaping Observer) -&amp;gt; Disposable in
            let id = freshId.next()!
            observers[id] = newObserver
            return Disposable {
                observers[id] = nil
            }
        }
        self.init(get: get, set: set, addObserver: addObserver)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Let’s consider we have &lt;code&gt;Person&lt;/code&gt; reference. In order to get a reference to its &lt;code&gt;name&lt;/code&gt; property, we need a way to both read and write the name. A &lt;code&gt;WritableKeyPath&lt;/code&gt; provides just that. We can thus add a &lt;code&gt;subscript&lt;/code&gt; to &lt;code&gt;Ref&lt;/code&gt; that creates a reference to part of the &lt;code&gt;Person&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension Ref {
    subscript&amp;lt;B&amp;gt;(keyPath: WritableKeyPath&amp;lt;A,B&amp;gt;) -&amp;gt; Ref&amp;lt;B&amp;gt; {
        let parent = self
        return Ref&amp;lt;B&amp;gt;(get: { parent._get()[keyPath: keyPath] }, set: {
            var oldValue = parent.value
            oldValue[keyPath: keyPath] = $0
            parent._set(oldValue)
        }, addObserver: { observer in
            parent.addObserver { observer($0[keyPath: keyPath]) }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The code above is a bit hard to read, but in order to use the library, you don’t really need to understand how it’s implemented.
&lt;/p&gt;
&lt;p&gt;
	One day, keypaths in Swift will also support subscripts, but until then, we’ll have to add another subscript for collections. The implementation is almost the same as above, except that we use indices rather than keypaths:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension Ref where A: MutableCollection {
    subscript(index: A.Index) -&amp;gt; Ref&amp;lt;A.Element&amp;gt; {
        return Ref&amp;lt;A.Element&amp;gt;(get: { self._get()[index] }, set: { newValue in
            var old = self.value
            old[index] = newValue
            self._set(old)
        }, addObserver: { observer in
                self.addObserver { observer($0[index]) }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	That’s all there is to it. The code uses a lot of advanced Swift features, but it’s under a hundred lines. It wouldn’t be possible without all the new Swift 4 additions: it relies on keypaths, generic subscripts, open-ended ranges, and a lot of features that were previously available in Swift.
&lt;/p&gt;
&lt;h3&gt;
	Discussion
&lt;/h3&gt;
&lt;p&gt;
	As stated before, this is research code, not production-level code. I’m very interested to see where and how this breaks once I start using it in a real app. Here’s a snippet that had some very counter-intuitive behavior for me:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;var twoPeople: Ref&amp;lt;Addressbook&amp;gt; = Ref(initialValue:
    [Person(name: &amp;quot;One&amp;quot;, addresses: []),
     Person(name: &amp;quot;Two&amp;quot;, addresses: [])])
let p0 = twoPeople[0]
twoPeople.value.removeFirst()
print(p0.value) // what does this print?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	I’d be really interested in pushing this further. I can imagine adding support for queues, so that you can do something like:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;var source = Ref&amp;lt;Addressbook&amp;gt;(initialValue: [], 
    queue: DispatchQueue(label: &amp;quot;private queue&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	I can also imagine that you could use this with a database. The &lt;code&gt;Var&lt;/code&gt; would allow you to both read and write, as well as subscribe to any notifications:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;final class MyDatabase {
   func readPerson(id: Person.Id) -&amp;gt; Var&amp;lt;Person&amp;gt; {
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	I’d love to hear comments and feedback. If you want to get a deeper understanding of how this works, try implementing it yourself (even after you’ve had a look at the code). By the way, we also made two &lt;a href=&quot;http://talk.objc.io/&quot;&gt;Swift Talk&lt;/a&gt; episodes about this: &lt;a href=&quot;https://talk.objc.io/episodes/S01E61-mutable-shared-structs-part-1&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;https://talk.objc.io/episodes/S01E63-mutable-shared-structs-part-2&quot;&gt;part 2&lt;/a&gt;. If you’re interested in Florian and me building this from scratch, please subscribe there.
&lt;/p&gt;
&lt;blockquote&gt;
	&lt;p&gt;
		Update: thanks to Egor Sobko for pointing out a subtle but crucial mistake: I was sending the observers &lt;code&gt;initialValue&lt;/code&gt; rather than &lt;code&gt;theValue&lt;/code&gt;. Fixed!
	&lt;/p&gt;
&lt;/blockquote&gt;
			</description>
			<pubDate>Wed, 19 Jul 2017 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/references</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/references</guid>
		</item>
		<item>
			<title>Reducers</title>
			<description>
				&lt;blockquote&gt;
	&lt;p&gt;
		This blogpost is part of an upcoming project, more about that soon.
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
	Reducers are a way to deal with state changes, and are great for dealing with asynchronous code. They come in a number of different ways, and are used in architectures like &lt;a href=&quot;http://redux.js.org/docs/introduction/Motivation.html&quot;&gt;Redux&lt;/a&gt;, &lt;a href=&quot;https://guide.elm-lang.org/architecture/&quot;&gt;Elm&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; and more.
&lt;/p&gt;
&lt;p&gt;
	Instead of giving a definition up front, we’ll look refactor an example app that is well-suited to write with reducers. For a playground with the full code (both &lt;a href=&quot;https://github.com/chriseidhof/reducers-examples/blob/master/Reducers.playground/Pages/Currency%20Conversion.xcplaygroundpage/Contents.swift&quot;&gt;before&lt;/a&gt; and &lt;a href=&quot;https://github.com/chriseidhof/reducers-examples/blob/master/Reducers.playground/Pages/Currency%20Conversion%20-%20Reducers.xcplaygroundpage/Contents.swift&quot;&gt;after&lt;/a&gt; refactoring) see &lt;a href=&quot;https://github.com/chriseidhof/reducers-examples&quot;&gt;reducers-examples&lt;/a&gt; on GitHub.
&lt;/p&gt;
&lt;h2&gt;
	Example
&lt;/h2&gt;
&lt;p&gt;
	To demonstrate reducers, we will write a simple currency conversion app that converts EUR amounts into USD amounts. It has three views: an text field for the input amount, a button to reload the current exchange rate and an output label. The output label will only display the amount if the input amount can be parsed and the current exchange rate are loaded. If the exchanges rates are loaded, changing the input amount should immediately change the output. Here’s the code that computes the output rate (this is hooked up to the &lt;code&gt;.editingChanged&lt;/code&gt; event of the text field):
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;var rate: Double?    
@objc func inputChanged() {
    guard let rate = rate else { return }
    guard let text = input.text, let number = Double(text) else { return }
    output.text = &amp;quot;\(number * rate) USD&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Next up, the code that reloads the exchange rates:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;@objc func reload() {
    URLSession.shared.dataTask(with: ratesURL()) { (data, _, _) in
        guard let data = data,
            let json = try? JSONSerialization.jsonObject(with: data, options: []),
            let dict = json as? [String:Any],
            let dataDict = dict[&amp;quot;rates&amp;quot;] as? [String:Double],
            let rate = dataDict[Currency.usd.rawValue] else { return }
        DispatchQueue.main.async { [weak self] in
            self?.rate = rate
            self?.inputChanged()
        }
    }.resume()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The code above is hard to test. First of all, there’s a dependency on the shared &lt;code&gt;URLSession&lt;/code&gt;. To make this more testable, we could consider pulling that out into a configurable property. Even if we do that, the code is still hard to test. We’d like to test that the parsing happens correctly, that we switch back to the main thread before updating the UI, that we set the rate and that we finally call &lt;code&gt;inputChanged()&lt;/code&gt;. The asynchronous code makes it especially hard to verify that our logic is correct.
&lt;/p&gt;
&lt;p&gt;
	We can pull out most of the logic into a &lt;code&gt;State&lt;/code&gt; struct to make the logic easy to test. The &lt;code&gt;State&lt;/code&gt; struct encapsulates the input amount and the conversion rate, and exposes a single computed property (the output):
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct State {
    private var inputAmount: Double? = nil
    private var rate: Double? = nil
    var output: Double? {
        guard let i = inputAmount, let r = rate else { return nil }
        return i * r
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Next up, we’ll define three messages that this state can receive. The input can change, the reload button could be pressed, or new rate data could be available. The third message is not sent from the outside. Instead of defining these as methods, we’ll define the messages as an enum (we’ll see why shortly):
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;enum Message {
    case inputChanged(String?)
    case ratesAvailable(data: Data?)
    case reload
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Now that we have defined our state and our &lt;code&gt;Message&lt;/code&gt; enum, we can write a method to interpet messages. Because &lt;code&gt;State&lt;/code&gt; is a struct, we define it as a &lt;code&gt;mutating&lt;/code&gt; method &lt;code&gt;send(_:)&lt;/code&gt;. We switch over the message and interpet it. In case the input changed, we try to parse it. When new rate data is available, we parse it and assign it to &lt;code&gt;self.rate&lt;/code&gt;. We’ll leave out the &lt;code&gt;reload&lt;/code&gt; case for now.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;mutating func send(_ message: Message) {
    switch message {
    case .inputChanged(let input):
        inputAmount = input.flatMap { Double($0) }
    case .ratesAvailable(data: let data):
        guard let data = data,
            let json = try? JSONSerialization.jsonObject(with: data, options: []),
            let dict = json as? [String:Any],
            let dataDict = dict[&amp;quot;rates&amp;quot;] as? [String:Double],
            let rate = dataDict[Currency.usd.rawValue] else { return }
        self.rate = rate
    case .reload:
        // TODO: load ratesURL() and update the rates
        fatalError()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	In the &lt;code&gt;.reload&lt;/code&gt; case, we’d like to load the &lt;code&gt;ratesURL()&lt;/code&gt; and then send the &lt;code&gt;.ratesAvailable()&lt;/code&gt; message. If we would use &lt;code&gt;URLSession.sharedSession&lt;/code&gt; directly, we lose our testability. We’d either have to inject the session, mock it, or find a different way to make it testable. Even if we we would do that, we’d have a problem in the &lt;code&gt;URLSession&lt;/code&gt;‘s callback: we cannot update &lt;code&gt;self&lt;/code&gt; because it’s a struct, not a class.
&lt;/p&gt;
&lt;p&gt;
	Instead of performing the URL loading side-effect directly, we’ll create a &lt;code&gt;Command&lt;/code&gt; enum that describes the side-effect:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;enum Command {
    case load(URL, onComplete: (Data?) -&amp;gt; Message)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Note that we cannot use &lt;code&gt;onComplete&lt;/code&gt; as a callback (because we cannot change the struct value in a callback). Instead, it transforms the optional data back into a &lt;code&gt;Message&lt;/code&gt;. We’ll add &lt;code&gt;Command?&lt;/code&gt; as a return type for &lt;code&gt;send(_:)&lt;/code&gt;. If there’s no side-effect to be executed, we simply return &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;mutating func send(_ message: Message) -&amp;gt; Command? {
    switch message {
    case .inputChanged(let input):
        inputAmount = input.flatMap { Double($0) }
        return nil
    case .ratesAvailable(data: let data):
        guard let data = data,
            let json = try? JSONSerialization.jsonObject(with: data, options: []),
            let dict = json as? [String:Any],
            let dataDict = dict[&amp;quot;rates&amp;quot;] as? [String:Double],
            let rate = dataDict[Currency.usd.rawValue] else { return nil }
        self.rate = rate
        return nil
    case .reload:
        return .load(ratesURL(), onComplete: Message.ratesAvailable)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Note that the code above is completely synchronous. In a test, we can construct a value of &lt;code&gt;State&lt;/code&gt; and send it any message we want. Afterwards, we can verify that it changed the state as we expected, and that the correct side-effect is executed. For example, in the reload case, we can even test that the &lt;code&gt;onComplete&lt;/code&gt; is set to the &lt;code&gt;.ratesAvailable&lt;/code&gt; message. In our initial (non-reducer) code, testing this would involve a lot of mocking and stubbing.
&lt;/p&gt;
&lt;p&gt;
	To interpret commands, we can define a separate extension on &lt;code&gt;State.Command&lt;/code&gt; that interprets a command. Instead of having asynchronous code in our &lt;code&gt;State&lt;/code&gt;’s logic, we can simply test this &lt;code&gt;interpret(_:)&lt;/code&gt; method once, in isolation.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension State.Command {
    func interpret(_ callback: @escaping (State.Message) -&amp;gt; ()) {
        switch self {
        case let .load(url, onComplete: transform):
            URLSession.shared.dataTask(with: url, completionHandler: { (data, _, _) in
                DispatchQueue.main.async {
                    callback(transform(data))
                }
            }).resume()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Finally, we need to hook up our &lt;code&gt;State&lt;/code&gt; to the view controller we’re refactoring. Instead of the &lt;code&gt;rate&lt;/code&gt; property that we had before, we’ll now define a &lt;code&gt;State&lt;/code&gt; property:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;var state = State() {
    didSet {
        self.output.text = state.output.map { &amp;quot;\($0) USD&amp;quot; } ?? &amp;quot;&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can also define a &lt;code&gt;send&lt;/code&gt; method on the view controller. It sends a message to the state, and if there’s any &lt;code&gt;Command&lt;/code&gt;, it interprets that command.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;private func send(_ message: State.Message) {
    state.send(message)?.interpret(self.send)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The only thing left is sending the correct messages in the view controller’s &lt;code&gt;inputChanged&lt;/code&gt; and &lt;code&gt;reload&lt;/code&gt; actions:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;@objc func inputChanged() {
    send(.inputChanged(input.text))
}

@objc func reload() {
    send(State.Message.reload)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Note that it’s easy to test &lt;code&gt;inputChanged&lt;/code&gt; and &lt;code&gt;reload&lt;/code&gt;. We don’t have to mock the state, but just test that the right &lt;code&gt;Message&lt;/code&gt; is sent. We can then separately test the implementation of &lt;code&gt;send(_:)&lt;/code&gt; on the state struct.
&lt;/p&gt;
&lt;h2&gt;
	Reducers, Defined
&lt;/h2&gt;
&lt;p&gt;
	Our &lt;code&gt;send(_:)&lt;/code&gt; method on &lt;code&gt;State&lt;/code&gt; is defined as a mutating method, and it is a &lt;em&gt;reducer&lt;/em&gt;
	. Generally, we could say that the a reducer is a function of type &lt;code&gt;(inout State, Message) -&amp;gt; Command&lt;/code&gt;, if &lt;code&gt;State&lt;/code&gt; is a value type. More generally, its type is &lt;code&gt;(State, Message) -&amp;gt; (State, Command)&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	There is another important requirement in order for a method to be a reducer: it has to be a pure method, with no side-effects. There is no way in Swift to let the compiler enforce this. Instead of reading global state, we have to send &lt;code&gt;Input&lt;/code&gt; messages to the reducers. And instead of having a side-effect that modifies global state, a reducer returns &lt;code&gt;Output&lt;/code&gt; messages.
&lt;/p&gt;
&lt;p&gt;
	If you have an object-oriented programming background, you might be reminded of objects. Just like objects, reducers encapsulate state and allow only certain messages. However, unlike objects, reducers have no side-effects and are therefore highly testable. We can intercept and inspect both the input and the output messages without having to create mock classes. Reducers don’t have asynchronous code; instead, the asynchrony is pushed outside to the code that drives the reducer. This also greatly helps for testability.
&lt;/p&gt;
&lt;p&gt;
	Note that instead of a &lt;code&gt;Message&lt;/code&gt; enum, we could have also defined our messages as &lt;code&gt;mutating&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; type. However, by defining messages as an enum, we gain a lot of flexibility: we can easily check that the right message is sent, we can serialize messages (for example, to send over the network) and we can easily forward them to other parts of the state.
&lt;/p&gt;
&lt;p&gt;
	The &lt;code&gt;State&lt;/code&gt; type with its &lt;code&gt;send(_:)&lt;/code&gt; method is an example of the &lt;a href=&quot;https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell&quot;&gt;“functional core, imperative shell”&lt;/a&gt; pattern. The reducer is the functional core, and is very easy to test. The view controller’s &lt;code&gt;send&lt;/code&gt; method is the imperative shell: it interprets the side-effects. This pattern can also be applied at a large scale.
&lt;/p&gt;
&lt;p&gt;
	For some other examples using reducers, check out my &lt;a href=&quot;https://github.com/chriseidhof/tea-in-swift&quot;&gt;Swift implementation of The Elm Architecture&lt;/a&gt;, or this &lt;a href=&quot;https://gist.github.com/inamiy/bd257c60e670de8a144b1f97a07bacec&quot;&gt;awesome list&lt;/a&gt; of Elm-inspired frameworks. Matt Gallagher also just wrote a post about &lt;a href=&quot;http://www.cocoawithlove.com/blog/statements-messages-reducers.html&quot;&gt;statements, messages and reducers&lt;/a&gt;&lt;/p&gt;
			</description>
			<pubDate>Mon, 03 Jul 2017 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/reducers</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/reducers</guid>
		</item>
		<item>
			<title>Classes That Conform To Protocols</title>
			<description>
				&lt;p&gt;
	The other day, someone asked how to have a variable which stores a &lt;code&gt;UIView&lt;/code&gt; that also conforms to a protocol. In Objective-C, you would simply write &lt;code&gt;UIView&amp;lt;HeaderViewProtocol&amp;gt;&lt;/code&gt;. In  current Swift, you can’t write something like that. This posts shows two workarounds.
&lt;/p&gt;
&lt;p&gt;
	First, let’s set the stage, and assume we have a &lt;code&gt;HeaderViewProtocol&lt;/code&gt;:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;protocol HeaderViewProtocol {
    func setTitle(_ string: String)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Until &lt;a href=&quot;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generalized-existentials&quot;&gt;generalized existentials&lt;/a&gt; arrive, we’ll have to make do with a workaround. The most mechanical solution would be to write a struct which has two properties, one for the protocol and one for the &lt;code&gt;UIView&lt;/code&gt;. Both point to the same reference:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct AnyHeaderView {
    let view: UIView
    let headerView: HeaderViewProtocol
    init&amp;lt;T: UIView&amp;gt;(view: T) where T: HeaderViewProtocol {
        self.view = view
        self.headerView = view
    }
}

let header = AnyHeaderView(view: myView)
header.headerView.setTitle(&amp;quot;hi&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Alternatively, we could also completely &lt;a href=&quot;http://chris.eidhof.nl/post/protocol-oriented-programming/&quot;&gt;get rid of the protocol&lt;/a&gt;, and create a &lt;code&gt;HeaderView&lt;/code&gt; struct which simply stores a view and a way to set the title:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct HeaderView {
    let view: UIView
    let setTitle: (String) -&amp;gt; ()
}

var label = UILabel()
let header = HeaderView(view: label) { str in
    label.text = str
}
header.setTitle(&amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	One benefit of this solution is that there are no protocols involved. More importantly, we can have multiple “implementations” of &lt;code&gt;HeaderView&lt;/code&gt; for a single class. This eliminates the need to subclass. I prefer this solution, as it’s really simple: just bundle up a function and a view.
&lt;/p&gt;
&lt;p&gt;
	(If your protocol has associated types or a &lt;code&gt;Self&lt;/code&gt; constraint, it will be a bit more work to write the type-eraser, see &lt;a href=&quot;http://chris.eidhof.nl/post/type-erasers-in-swift/&quot;&gt;here&lt;/a&gt; for an explanation).
&lt;/p&gt;
			</description>
			<pubDate>Wed, 01 Feb 2017 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/classes-and-protocols</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/classes-and-protocols</guid>
		</item>
		<item>
			<title>Types vs TDD</title>
			<description>
				&lt;p&gt;
	This morning, I read &lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2017/01/11/TheDarkPath.html&quot;&gt;an article&lt;/a&gt; against static typing. To be more precise: it argues against static typing in the way Swift/Kotlin implement it. I don’t know anything about Kotlin, so I’ll try to relate everything to Swift.  The main point of the article is that too much static typing is a bad thing. I agree: although my definition of “too much” is very different.
&lt;/p&gt;
&lt;p&gt;
	The main point of critique is that we can’t possibly keep adding features to a language to solve actual problems, because we would end up with too many features. Instead, we should solve everything by writing tests. I don’t think it’s an either/or situation at all: we can have a solid type system and write “manual” tests.
&lt;/p&gt;
&lt;p&gt;
	A type checker actually does testing for you. It’s not a replacement for TDD, but it allows you to completely get rid of a whole bunch of tests. For example, if you define a method &lt;code&gt;foo&lt;/code&gt; that returns an &lt;code&gt;Int&lt;/code&gt;, you can be sure it will only return &lt;code&gt;Int&lt;/code&gt;s. Not &lt;code&gt;String&lt;/code&gt;s, not &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, not anything else. No need to write a test.
&lt;/p&gt;
&lt;p&gt;
	The article argues that specifying a type such as &lt;code&gt;Int&lt;/code&gt; is very inflexible: what if you ever wanted to change &lt;code&gt;foo&lt;/code&gt; to return an optional?  According to the article, you have to know this before you write the system. (And if I interpret the article correctly, it argues that TDD would solve this).
&lt;/p&gt;
&lt;p&gt;
	I agree on at least one thing: at some point, code is going to change. However, I couldn’t disagree more on the statement that typing makes this hard.
&lt;/p&gt;
&lt;p&gt;
	In Swift, once you change &lt;code&gt;foo&lt;/code&gt; to return an &lt;code&gt;Int?&lt;/code&gt;, the compiler will now show an error for each time you call &lt;code&gt;foo&lt;/code&gt;. This makes it &lt;em&gt;easy&lt;/em&gt;
	 to make that change, because until you have reviewed every single call to &lt;code&gt;foo&lt;/code&gt;, the program simply won’t compile. I think of the compile errors as a todo-list, not as a &lt;a href=&quot;https://twitter.com/unclebobmartin/status/819262224686546945&quot;&gt;speed bump&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	When you make changes (small or large ones), it’s good to have a system in place that checks whether your code still works. With many kinds of changes, the compiler can do this automatically. You don’t have to write tests for that.
&lt;/p&gt;
&lt;p&gt;
	Don’t get me wrong: types are not a silver bullet. You still need to test your code. But wouldn’t you rather test interesting parts, and leave the boring stuff to the compiler?
&lt;/p&gt;
			</description>
			<pubDate>Thu, 12 Jan 2017 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/types-vs-tdd</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/types-vs-tdd</guid>
		</item>
		<item>
			<title>Protocol Oriented Programming is Not a Silver Bullet</title>
			<description>
				&lt;p&gt;
	In Swift, protocol-oriented programming is in fashion. There’s a lot of Swift code out there that’s “protocol-oriented”, some open-source libraries even state it as a feature. I think protocols are heavily overused in Swift, and oftentimes the problem at hand can be solved in a much simpler way. In short: don’t be dogmatic about using (or avoiding) protocols.
&lt;/p&gt;
&lt;p&gt;
	One of the most influential sessions at WWDC 2015 was called &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/408/&quot;&gt;Protocol-Oriented Programming in Swift&lt;/a&gt;. It shows (among other things) that you can replace a class hierarchy (that is, a superclass and some subclasses) with a protocol-oriented solution (that is, a protocol and some types that conform to the protocol). The protocol-oriented solution is simpler, and more flexible. For example, a class can only have a single superclass, yet a type can conform to many protocols.
&lt;/p&gt;
&lt;p&gt;
	Let’s look at the problem they solved in the WWDC talk. A series of drawing commands needed to be rendered as a graphic, as well as logged to the console. By putting the drawing commands in a protocol, any code that describes a drawing could be phrased in terms of the protocol’s methods. Protocol extensions allow you to define new drawing functionality in terms of the protocol’s base functionality, and every type that conforms gets the new functionality for free.
&lt;/p&gt;
&lt;p&gt;
	In the example above, protocols solve the problem of sharing code between multiple types. In Swift’s Standard Library, protocols are heavily used for collections, and they solve exactly the same problem. Because &lt;code&gt;dropFirst&lt;/code&gt; is defined on the &lt;code&gt;Collection&lt;/code&gt; type, all the collection types get this for free! At the same time, there are so many collection-related protocols and types, that it can be hard to find things. That’s one drawback of protocols, yet the advantages easily outweigh the disadvantages in the case of the Standard Library.
&lt;/p&gt;
&lt;p&gt;
	Now, let’s work our way through an example. Here, we have a Webservice class. It loads entities from the network using &lt;code&gt;URLSession&lt;/code&gt;. (It doesn’t actually load things, but you get the idea):
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Webservice {
    func loadUser() -&amp;gt; User? {
        let json = self.load(URL(string: &amp;quot;/users/current&amp;quot;)!)
        return User(json: json)
    }
    
    func loadEpisode() -&amp;gt; Episode? {
        let json = self.load(URL(string: &amp;quot;/episodes/latest&amp;quot;)!)
        return Episode(json: json)
    }
    
    private func load(_ url: URL) -&amp;gt; [AnyHashable:Any] {
        URLSession.shared.dataTask(with: url)
        // etc.
        return [:] // should come from the server
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The code above is short and works fine. There is no problem, until we want to test &lt;code&gt;loadUser&lt;/code&gt; and &lt;code&gt;loadEpisode&lt;/code&gt;. Now we either have to stub &lt;code&gt;load&lt;/code&gt;, or pass in a mock &lt;code&gt;URLSession&lt;/code&gt; using dependency injection. We could also define a protocol that &lt;code&gt;URLSession&lt;/code&gt; conforms to and then pass in a test instance. However, in this case, the solution is much simpler: we can pull the changing parts out of the &lt;code&gt;Webservice&lt;/code&gt; and into a struct (we also cover this in &lt;a href=&quot;https://talk.objc.io/episodes/S01E01-networking&quot;&gt;Swift Talk Episode 1&lt;/a&gt; and in &lt;a href=&quot;https://www.objc.io/books/advanced-swift/&quot;&gt;Advanced Swift&lt;/a&gt;):
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Resource&amp;lt;A&amp;gt; {
    let url: URL
    let parse: ([AnyHashable:Any]) -&amp;gt; A
}

class Webservice {
    let user = Resource&amp;lt;User&amp;gt;(url: URL(string: &amp;quot;/users/current&amp;quot;)!, parse: User.init)
    let episode = Resource&amp;lt;Episode&amp;gt;(url: URL(string: &amp;quot;/episodes/latest&amp;quot;)!, parse: Episode.init)
    
    private func load&amp;lt;A&amp;gt;(resource: Resource&amp;lt;A&amp;gt;) -&amp;gt; A {
        URLSession.shared.dataTask(with: resource.url)
        // load asynchronously, parse the JSON, etc. For the sake of the example, we directly return an empty result.
        let json: [AnyHashable:Any] = [:] // should come from the server
        return resource.parse(json)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Now, we can test &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;episode&lt;/code&gt; without having to mock anything: they’re simple struct values. We still have to test &lt;code&gt;load&lt;/code&gt;, but that’s only one method (instead of for each resource). Now let’s add some protocols.
&lt;/p&gt;
&lt;p&gt;
	Instead of the &lt;code&gt;parse&lt;/code&gt; function, we could create a protocol for types that can be initialized from JSON.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protocol FromJSON {
    init(json: [AnyHashable:Any])
}

struct Resource&amp;lt;A: FromJSON&amp;gt; {
    let url: URL
}

class Webservice {
    let user = Resource&amp;lt;User&amp;gt;(url: URL(string: &amp;quot;/users/current&amp;quot;)!)
    let episode = Resource&amp;lt;Episode&amp;gt;(url: URL(string: &amp;quot;/episodes/latest&amp;quot;)!)
    
    private func load&amp;lt;A&amp;gt;(resource: Resource&amp;lt;A&amp;gt;) -&amp;gt; A {
        URLSession.shared.dataTask(with: resource.url)
        // load asynchronously, parse the JSON, etc. For the sake of the example, we directly return an empty result.
        let json: [AnyHashable:Any] = [:] // should come from the server
        return A(json: json)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	The code above might look simpler, but it’s also way less flexible. For example, how would you define a resource that has an array of &lt;code&gt;User&lt;/code&gt; values? (In the protocol-oriented example above, that’s not yet possible, and we’ll have to wait for Swift 4 or 5 until this is expressible). The protocol makes things simpler, but I think it doesn’t pay for itself, because it dramatically decreases the ways in which we can create a &lt;code&gt;Resource&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	Instead of having the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;episode&lt;/code&gt; as &lt;code&gt;Resource&lt;/code&gt; values, we could also make &lt;code&gt;Resource&lt;/code&gt; a protocol and have &lt;code&gt;UserResource&lt;/code&gt; and &lt;code&gt;EpisodeResource&lt;/code&gt; structs. This seems to be a popular thing to do, because having a type instead of a value “just feels right”:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protocol Resource {
    associatedtype Result
    var url: URL { get }
    func parse(json: [AnyHashable:Any]) -&amp;gt; Result
}

struct UserResource: Resource {
    let url = URL(string: &amp;quot;/users/current&amp;quot;)!
    func parse(json: [AnyHashable : Any]) -&amp;gt; User {
        return User(json: json)
    }
}

struct EpisodeResource: Resource {
    let url = URL(string: &amp;quot;/episodes/latest&amp;quot;)!
    func parse(json: [AnyHashable : Any]) -&amp;gt; Episode {
        return Episode(json: json)
    }
}

class Webservice {
    private func load&amp;lt;R: Resource&amp;gt;(resource: R) -&amp;gt; R.Result {
        URLSession.shared.dataTask(with: resource.url)
        // load asynchronously, parse the JSON, etc. For the sake of the example, we directly return an empty result.
        let json: [AnyHashable:Any] = [:]
        return resource.parse(json: json)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	But if we look at it critically, what did we really gain? The code became longer, more complex and less direct. And because of the associated type, we’ll probably end up defining an &lt;code&gt;AnyResource&lt;/code&gt; eventually. Is there any benefit to having an &lt;code&gt;EpisodeResource&lt;/code&gt; struct instead of an &lt;code&gt;episodeResource&lt;/code&gt; value? They are both global definitions. For the struct, the name starts with an uppercase letter, and for the value, a lowercase letter. Other than that, there really isn’t any advantage. You can both namespace them (for autocompletion). So in this case, having a value is definitely simpler and shorter.
&lt;/p&gt;
&lt;p&gt;
	There are many other examples I’ve seen in code around the internet. For example, I’ve seen a protocol like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protocol URLStringConvertible {
    var urlString: String { get }
}

// Somewhere later

func sendRequest(urlString: URLStringConvertible, method: ...) {
    let string = urlString.urlString
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	What does this buy you? Why not simply remove the protocol and pass in the &lt;code&gt;urlString&lt;/code&gt; directly? Much simpler. Or a protocol with a single method:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;protocol RequestAdapter {
    func adapt(_ urlRequest: URLRequest) throws -&amp;gt; URLRequest
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	A bit more controversial: why not simply remove the protocol, and pass in a function somewhere? Much simpler. (Unless your protocol is a class-only protocol and you want a weak reference it).
&lt;/p&gt;
&lt;p&gt;
	I can keep showing examples, but I hope the point is clear. Often, there are simpler choices. More abstractly, protocols are just one way to achieve polymorphic code. There are many other ways: subclassing, generics, values, functions, and so on. Values (e.g. a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;URLStringConvertible&lt;/code&gt;) are the simplest way. Functions (e.g. &lt;code&gt;adapt&lt;/code&gt; instead of &lt;code&gt;RequestAdapter&lt;/code&gt;) are a bit more complex than values, but are still simple. Generics (without any constraints) are simpler than protocols. And to be complete, protocols are often simpler than class hierarchies.
&lt;/p&gt;
&lt;p&gt;
	A useful heuristic might be to think about whether your protocol models data or behavior. For data, a struct is probably easier. For complex behavior (e.g. a delegate with multiple methods), a protocol is often easier. (The standard library’s collection protocols are a bit special: they don’t really describe data, but rather, they describe data manipulation.)
&lt;/p&gt;
&lt;p&gt;
	That said, protocols can be very useful. But don’t start with a protocol just for the sake of protocol-oriented programming. Start by looking at your problem, and try to solve it in the simplest way possible. Let the problem drive the solution, not the other way around. Protocol-oriented programming isn’t inherently good or bad. Just like any other technique (functional programming, OO, dependency injection, subclassing) it can be used to solve a problem, and we should try to pick the right tool for the job. Sometimes that’s a protocol, but often, there’s a simpler way.
&lt;/p&gt;
&lt;h3&gt;
	More
&lt;/h3&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			http://www.thedotpost.com/2016/01/rob-napier-beyond-crusty-real-world-protocols (video)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			http://www.gamedev.net/page/resources/_/technical/game-programming/haskell-game-object-design-or-how-functions-can-get-you-apples-r3204 (Haskell)
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
			</description>
			<pubDate>Thu, 24 Nov 2016 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/protocol-oriented-programming</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/protocol-oriented-programming</guid>
		</item>
		<item>
			<title>On Burnout</title>
			<description>
				&lt;p&gt;
	I’ve seen a number of blogposts and talks recently that talk about depression, burn-out, and other mental problems.  One post recommended reading a book. Another one recommended talking to friends and family. These things might help, but I doubt that they actually solve the root cause (looking back, they definitely didn’t solve my problems, at best suppress them).
&lt;/p&gt;
&lt;p&gt;
	I recommend something different. If you have a mental issue, go see a professional. Take it seriously.  I know there’s a stigma attached to this, let’s try to break through that.
&lt;/p&gt;
&lt;p&gt;
	If your leg is broken, you’d probably go to the hospital. With mental issues, you often don’t visually see that something is wrong. It might feel harder to justify seeing a professional. Some people are functioning very well while suffering from mental problems. For example, I can often turn my suppressed anger into productivity (alas, the anger still gets suppressed).
&lt;/p&gt;
&lt;p&gt;
	It’s scary to take that step. I started seeing a therapist about a year and a half ago, to deal with my depression. It’s been one the best things I’ve ever done for myself. If you’re suffering from a mental issue, consider doing the same.
&lt;/p&gt;
			</description>
			<pubDate>Thu, 27 Oct 2016 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/burnout</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/burnout</guid>
		</item>
	</channel>
</rss>