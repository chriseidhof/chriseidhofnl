<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Chris Eidhof</title>
		<description>
			Personal Blog
		</description>
		<link>http://chris.eidhof.nl</link>
		<atom:link href="http://chris.eidhof.nl/feed.xml" rel="self" type="application/rss+xml"/>
		<item>
			<title>Weeknotes № 48</title>
			<description>
				&lt;p&gt;
	We held two workshops last week, one in PT and one in ET. This meant staying up (quite) late for five days in a row. It always takes some getting used to. But the advantage is that I had lots of daylight time to do other stuff.
&lt;/p&gt;
&lt;p&gt;
	I built a large wooden horse for my daughter. I finally took the time to set up my basement workshop (beyond the essentials). Got my dust collection going, which makes a massive difference (without dust collection, it isn’t much fun to spend longer than a few minutes there).
&lt;/p&gt;
&lt;p&gt;
	After a chat with my friend I moved my SwiftUI in the browser project over to next.js. This took a few days (during which the code didn’t compile). I feel a bit out of my depth in the entire modern web ecosystem, but I’ll manage. The nice thing is that now I can wrap up my functionality in React components, which is definitely an improvement over doing everything by hand.
&lt;/p&gt;
&lt;p&gt;
	I started slightly ramping up my running mileage and am hoping to start another 18-week marathon preparation in about a week from now. This should get me in shape for an April marathon. While it’s not realistic yet to train for a PB (I need a longer and more intensive buildup for that) I think I could aim for a second-best time. It depends a bit on how the next months go, training-wise.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 27 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-48</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-48</guid>
		</item>
		<item>
			<title>Weeknotes № 46-47</title>
			<description>
				&lt;p&gt;
	Here are the combined weeknotes for the last two weeks.
&lt;/p&gt;
&lt;p&gt;
	I visited my friend in London and met up with a bunch of friends. The NSLondon folks were nice enough to organize a drinks night, was great to see many old and new friends. London feels almost like the opposite of where we live (both in good and bad ways). One of my highlights was zipping through the streets in the dark rush hour on a rental E-bike (while being used to driving on the other side of the road). Felt dangerous but lots of fun.
&lt;/p&gt;
&lt;p&gt;
	I made more progress on the SwiftUI web port. I’m starting to write out explanations of modifiers and views. I think in a few weeks we can start on the design work as well. I think I’d like to do the HTML/CSS myself for this one. While I did do lots of front-end web development years ago, I feel quite out of touch with modern front-end development. There are so many new things! I like a lot of it, but the one thing I’m trying to avoid for as long as I can is all those dependencies (bundlers, npm packages, etc.).
&lt;/p&gt;
&lt;p&gt;
	We finished preparing two workshops (one in EST, one in PST, both in a single week). We also started some working on implementing the redesign of objc.io. This has been “ready” (that is, implemented in HTML/CSS) for over half a year, but we hadn’t gotten around to actually integrating it into our main website. So far, we only spent a day on this, but already made considerable progress.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 27 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-47</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-47</guid>
		</item>
		<item>
			<title>Weeknotes № 44</title>
			<description>
				&lt;p&gt;
	The first half of last week I was still away, so nothing much happened.
&lt;/p&gt;
&lt;p&gt;
	The second half of the week we started preparing two more workshops. We prepare each workshop specifically for the company we teach, so it’s always quite a bit of work. We believe it’s useful for the company we work with (as they work on problems directly related to their day-to-day work). Oftentimes, we also learn something ourselves.
&lt;/p&gt;
&lt;p&gt;
	In the odd hour I had available I worked on improving the SwiftUI layout port to the web. I think I’ve got enough of the SwiftUI part implemented, now it’s time to see how we can use this to create better explanations.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 06 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-44</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-44</guid>
		</item>
		<item>
			<title>Weeknotes № 45</title>
			<description>
				&lt;p&gt;
	On Monday I was excited to finally have a regular week of work again without any travel or other big things. Little did I know. On Monday we all got really sick. It knocked the whole family out for multiple days.
&lt;/p&gt;
&lt;p&gt;
	In the end, I did get a few days of solid work in last week. After finishing the projects we’ll build for our workshops, we split those up into individual exercises and write all the descriptions. We’ve gotten a lot more efficient at this, but it still takes a few iterations per workshop, even now.
&lt;/p&gt;
&lt;p&gt;
	I also went and cleaned up a little bit of the Workshop app (our Mac app that the attendees use). I added a few small features. For example, all examples have live previews, I added support for better resizing that feels more native on the Mac. We have “fake” simulators in the app that show the solution in context, and I improved some of our fake iOS components (e.g. our simulation of a navigation view).
&lt;/p&gt;
&lt;p&gt;
	In the evenings I kept tinkering with my web port of SwiftUI’s layout. Text layout now behaves almost exactly as SwiftUI’s Text view (which is based on CTFrameSetter). I added support for dark mode, and support to visualize a view’s origin and size. I added variables that allow you to change values in the source code by dragging them (similar to Bret Victor’s demos). There are so many more possibilities, but of course, my goal is for the end result to be very simple. So far TypeScript has really delivered on its promise, I feel confident making both small and large refactorings and having the type checker guide me through it.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 06 Nov 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-45</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-45</guid>
		</item>
		<item>
			<title>Weeknotes № 43</title>
			<description>
				&lt;p&gt;
	I think a lot of Apple’s documentation could be improved. For example, I think SwiftUI’s layout system could be explained in a much better way. We try to do so in our workshops and books, but I think interactive explanations on a public website would be even better. A few years ago we reimplemented large parts of SwiftUI’s layout system in Swift. I started porting this to Javascript.
&lt;/p&gt;
&lt;p&gt;
	While in The Netherlands, I also met up with my friends from university. We had a very close-knit group of students during our Master’s and ended up all going super deep on Haskell and functional programming. When everyone at the table immediately recommended I switch to TypeScript I took their word for it. The switch was &lt;em&gt;so&lt;/em&gt;
	 worth it.
&lt;/p&gt;
&lt;p&gt;
	I installed the TypeScript compiler and VS Code. I also (based on my friends’ recommendations) enabled copilot and had such an incredibly productive time. I don’t have to worry too much about my implementation’s performance or feature-completeness, as the goal is to only use this for teaching. I just focus on adding the subset of views that I want to explain and make sure they behave in exactly the same way as the real SwiftUI does. Luckily, we have already done most of the hard work in Swift, I only need to port it. I currently have stacks, frames, shapes, padding, background/overlay, images, geometry readers and a basic version of text working.
&lt;/p&gt;
&lt;p&gt;
	There are a bunch of things missing before we can release this in some form. It needs better pretty printing (generating the code from the views), tracing (so that we can show the layout process), design (the surrounding explanations need to have at least some kind of design that goes beyond the browser’s default Times font).
&lt;/p&gt;
			</description>
			<pubDate>Mon, 30 Oct 2023 00:00:00 +0100</pubDate>
			<link>http://chris.eidhof.nl/post/2023-43</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-43</guid>
		</item>
		<item>
			<title>Weeknotes № 42</title>
			<description>
				&lt;p&gt;
	Still on my time off. We’re away in a holiday park, so I’m keeping the laptop mostly shut. I’ve done a tiny bit of work at the beginning of the week, hopefully I can share some of that soon. Mainly writing this post as to not break the streak.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 23 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-42</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-42</guid>
		</item>
		<item>
			<title>Weeknotes № 41</title>
			<description>
				&lt;p&gt;
	As a short break from my time off, we ran a workshop last week. I also took the opportunity to finally (after we moved in a few months ago) get my desk set up. I switched the saw horses for my standing desk base, added cable management and brought out all the gear I use when running a workshop: proper lighting, DSLR mount, HDMI converter, and so on. (It turned out my micro HDMI cable broke and I had to use my phone as a camera instead).
&lt;/p&gt;
&lt;p&gt;
	Because we ran the workshop in PST, we had to stay up quite late (I’m an early riser and not much of an evening person by default). A few days before these PST workshops I’ll start by adjusting my rhythm. The hardest part for me is sleeping in — even though I’m tired, I can’t help but wake up early. The other weird thing is my energy level throughout the day: I’m typically very awake early in the morning and get progressively more tired during the day. This kind of felt the other way around.
&lt;/p&gt;
&lt;p&gt;
	During the workshop, one of the attendees mentioned that it was nice to actually work on getting a very simple view to be pixel-perfect. In their own app, they often blame things on the complexity of their app, whereas here it’s just a few small components and there’s no hiding behind complexity. It also made me feel that, as iOS developers writing SwiftUI, any time invested in understanding SwiftUI is very well spent. We’ll probably be using this framework every single day for the next ten years or longer, any investment we make now will probably pay off many times over.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 16 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-41</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-41</guid>
		</item>
		<item>
			<title>Weeknotes № 40</title>
			<description>
				&lt;p&gt;
	I’m taking some time off this month to focus on the family and get the final home improvement bits done before winter is here. I am working on some small side-projects and we will run a workshop this week.
&lt;/p&gt;
&lt;p&gt;
	One of the things I experimented with is a generic programming library. This allows you to view your structs and enums as sums of products, and makes it relatively easy to write algorithms that operate on the structure of these types. For example, I’ve written a binary encoder/decoder, a method that generates a simple SwiftUI view for a type, a method that generates an editor (form) for a type, and a bunch more. I’m currently trying a few different approaches and am planning to blog a bit more about this soon. If you’re interested, &lt;a href=&quot;https://github.com/chriseidhof/generic-programming-tests&quot;&gt;here’s a repo&lt;/a&gt; with some of my experiments.
&lt;/p&gt;
&lt;p&gt;
	In the typing recorder project that I wrote about in previous weeknotes, I started with a simple enum-based model layer. I was too lazy to make my model values &lt;code&gt;Identifiable&lt;/code&gt; but just had an array of enum values with the array index as the identifier. As always, this came back to haunt me. I finally changed my representation to include a stable identifier. This would have been much less work if I had done it from the beginning.
&lt;/p&gt;
&lt;p&gt;
	I went for a quick dip in the lake after my long run on Sunday — it’s doable, but far from comfortable. Part of me wants to keep doing that, but I’m not sure how long I’ll last this year.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 09 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-40</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-40</guid>
		</item>
		<item>
			<title>Weeknotes № 39</title>
			<description>
				&lt;p&gt;
	We shipped &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt; last week! It’s now available in PDF and print. We’re very happy with the result (and open for suggestions, of course).
&lt;/p&gt;
&lt;p&gt;
	One thing that’s currently missing which we might add (depending on how hard it is) is an ePub version. Without having implemented it, it’s a bit hard to predict how much work this is. I’m sure we can get an 80% solution in a few days, but actually shipping it will definitely be harder.
&lt;/p&gt;
&lt;p&gt;
	My typing recording app is seeing some good progress. I’ve been bitten once again by the fact that I prototyped something without making my model values conform to &lt;code&gt;Identifiable&lt;/code&gt;. I stored them in an array and just used the array index as the identity. This works fine for a while, but will always come back to haunt you.
&lt;/p&gt;
&lt;p&gt;
	We’ve also been busy with preparing new workshops. We updated the content in our workshop app to reflect what we learned from writing the book, and are also preparing some client-specific exercises.
&lt;/p&gt;
&lt;p&gt;
	At home, we started some work on renovating the exterior walls. Big holes were cut to allow for new windows and larger windows. We had to reinsulate some parts, add corner rails for the plastering, and all kinds of other small jobs I’d never done before. In the end, none of it is very hard, but it all takes a while to figure out. The hardest part for me is that I don’t know how to do things the right way, both at a theoretical level (what insulation or products do I use) and at a practical level (how do I make sure this is attached correctly). YouTube can help a lot but is no replacement for actual experience and expertise.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 02 Oct 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-39</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-39</guid>
		</item>
		<item>
			<title>Weeknotes № 38</title>
			<description>
				&lt;p&gt;
	Last week we recorded a bunch of episodes around building a small marquee component. We wanted to make it interactive (similar to a scroll view) which makes the underlying implementation a bit different from how you would normally write SwiftUI components. The animations are driven by a &lt;code&gt;TimelineView&lt;/code&gt; so we can also easily do some math around the gesture velocity.
&lt;/p&gt;
&lt;p&gt;
	We also got our proof copy of the print book, so close to release now. We made a few final adjustments to this as well.
&lt;/p&gt;
&lt;p&gt;
	In the evenings I spent some more time on my recording app. I hope to use it for a presentation next week (not sure yet if the presentation will happen). My goal is to make it very easy for me to make these kind of interactive text animations so that I can easily prototype and ship high-quality code animations. I’m currently mostly just trying to get that recording workflow perfect.
&lt;/p&gt;
&lt;p&gt;
	I swam a bunch more, also with a wetsuit (it’s not necessary yet, just to try what it’s like). I feel like my fear of open-water swimming is definitely getting a lot less. As always, one of the best ways to deal with fear is confronting it, which is definitely working in this case.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 25 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-38</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-38</guid>
		</item>
		<item>
			<title>Weeknotes № 37</title>
			<description>
				&lt;p&gt;
	Last week we finalized the layout for Thinking in SwiftUI. Now we need to check the (print) proof copy and verify everything is okay before we can finally release it! I also spent some more time on my typing recorder app, it’s really starting to take shape. Hopefully I can demo it soon.
&lt;/p&gt;
&lt;p&gt;
	I spent another day working on better understanding and analyzing what’s happening with &lt;code&gt;UIViewRepresentable&lt;/code&gt; and state, and typed these notes up into &lt;a href=&quot;http://chris.eidhof.nl/post/view-representable&quot;&gt;a blog post&lt;/a&gt;. After some initial confusion around processing multiple events (both from people who read it as well as myself) I also added some more explanations and diagrams to that post. Being able to quickly embed SwiftUI views in posts is starting to pay off, it’s almost no extra work. I’d like to look into how to do layout with view representables as well. Not sure yet how to tackle that and what use cases exist, but we’ll find out!
&lt;/p&gt;
&lt;p&gt;
	I also ran a race on Saturday which was pretty tough! After about half a minute I was in second position and it stayed that way throughout the race. I lost contact with the winner very quickly. Even throughout the half-way point he just kept on increasing the lead which ultimately was a little bit demotivating. I still enjoyed the running, I just wasn’t motivated to really push hard.
&lt;/p&gt;
&lt;p&gt;
	After the race there was a nice clear lake to swim in (a five minute walk from the finish line). Yesterday, I swam with a friend (so much more fun than swimming alone). We swam across our local lake and back, making it my farthest swim yet.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 18 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-37</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-37</guid>
		</item>
		<item>
			<title>Working With UIViewRepresentable</title>
			<description>
				&lt;p&gt;
	When we work with SwiftUI, we can always drop down to UIKit level by using &lt;code&gt;UIViewRepresentable&lt;/code&gt;, &lt;code&gt;NSViewRepresentable&lt;/code&gt; or &lt;code&gt;UIViewControllerRepresentable&lt;/code&gt;. The documentation around these protocols is still pretty sparse, and it can be hard to get them to work exactly the way we want. I tried to come up with some rules and patterns for using them. These patterns are &lt;em&gt;not&lt;/em&gt;
	 final, if you have feedback about missing things or mistakes, please let me know.
&lt;/p&gt;
&lt;p&gt;
	There are a few different challenges. In this article, I want to focus on communicating state between SwiftUI and UIKit/AppKit. Communication can happen in either direction: we’ll need to update our &lt;code&gt;UIView&lt;/code&gt; when SwiftUI’s state changes, and we’ll need to update our SwiftUI state based on UIView changes.
&lt;/p&gt;
&lt;p&gt;
	Here are two rules for working with representables. (&lt;a href=&quot;https://www.cocoawithlove.com&quot;&gt;Matt&lt;/a&gt; helped me with this, thank you):
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			When updating a UIView in response to a SwiftUI state change, we need to go over all the representable’s properties, but only change the UIView properties that need it.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			When updating SwiftUI in response to a UIKit change, we need to make sure these updates happen asynchronously.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	If we don’t follow these rules, there are a few issues we might see:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			The dreaded “Modifying state during view update, this will cause undefined behavior” warning
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Unnecessary redraws of our &lt;code&gt;UIViewRepresentable&lt;/code&gt;, or even infinite loops
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Strange behavior where the state and the view are a little bit out of sync
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	In my testing, these issues are becoming less relevant with UIKit, but are very relevant when dealing with AppKit. My guess is that UIKit components have seen some internal changes to make writing view representables simpler. However, as we’ll see, this isn’t the case for every UIKit view.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Building a MapView wrapper&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	MapKit’s &lt;code&gt;Map&lt;/code&gt; view for SwiftUI used to be very limited, and a popular target for wrapping in a representable. As of iOS 17 it gained a lot of new capabilities, but we’ll still use it as our first example.
&lt;/p&gt;
&lt;p&gt;
	We’ll be writing a simple wrapper that takes a binding to the map view’s center coordinate. As a first step, we’ll create an &lt;code&gt;MKMapView&lt;/code&gt; and set the delegate to be our coordinator.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct HybridMap: UIViewRepresentable {
    @Binding var position: CLLocationCoordinate2D

    // ...

    func makeUIView(context: Context) -&amp;gt; MKMapView {
        let view = MKMapView()
        view.delegate = context.coordinator
        view.preferredConfiguration = MKHybridMapConfiguration()
        return view
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	For the coordinator, there is a nice technique to pass in all properties of &lt;code&gt;HybridMap&lt;/code&gt; directly (this is especially useful when we have more than one property). You can simply pass a copy of &lt;code&gt;self&lt;/code&gt;, as &lt;code&gt;HybridMap&lt;/code&gt; is a struct:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;// ...
class Coordinator: NSObject, MKMapViewDelegate {
    var parent: HybridMap
    init(parent: HybridMap) {
        self.parent = parent
    }

    func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
        parent.position = mapView.centerCoordinate
    }
}

func makeCoordinator() -&amp;gt; Coordinator {
    Coordinator(parent: self)
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Finally, here’s our &lt;code&gt;updateUIView&lt;/code&gt; method:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    context.coordinator.parent = self
    view.centerCoordinate = position
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can now create a simple view with a state property for the position:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let initialPosition = CLLocationCoordinate2D(latitude: 52.518611, longitude: 13.408333)

struct ContentView: View {
    @State private var position = initialPosition

    var body: some View {
        VStack {
            Text(&amp;quot;\(position.latitude) \(position.longitude)&amp;quot;)
            Button(&amp;quot;Reset Position&amp;quot;) { position = initialPosition }
            HybridMap(position: $position)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we launch the above app, we’ll immediately get a runtime warning: “Modifying state during view update, this will cause undefined behavior.”. To debug this, we can add print statements to the beginning and ending of both our &lt;code&gt;updateUIView&lt;/code&gt; as well as &lt;code&gt;mapViewDidChangeVisibleRegion&lt;/code&gt; methods:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    print(&amp;quot;Begin updateUIView&amp;quot;, position)
    defer { print(&amp;quot;End updateUIView&amp;quot;) }
    context.coordinator.parent = self
    view.centerCoordinate = position
}
// ...
func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
    print(&amp;quot;Begin didChange&amp;quot;, mapView.centerCoordinate)
    defer { print(&amp;quot;End didChange&amp;quot;) }
    parent.position = mapView.centerCoordinate
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we launch the app, we get the following print statements:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Begin updateUIView CLLocationCoordinate2D(latitude: 52.518611, longitude: 13.408333)
End updateUIView
Begin didChange CLLocationCoordinate2D(latitude: 51.117027, longitude: 10.333652000000006)
End didChange
Begin didChange CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
End didChange
Begin updateUIView CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
Begin didChange CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
[SwiftUI] Modifying state during view update, this will cause undefined behavior.
End didChange
End updateUIView
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Here’s what happens: first, the view is rendered and put on screen. After that, the &lt;code&gt;didChange&lt;/code&gt; runs. We can see that map views don’t store their center coordinate directly, my guess is that they only store the visible region as their source of truth. This is why the values in the print statements are different from our initial value. Towards the end, we see that a &lt;code&gt;didChange&lt;/code&gt; runs from within our &lt;code&gt;updateUIView&lt;/code&gt; method, updating our SwiftUI state. This causes the “Modifying state” error.
&lt;/p&gt;
&lt;p&gt;
	As far as I know, the only reliable way I know of to get rid of this warning is by doing this state change asynchronously. The simplest way is by enqueueing another block on the main queue:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
    DispatchQueue.main.async {
        self.parent.position = mapView.centerCoordinate
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This makes the runtime warning go away. However, we can’t drag the map anymore, after a single drag movement it halts. There is one more step left to make this representable work:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    context.coordinator.parent = self
    if view.centerCoordinate != position {
        view.centerCoordinate = position
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	By only doing the view update when necessary we’re not triggering another &lt;code&gt;didChange&lt;/code&gt;. Both of these changes are specific instances of the rules at the beginning of the article:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			We need to change our SwiftUI state asynchronously in response to UIKit changes.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We need to only update properties of UIKit views when absolutely necessary
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Building a Text View wrapper&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	As a second example, we’ll build an &lt;code&gt;NSTextView&lt;/code&gt; wrapper. My goal is to write a &lt;code&gt;MyTextView&lt;/code&gt; component that takes a binding for both the text and the selected range. This is for the Mac, so we’ll be using &lt;code&gt;NSView&lt;/code&gt; instead of &lt;code&gt;UIView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	Here’s the (broken) initial version, with a structure very similar to our map view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyTextView: NSViewRepresentable {
    @Binding var text: String
    @Binding var selection: NSRange

    final class Coordinator: NSObject, NSTextViewDelegate {
        var parent: MyTextView
        unowned var textView: NSTextView!
        init(parent: MyTextView) {
            self.parent = parent
        }

        func textDidChange(_ notification: Notification) {
            self.parent.text = textView.string
        }

        func textViewDidChangeSelection(_ notification: Notification) {
            self.parent.selection = textView.selectedRange()
        }
    }

    func makeCoordinator() -&amp;gt; Coordinator {
        Coordinator(parent: self)
    }

    func makeNSView(context: Context) -&amp;gt; NSTextView {
        let t = NSTextView()
        context.coordinator.textView = t
        t.delegate = context.coordinator
        return t
    }

    func updateNSView(_ t: NSTextView, context: Context) {
        t.textStorage?.setAttributedString(text.highlight())
        t.selectedRanges = [.init(range: selection)]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we run the example above, we can see that we get the dreaded “Modifying state during view update, this will cause undefined behavior” warning. This happens because when we set the attributed string from within &lt;code&gt;updateNSView&lt;/code&gt;, the text view will fire a &lt;code&gt;textViewDidChangeSelection&lt;/code&gt; notification. This notification isn’t posted asynchronously, but actually does happen during the &lt;code&gt;updateNSView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updating SwiftUI in Response to an NSView Change&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	Similar to the map view, we can now wrap our update by enqueueing it on the main queue:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func textViewDidChangeSelection(_ notification: Notification) {
    let r = self.textView.selectedRange()
    DispatchQueue.main.async {
        self.parent.selection = r
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Unfortunately, things are still broken: we don’t get a runtime warning anymore, but the cursor behaves weirdly. (The insertion point is rendered at the start of the current selection whenever the length of the selection is zero).
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updating an NSView in Response to a SwiftUI State Change&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	In principle, this is simple. Whenever something changes, SwiftUI will call &lt;code&gt;updateNSView(:context:)&lt;/code&gt;. However, we don’t know &lt;em&gt;what&lt;/em&gt;
	 changed, it could be any number of properties. In the above implementation, we simply set the two properties, but that’s not enough.
&lt;/p&gt;
&lt;p&gt;
	In our update method, we should take care to inspect each property, but only set the corresponding &lt;code&gt;NSView&lt;/code&gt; value if it’s really necessary. For example:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateNSView(_ t: NSTextView, context: Context) {
    context.coordinator.parent = self
    if t.string != text {
        t.textStorage?.setAttributedString(text.highlight())
    }
    if t.selectedRange() != selection {
        t.selectedRanges = [.init(range: selection)]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This solves almost all our problems. However, there is still a weird issue. When I’m typing at the end of the text field, some characters get inserted just before the last character, instead of at the end.
&lt;/p&gt;
&lt;p&gt;
	Here’s what happens (bear with me):
&lt;/p&gt;
&lt;p&gt;
	When I type a character at the end of the string, the selection changes. A &lt;code&gt;self.parent.setSelection…&lt;/code&gt; is enqueued. The main queue now looks like this:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/1-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/1.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Before that runs, however, the text is updated, and &lt;code&gt;updateNSView&lt;/code&gt; happens. It will set the attributed string, which in turn causes the selection to change, which adds another &lt;code&gt;setSelection&lt;/code&gt; to the queue (with the old selection value). The main queue now looks like this:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/3-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/3.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	The main queue then runs the first (correct) block to set the selection, and then the second (incorrect) block.
&lt;/p&gt;
&lt;p&gt;
	To keep the order of events correct, this means we also have to enqueue the changing of our text. That way, all events will happen in the order we expect:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func textDidChange(_ notification: Notification) {
    let str = textView.string
    DispatchQueue.main.async {
        self.parent.text = str
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This is tricky to find and tricky to debug. A simple rule of thumb would be that once we start enqueueing one change asynchronously, we probably need to do all of the other updates asynchronously as well.
&lt;/p&gt;
&lt;p&gt;
	Now, when the user types a character, the following happens. First, the selection event is enqueued:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/5-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/5.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Then, the text setting event is enqueued:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/7-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/7.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	The main queue is a first-in, first-out serial queue. During the next iteration of the run loop, the first block runs while the other is still in the queue:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/9-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/9.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Because the &lt;code&gt;setSelection&lt;/code&gt; changes the internal SwiftUI view, the view is marked as needing to redraw. This causes the &lt;code&gt;updateView&lt;/code&gt; to be enqueued:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/11-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/11.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	After the &lt;code&gt;setSelection&lt;/code&gt; block is done, the &lt;code&gt;setText&lt;/code&gt; is removed from the queue:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/13-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/13.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	This &lt;code&gt;setText&lt;/code&gt; also wants the view to redraw. However, because the view is already flagged as “dirty” by the &lt;code&gt;setSelection&lt;/code&gt; block, no further block will be enqueued. So after &lt;code&gt;setText&lt;/code&gt; runs, the queue looks like this:
&lt;/p&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/view-representable/15-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/view-representable/15.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Then the &lt;code&gt;updateView&lt;/code&gt; runs and because we have the if-conditions in our method, no further changes will happen. So in practice, even though we enqueued multiple blocks asynchronously, these got coalesced into a single &lt;code&gt;updateView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More Issues and Gotchas&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	As mentioned, we need to check each property in &lt;code&gt;updateNSView(:context:)&lt;/code&gt; and make sure to only update the &lt;code&gt;NSView&lt;/code&gt; when it’s really needed. This relies on us being able to compare values.  Sometimes this isn’t possible. For example, when dealing with the map view, we saw that the center coordinate conversion is lossy. In the cases where we can’t read out the current value, we can cache each value that we set. Inside our coordinator, we could add a helper like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;private var previousValues: [String: Any] = [:]
func setIfNeeded&amp;lt;Value: Equatable&amp;gt;(value: Value, name: String, update: (NSTextView) -&amp;gt; ()) {
    if let previous = previousValues[name] as? Value, previous == value {
        return
    }
    previousValues[name] = value
    update(textView)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we set the new value, we first check whether or not we’ve previously set this value. Only if it’s different, we proceed to update the underlying platform view. In a way, this is similar to SwiftUI’s &lt;code&gt;onChange(of:)&lt;/code&gt; modifier (only run the closure when something changed).
&lt;/p&gt;
&lt;p&gt;
	Similarly, when we want to start animations in SwiftUI, we’ll need to have some kind of state, and our coordinator needs to track when that state changes and only start a new animation then. You could use a method similar to &lt;code&gt;setIfNeeded&lt;/code&gt; to achieve this.
&lt;/p&gt;
&lt;p&gt;
	Sometimes, we want to communicate events back from an NSView to SwiftUI. If the event modifies a value, we could simply modify the corresponding binding. For example, if the event would be &lt;code&gt;scrollViewDidScroll&lt;/code&gt;, we can change the &lt;code&gt;scrollPosition&lt;/code&gt; binding. However, for other events it’s more appropriate to just call a closure (this is what &lt;code&gt;Button&lt;/code&gt; does each time the user taps). Of course, this closure could have parameters as well.
&lt;/p&gt;
&lt;p&gt;
	I’m sure there are many more issues when doing this in practice, if you have any feedback or comments I’d love to hear about it.
&lt;/p&gt;
&lt;p&gt;
	If you want to learn more about SwiftUI, check out our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updates&lt;/strong&gt;
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			After some discussion on Mastodon (and some research) I added a section on multiple events (which includes the main queue diagrams).
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
			</description>
			<pubDate>Wed, 13 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/view-representable</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/view-representable</guid>
		</item>
		<item>
			<title>Weeknotes № 36</title>
			<description>
				&lt;p&gt;
	It feels like last week was the last warm week of summer, and so as a family, we took advantage of that every afternoon and went swimming in one of the lakes nearby. Our new house is a short walk to one of those lakes, and one of my dreams since we moved here half a year ago was swimming across the lake. I’ve been swimming all my life, but never any long distances or with good technique.
&lt;/p&gt;
&lt;p&gt;
	On Wednesday I saw the calm water, hot sun and no boats so I decided on a whim that this was the day. Armed with goggles and a tow float I decided to swim across. The unknown of it was pretty scary for me (which did give me a nice speed boost). It’s a large lake, there are boats, I might cramp up or unknown other stuff might happen. In the end, it took less than ten minutes to swim across. After only two minutes my elastic watch strap came loose, so I had to change to breast stroke until I figured out I could just shove my watch all the way up to my elbow. Those ten minutes felt a lot longer than normal!
&lt;/p&gt;
&lt;p&gt;
	I swam across another time a few days later (in eight minutes), wearing a cap as well (for visibility). My last swimming lesson was thirty years ago, and the freestyle part I never learned was that, most of the time, your face is below the surface. You basically only tilt your head out of the water a bit to get in some fresh air and then continue, looking down towards the bottom. For some reason this is pretty scary to me as well, even more so in a very clear lake. But after a few more “longer” swims I’m starting to get used to it. Next season, I’d love to build up to really long swims, maybe crossing the lake length-wise.
&lt;/p&gt;
&lt;p&gt;
	Florian was away last week, I worked on the “typing recorder” app that I plan to use to record myself typing and play back in a smooth way (for presentations, workshops and videos). As part of this, I needed to do another &lt;code&gt;NSViewRepresentable&lt;/code&gt; implementation for &lt;code&gt;NSTextField&lt;/code&gt;. I had yet another one of these “Modifying state during view update” runtime warnings and decided it was time to fully understand these. I’ve written down a bunch of notes already that I hope to turn into a blog post soon.
&lt;/p&gt;
&lt;p&gt;
	We finalized the copy editing for &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;, &lt;a href=&quot;http://www.natalye.com&quot;&gt;Natalye&lt;/a&gt; went through the last bunch of edits so now it’s time to typeset everything. We’ll need to do this once for print and once for the PDF version.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 11 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-36</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-36</guid>
		</item>
		<item>
			<title>Weeknotes № 35</title>
			<description>
				&lt;p&gt;
	We finally recorded the final bits of our &lt;a href=&quot;https://talk.objc.io/episodes/S01E366-building-keyframe-animations-part-1&quot;&gt;keyframe reimplementation&lt;/a&gt;, including a Catmull-Rom implementation that turned out to be extremely simple and matches exactly what SwiftUI does. I’ve used our reimplementation in a macOS 13 app successfully.
&lt;/p&gt;
&lt;p&gt;
	We also went over the entire &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;book&lt;/a&gt; and made it ready for a final copy-editing pass. The next steps after that is to do a little bit of typesetting for the PDF version and possible a bit more for the printed version. Then we can release it!
&lt;/p&gt;
&lt;p&gt;
	I’ve been playing around with a new project that lets me record me typing code and then replay it in a smoother and animated way. This should be useful for making videos and when giving presentations (in SwiftUI).
&lt;/p&gt;
&lt;p&gt;
	Last week, &lt;a href=&quot;https://www.swiftconf.to&quot;&gt;Swift TO&lt;/a&gt; released the videos of all the presentations. I created an annotated version of my presentation &lt;a href=&quot;http://chris.eidhof.nl/presentations/day-in-the-life&quot;&gt;A Day in the Life of a SwiftUI View&lt;/a&gt;. This definitely took a few hours here and there, but hopefully it’s useful to those of you that don’t want to or can’t watch videos.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 04 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-35</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-35</guid>
		</item>
		<item>
			<title>Running Code When Your View Appears</title>
			<description>
				&lt;p&gt;
	When you’re writing SwiftUI views, you definitely don’t want to run expensive tasks in the view’s initializer, as it might get called very often. Also, since the view doesn’t have structural identity yet when the initializer runs, you can’t reliably store data. Instead, you want to load data in the view’s body before the view will be drawn on screen.
&lt;/p&gt;
&lt;p&gt;
	You can achieve this with &lt;code&gt;.task&lt;/code&gt; or &lt;code&gt;.onAppear&lt;/code&gt;. The &lt;code&gt;onAppear&lt;/code&gt; modifier has been around since the beginning. It takes a regular closure that is called whenever the view appears on screen
&lt;sup&gt;&lt;a href=&quot;#fnref1&quot; name=&quot;fnref-rev1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
. The &lt;code&gt;task&lt;/code&gt; modifier supports async/await without you having to create a manual &lt;code&gt;Task&lt;/code&gt;. The task also gets cancelled automatically when the view disappears.
&lt;/p&gt;
&lt;p&gt;
	Because &lt;code&gt;task&lt;/code&gt; can do anything that &lt;code&gt;onAppear&lt;/code&gt; can, is there still any reason to use &lt;code&gt;onAppear&lt;/code&gt;? Or can we just move to &lt;code&gt;task&lt;/code&gt;? At first, I thought the two are the same, it seems like &lt;code&gt;task&lt;/code&gt; is built on top of &lt;code&gt;onAppear&lt;/code&gt;. There is a small difference, however (which might be an essential difference depending on how you use it). Consider the following view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct ContentView: View {
    @State private var color0 = Color.red
    @State private var color1 = Color.red
    var body: some View {
        VStack {
            color0
            color1
        }
        .onAppear { color0 = .green }
        .task { color1 = .green }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When you launch this app, you can see that the topmost view in the &lt;code&gt;VStack&lt;/code&gt; never renders in red, whereas the bottom view quickly flickers red before turning green. If you can’t see it, you can use QuickTime to create a screen recording and verify it that way.
&lt;/p&gt;
&lt;blockquote&gt;
	&lt;p&gt;
		We first noticed this behavior when implementing our own version of AsyncImage. We wanted to take a cached image, but when you use &lt;code&gt;task&lt;/code&gt;, you’ll always see the placeholder.
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
	When you use &lt;code&gt;onAppear&lt;/code&gt; or &lt;code&gt;onPreferenceChange&lt;/code&gt; (possibly more modifiers), SwiftUI can execute your code before it even renders a single frame. Initially, the body executes, calls &lt;code&gt;onAppear&lt;/code&gt; and then runs the closure inside &lt;code&gt;onAppear&lt;/code&gt;. If this changes any state, the body is re-rendered before the view is even drawn on screen.
&lt;/p&gt;
&lt;p&gt;
	I’m not sure why task behaves differently and if the source of this “problem” is with SwiftUI or the concurrency system. I’m not sure if it’s meant to be or considered a bug, but at least, at this moment in time, it does work differently.
&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
	&lt;hr/&gt;
	&lt;ol&gt;
		&lt;li id=&quot;fnref1&quot;&gt;
			&lt;p&gt;
				The closure is called at least once when the view appears, but can also be called multiple times. For example, when the view is in a scroll view or a tab bar, the closure gets called each time the view becomes visible.
				 &lt;a href=&quot;#fnref-rev1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
			</description>
			<pubDate>Thu, 31 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/swiftui-on-appear-vs-task</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/swiftui-on-appear-vs-task</guid>
		</item>
		<item>
			<title>How To Visualize The Safe Area</title>
			<description>
				&lt;p&gt;
	When we draw a SwiftUI view on screen, it only fills the safe area by default. For example, here we can see a yellow rectangle that fills the safe area, but leaves white space at the top and bottom of the screen.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;Rectangle()
    .fill(Color.yellow)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/1-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/1.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	We can change this behavior by adding the &lt;code&gt;.ignoresSafeArea&lt;/code&gt; modifier:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;Rectangle()
    .fill(Color.yellow)
    .ignoresSafeArea()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/3-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/3.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	When the layout happens, the safe area insets are passed around to all the views that do layout. Whenever a border of a view marked with &lt;code&gt;ignoresSafeArea&lt;/code&gt; touches the edge of the safe area, it will extend itself. For example, in the following view, the yellow color extends to the top but not to the bottom, as expected:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;VStack {
    Color.yellow
        .ignoresSafeArea()
    Text(&amp;quot;Hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/5-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/5.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	We can also make the safe area smaller (increase the insets) using a number of different modifiers. The &lt;code&gt;safeAreaInset&lt;/code&gt; (available since iOS 15) allows us to add to the non-safe area. The yellow color will now respect the safe area, but can also use the &lt;code&gt;ignoresSafeArea&lt;/code&gt; modifier to display beyond the safe area.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;VStack {
    Color.yellow
    Text(&amp;quot;Hello&amp;quot;)
}
.safeAreaInset(edge: .leading) {
    Color.clear.frame(width: 20)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/7-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/7.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Insetting a view’s safe area with another view is not the same as placing the the views next to each other. For example, when we add a bottom safe area inset to a scroll view, the scroll view will draw itself behind that inset but also lets the user scroll so that all the content is visible:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;myScrollView
    .safeAreaInset(edge: .bottom) {
        Text(&amp;quot;This is my bottom view&amp;quot;)
            .frame(height: 100)
            .frame(maxWidth: .infinity)
            .background(Material.regular)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/9-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/9.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	One of the interesting things is that we can visualize the safe area using an overlay and a geometry reader. We can add &lt;code&gt;ignoresSafeArea&lt;/code&gt; to the geometry reader. Inside the geometry reader, we get access to the size of the safe area insets as well as the safe area size itself:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension View {
    func visualizeSafeArea() -&amp;gt; some View {
        overlay {
            GeometryReader { proxy in
                ZStack {
                    VStack(spacing: 0) {
                        Color.yellow
                            .frame(height: proxy.safeAreaInsets.top)
                        Color.clear
                            .frame(height: proxy.size.height)
                        Color.red
                            .frame(height: proxy.safeAreaInsets.bottom)
                    }
                    HStack(spacing: 0) {
                        Color.green
                            .frame(width: proxy.safeAreaInsets.leading)
                        Color.clear
                            .frame(width: proxy.size.width)
                        Color.blue
                            .frame(width: proxy.safeAreaInsets.trailing)
                    }
                }
                .opacity(0.5)
                .ignoresSafeArea()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Using the helper above, we can now visualize the safe area insets for any view. For example, let’s consider a gray rectangle that fills the safe area. We can see the yellow indicating the top safe area insets and the red indicating the bottom safe area insets:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;Rectangle()
    .fill(Color.gray)
    .visualizeSafeArea()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/11-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/11.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	It’s interesting to play around with this helper, applying it at different points in the view hierarchy. It helped me gain a good understanding of how the safe area behaves and how to modify it for my own needs.
&lt;/p&gt;
&lt;p&gt;
	As always, if you’re interested how SwiftUI works below the hood, check out our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;. In fact, this post was inspired by &lt;a href=&quot;https://github.com/objcio/thinking-in-swiftui-qa/issues/19&quot;&gt;a question&lt;/a&gt; from Ayman that we answered in our &lt;a href=&quot;https://github.com/objcio/thinking-in-swiftui-qa&quot;&gt;weekly Q&amp;amp;A&lt;/a&gt;.
&lt;/p&gt;
			</description>
			<pubDate>Wed, 30 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/visualize-swiftui-safe-area</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/visualize-swiftui-safe-area</guid>
		</item>
		<item>
			<title>Weeknotes № 34</title>
			<description>
				&lt;p&gt;
	Last week we prepared and recorded &lt;a href=&quot;https://talk.objc.io/episodes/S01E369-cubic-bezier-keyframes-part-1&quot;&gt;more episodes&lt;/a&gt; about our SwiftUI keyframe reimplementation effort. I also worked on getting closer to the Catmull-Rom version that SwiftUI has implemented, but I’m not quite there yet. It’s close enough to be unnoticable, but I always feel like pushing that extra bit to get 100% accurate is somehow worth it when trying to understand how things work.
&lt;/p&gt;
&lt;p&gt;
	We replaced our old blender at home (it broke over a year ago), so I’ve been on a bit of a smoothie trip, making all kinds of combinations (spinach/banana/ginger is one of my favorites). I also finally made gazpacho again: almost everything (except for the stale bread) came directly from the garden. Absolutely delicious.
&lt;/p&gt;
&lt;p&gt;
	Towards the end of the week we started integrating the iOS 17 chapter of Thinking in SwiftUI into the rest of the book. This was a bit more work than expected but we have the basic contents in. Now some parts don’t flow as nicely, so that’ll be our focus for this week.
&lt;/p&gt;
&lt;p&gt;
	Yesterday I ran a 24km race again on quite difficult terrain. I wasn’t really sure how fit I am, but it turned to be much better than expected. I started off quickly and built up a gap to the guy behind me. I was afraid I overpaced myself doing that, and the gap stayed at roughly the same distance. Towards the end there was a short but steep climb where he got much closer, but I still had enough left to not let him pass.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 28 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-34</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-34</guid>
		</item>
		<item>
			<title>Weeknotes № 33</title>
			<description>
				&lt;p&gt;
	After last week’s conference in Toronto I went to NYC to get the most out of the transatlantic flight. The kind folks at iOSoho gave me a stage as well. After spending so long on preparing my talk (I didn’t track the time, but my guess is that it easily adds up to two weeks full-time) it was nice to give the same talk again to get some more mileage out of the preparation.
&lt;/p&gt;
&lt;p&gt;
	I spent the rest of my time in NYC by meeting a lot of friends, old and new. I love visiting the city, especially because of the people, the diversity and the buzz. I’ve had a lot of nice food and long walks with great people. However, in our current life situation, I think the life filled with nature, playing outside and swimming is nicer for us as a family right now (it sometimes feels like the opposite of New York). I miss things about the city, but would probably miss even more things about the countryside should we live in the city. The programmer in me wants to classify things: one should clearly be better than the other, but unfortunately, real life often doesn’t work like that. There are probably famous people who say this more eloquently, but one of the things I love about traveling is that it makes me appreciate home even more.
&lt;/p&gt;
&lt;p&gt;
	I haven’t really done much programming or research last week. One of the things I did realize (also throught conversations with other people) is that I really enjoy understanding (and then explaining) things at a really fundamental level. For me, the best way to do this seems to be by actually reimplementing the thing I’d like to understand. This also has been a recurring theme of Swift Talk over the years, not by accident.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 21 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-33</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-33</guid>
		</item>
		<item>
			<title>Weeknotes № 29-32</title>
			<description>
				&lt;p&gt;
	The last weeks we’ve mostly enjoyed our holiday (visiting the Baltic sea), spent time in the garden, and generally took it easy.
&lt;/p&gt;
&lt;p&gt;
	I finished the keyframe implementation, I think it’s almost the same as the native implementation but it works on older platforms. It’s not efficient and the code isn’t very pretty yet. While I don’t worry too much about efficiency, I would like to clean up the code before putting it out.
&lt;/p&gt;
&lt;p&gt;
	I’ve worked pretty hard on preparing the presentation that I gave last week at &lt;a href=&quot;http://swiftconf.to&quot;&gt;Swift TO&lt;/a&gt; and will give this week at &lt;a href=&quot;https://www.meetup.com/iosoho/events/295354940/&quot;&gt;iOSoho&lt;/a&gt;. There are almost 150 slides (build steps) for 30 minutes of talking (not including some of the hand-controlled animations). I don’t think I’ve ever had that many slides, and I don’t think it was too much.
&lt;/p&gt;
&lt;p&gt;
	I created the presentation using SwiftUI. This was both scary (what if it breaks on stage?) as well as really fun and productive. I was able to use all the builtin views and drawing, and a lot more nerdy stuff:
&lt;/p&gt;
&lt;p&gt;
	The presentation is a custom Mac app with two windows: one presenter window that I control and see, and a second presentation window that displays full-screen on the projector. Almost everything in the presentation is fake, to make things controllable and reliable. The simulator, the animated mouse clicks, the buttons, and the network loading.
&lt;/p&gt;
&lt;p&gt;
	I reused our (internal) diagrams library to draw and animate all kinds of tree diagrams. I used &lt;a href=&quot;https://movingparts.io/pow&quot;&gt;Pow&lt;/a&gt; for some of the animated effects. Not just transitions, but also shimmer effects in the tree diagrams to highlight specific features. I used the &lt;a href=&quot;https://talk.objc.io/episodes/S01E326-iphone-simulator-chrome-part-2&quot;&gt;iPhone simulator chrome&lt;/a&gt; to draw my views as if they were running in the simulator.
&lt;/p&gt;
&lt;p&gt;
	I dug up my old Logitech clicker, which works as if it were an external keyboard. I handled the keyboard events in SwiftUI, not only to move between slides but also to toggle specific features and trigger some animations.
&lt;/p&gt;
&lt;p&gt;
	I couldn’t get all the animations to work exactly the way I wanted to. Specifically the tree diagrams have some broken animations. I think this is due to the vertices being rendered through preferences. Likewise, I wanted to add a few more custom animations that I just didn’t have the time to implement. However, for upcoming presentations I should be able to take what I have and improve upon this, slowly working my way towards the perfect presentation.
&lt;/p&gt;
&lt;p&gt;
	Because anything can go wrong, I also spent a day implementing PDF export. This gave me a backup for when things fail as well as readable slides for other people. On recent versions of macOS, it’s now very easy to export SwiftUI views as vector PDFs. Some native views (e.g. &lt;code&gt;ProgressView&lt;/code&gt;) render as red circles with a line through them, but I could quickly work my way around that.
&lt;/p&gt;
&lt;p&gt;
	Of course, I did all of this work after I had the story and outline for my presentation done. I knew what I wanted to say, how much time I had left to prepare and made the decision to bite the bullet and use SwiftUI. It was &lt;em&gt;way&lt;/em&gt;
	 more work than doing a live-coding presentation or creating slides in Keynote, but I did enjoy it.
&lt;/p&gt;
&lt;p&gt;
	I’ve gotten some great feedback on the presentation. There were even people fixing bugs in their codebase the same day, which is always very rewarding. My goal was to help people understand my mental model of SwiftUI, and from talking to the attendees, I think I have achieved that.
&lt;/p&gt;
&lt;p&gt;
	I’m not sure whether the presentation video will be available publicly, but I’ll post the annotated slides here soon.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 14 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-32</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-32</guid>
		</item>
		<item>
			<title>Weeknotes № 28</title>
			<description>
				&lt;p&gt;
	Last week we put the finishing touches to the animation chapter, and recorded a bunch of episodes to cover the summer break. I worked a bit on my talk as well.
&lt;/p&gt;
&lt;p&gt;
	For our keyframe reimplementation, we also wanted to have cubic bezier timing curves. This was interesting to implement: sampling a cubic bezier curve is actually really simple, I was basically able to take &lt;a href=&quot;https://en.wikipedia.org/wiki/Bézier_curve#Cubic_Bézier_curves&quot;&gt;Wikipedia’s algorithm&lt;/a&gt; and just write it down in Swift. The algorithm is a function from &lt;code&gt;t&lt;/code&gt; to a point (you can actually use &lt;code&gt;VectorArithmetic&lt;/code&gt; instead of a point, which I did). After plotting everything, I realized that the &lt;code&gt;t&lt;/code&gt; isn’t used as the time value. Instead, if you use a &lt;code&gt;CGPoint&lt;/code&gt;, the &lt;code&gt;x&lt;/code&gt; value is the time, and the &lt;code&gt;y&lt;/code&gt; value the progress. in other words, the &lt;code&gt;t&lt;/code&gt; is used to sample the result, but not as the time or value.
&lt;/p&gt;
&lt;p&gt;
	This makes a lot of sense, but took me a while to figure out. To provide an efficient implementation, we need to then first find a &lt;code&gt;t&lt;/code&gt; for a given time (in other words, find &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;). There seem to be a number of efficient ways to do this &lt;a href=&quot;https://github.com/gre/bezier-easing/tree/master&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://github.com/WebKit/WebKit/blob/main/Source/WebCore/platform/graphics/UnitBezier.h&quot;&gt;this&lt;/a&gt; seems to be helpful. Once we have the correct &lt;code&gt;t&lt;/code&gt; we can get &lt;code&gt;y&lt;/code&gt; as well.
&lt;/p&gt;
&lt;p&gt;
	When you have multiple cubic bezier keyframes after each other, the implementation uses Catmull-Rom to interpolate between the keyframes. I also managed to implement this (on top of quadratic bezier curves), getting the exact same timing curve. Hopefully we can get this to Swift Talk sometime soon!
&lt;/p&gt;
&lt;p&gt;
	The summer holiday has started here, we had family visiting and will be going on a trip of our own. So next week there almost certainly won’t be any weeknotes.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 17 Jul 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-28</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-28</guid>
		</item>
	</channel>
</rss>