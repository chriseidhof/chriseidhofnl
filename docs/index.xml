<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Chris Eidhof</title>
		<description>
			Personal Blog
		</description>
		<link>http://chris.eidhof.nl</link>
		<atom:link href="http://chris.eidhof.nl/feed.xml" rel="self" type="application/rss+xml"/>
		<item>
			<title>Working With UIViewRepresentable</title>
			<description>
				&lt;p&gt;
	When we work with SwiftUI, we can always drop down to UIKit level by using &lt;code&gt;UIViewRepresentable&lt;/code&gt;, &lt;code&gt;NSViewRepresentable&lt;/code&gt; or &lt;code&gt;UIViewControllerRepresentable&lt;/code&gt;. The documentation around these protocols is still pretty sparse, and it can be hard to get them to work exactly the way we want. I tried to come up with some rules and patterns for using them. These patterns are &lt;em&gt;not&lt;/em&gt;
	 final, if you have feedback about missing things or mistakes, please let me know.
&lt;/p&gt;
&lt;p&gt;
	There are a few different challenges. In this article, I want to focus on communicating state between SwiftUI and UIKit/AppKit. Communication can happen in either direction: we’ll need to update our &lt;code&gt;UIView&lt;/code&gt; when SwiftUI’s state changes, and we’ll need to update our SwiftUI state based on UIView changes.
&lt;/p&gt;
&lt;p&gt;
	Here are two rules for working with representables. (&lt;a href=&quot;https://www.cocoawithlove.com&quot;&gt;Matt&lt;/a&gt; helped me with this, thank you):
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			When updating a UIView in response to a SwiftUI state change, we need to go over all the representable’s properties, but only change the UIView properties that need it.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			When updating SwiftUI in response to a UIKit change, we need to make sure these updates happen asynchronously.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	If we don’t follow these rules, there are a few issues we might see:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			The dreaded “Modifying state during view update, this will cause undefined behavior” warning
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Unnecessary redraws of our &lt;code&gt;UIViewRepresentable&lt;/code&gt;, or even infinite loops
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			Strange behavior where the state and the view are a little bit out of sync
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	In my testing, these issues are becoming less relevant with UIKit, but are very relevant when dealing with AppKit. My guess is that UIKit components have seen some internal changes to make writing view representables simpler. However, as we’ll see, this isn’t the case for every UIKit view.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Building a MapView wrapper&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	MapKit’s &lt;code&gt;Map&lt;/code&gt; view for SwiftUI used to be very limited, and a popular target for wrapping in a representable. As of iOS 17 it gained a lot of new capabilities, but we’ll still use it as our first example.
&lt;/p&gt;
&lt;p&gt;
	We’ll be writing a simple wrapper that takes a binding to the map view’s center coordinate. As a first step, we’ll create an &lt;code&gt;MKMapView&lt;/code&gt; and set the delegate to be our coordinator.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct HybridMap: UIViewRepresentable {
    @Binding var position: CLLocationCoordinate2D
    
    // ...

    func makeUIView(context: Context) -&amp;gt; MKMapView {
        let view = MKMapView()
        view.delegate = context.coordinator
        view.preferredConfiguration = MKHybridMapConfiguration()
        return view
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	For the coordinator, there is a nice technique to pass in all properties of &lt;code&gt;HybridMap&lt;/code&gt; directly (this is especially useful when we have more than one property). You can simply pass a copy of &lt;code&gt;self&lt;/code&gt;, as &lt;code&gt;HybridMap&lt;/code&gt; is a struct:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;// ...
class Coordinator: NSObject, MKMapViewDelegate {
    var parent: HybridMap
    init(parent: HybridMap) {
        self.parent = parent
    }

    func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
        parent.position = mapView.centerCoordinate
    }
}

func makeCoordinator() -&amp;gt; Coordinator {
    Coordinator(parent: self)
}
// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Finally, here’s our &lt;code&gt;updateUIView&lt;/code&gt; method:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    context.coordinator.parent = self
    view.centerCoordinate = position
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	We can now create a simple view with a state property for the position:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;let initialPosition = CLLocationCoordinate2D(latitude: 52.518611, longitude: 13.408333)

struct ContentView: View {
    @State private var position = initialPosition
    
    var body: some View {
        VStack {
            Text(&amp;quot;\(position.latitude) \(position.longitude)&amp;quot;)
            Button(&amp;quot;Reset Position&amp;quot;) { position = initialPosition }
            HybridMap(position: $position)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we launch the above app, we’ll immediately get a runtime warning: “Modifying state during view update, this will cause undefined behavior.”. To debug this, we can add print statements to the beginning and ending of both our &lt;code&gt;updateUIView&lt;/code&gt; as well as &lt;code&gt;mapViewDidChangeVisibleRegion&lt;/code&gt; methods:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    print(&amp;quot;Begin updateUIView&amp;quot;, position)
    defer { print(&amp;quot;End updateUIView&amp;quot;) }
    context.coordinator.parent = self
    view.centerCoordinate = position
}
// ...
func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
    print(&amp;quot;Begin didChange&amp;quot;, mapView.centerCoordinate)
    defer { print(&amp;quot;End didChange&amp;quot;) }
    parent.position = mapView.centerCoordinate
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we launch the app, we get the following print statements:
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Begin updateUIView CLLocationCoordinate2D(latitude: 52.518611, longitude: 13.408333)
End updateUIView
Begin didChange CLLocationCoordinate2D(latitude: 51.117027, longitude: 10.333652000000006)
End didChange
Begin didChange CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
End didChange
Begin updateUIView CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
Begin didChange CLLocationCoordinate2D(latitude: 52.51861099999999, longitude: 13.40833300000003)
[SwiftUI] Modifying state during view update, this will cause undefined behavior.
End didChange
End updateUIView
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Here’s what happens: first, the view is rendered and put on screen. After that, the &lt;code&gt;didChange&lt;/code&gt; runs. We can see that map views don’t store their center coordinate directly, my guess is that they only store the visible region as their source of truth. This is why the values in the print statements are different from our initial value. Towards the end, we see that a &lt;code&gt;didChange&lt;/code&gt; runs from within our &lt;code&gt;updateUIView&lt;/code&gt; method, updating our SwiftUI state. This causes the “Modifying state” error.
&lt;/p&gt;
&lt;p&gt;
	As far as I know, the only reliable way I know of to get rid of this warning is by doing this state change asynchronously. The simplest way is by enqueueing another block on the main queue:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
    DispatchQueue.main.async {
        self.parent.position = mapView.centerCoordinate
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This makes the runtime warning go away. However, we can’t drag the map anymore, after a single drag movement it halts. There is one more step left to make this representable work:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateUIView(_ view: MKMapView, context: Context) {
    context.coordinator.parent = self
    if view.centerCoordinate != position {
        view.centerCoordinate = position
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	By only doing the view update when necessary we’re not triggering another &lt;code&gt;didChange&lt;/code&gt;. Both of these changes are specific instances of the rules at the beginning of the article:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			We need to change our SwiftUI state asynchronously in response to UIKit changes.
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We need to only update properties of UIKit views when absolutely necessary
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Building a Text View wrapper&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	As a second example, we’ll build an &lt;code&gt;NSTextView&lt;/code&gt; wrapper. My goal is to write a &lt;code&gt;MyTextView&lt;/code&gt; component that takes a binding for both the text and the selected range. This is for the Mac, so we’ll be using &lt;code&gt;NSView&lt;/code&gt; instead of &lt;code&gt;UIView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
	Here’s the (broken) initial version, with a structure very similar to our map view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct MyTextView: NSViewRepresentable {
    @Binding var text: String
    @Binding var selection: NSRange

    final class Coordinator: NSObject, NSTextViewDelegate {
        var parent: MyTextView
        unowned var textView: NSTextView!
        init(parent: MyTextView) {
            self.parent = parent
        }

        func textDidChange(_ notification: Notification) {
            self.parent.text = textView.string
        }

        func textViewDidChangeSelection(_ notification: Notification) {
            self.parent.selection = textView.selectedRange()
        }
    }

    func makeCoordinator() -&amp;gt; Coordinator {
        Coordinator(parent: self)
    }

    func makeNSView(context: Context) -&amp;gt; NSTextView {
        let t = NSTextView()
        context.coordinator.textView = t
        t.delegate = context.coordinator
        return t
    }

    func updateNSView(_ t: NSTextView, context: Context) {
        t.textStorage?.setAttributedString(text.highlight())
        t.selectedRanges = [.init(range: selection)]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we run the example above, we can see that we get the dreaded “Modifying state during view update, this will cause undefined behavior” warning. This happens because when we set the attributed string from within &lt;code&gt;updateNSView&lt;/code&gt;, the text view will fire a &lt;code&gt;textViewDidChangeSelection&lt;/code&gt; notification. This notification isn’t posted asynchronously, but actually does happen during the &lt;code&gt;updateNSView&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updating SwiftUI in Response to an NSView Change&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	Similar to the map view, we can now wrap our update by enqueueing it on the main queue:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func textViewDidChangeSelection(_ notification: Notification) {
    let r = self.textView.selectedRange()
    DispatchQueue.main.async {
        self.parent.selection = r
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Unfortunately, things are still broken: we don’t get a runtime warning anymore, but the cursor behaves weirdly. (The insertion point is rendered at the start of the current selection whenever the length of the selection is zero).
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Updating an NSView in Response to a SwiftUI State Change&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	In principle, this is simple. Whenever something changes, SwiftUI will call &lt;code&gt;updateNSView(:context:)&lt;/code&gt;. However, we don’t know &lt;em&gt;what&lt;/em&gt;
	 changed, it could be any number of properties. In the above implementation, we simply set the two properties, but that’s not enough.
&lt;/p&gt;
&lt;p&gt;
	In our update method, we should take care to inspect each property, but only set the corresponding &lt;code&gt;NSView&lt;/code&gt; value if it’s really necessary. For example:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func updateNSView(_ t: NSTextView, context: Context) {
    context.coordinator.parent = self
    if t.string != text {
        t.textStorage?.setAttributedString(text.highlight())
    }
    if t.selectedRange() != selection {
        t.selectedRanges = [.init(range: selection)]
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This solves almost all our problems. However, there is still a weird issue. When I’m typing at the end of the text field, some characters get inserted just before the last character, instead of at the end.
&lt;/p&gt;
&lt;p&gt;
	Here’s what happens (bear with me):
&lt;/p&gt;
&lt;p&gt;
	When I type a character at the end of the string, the selection changes. A &lt;code&gt;self.parent.setSelection…&lt;/code&gt; is enqueued. Before that runs, however, the text is updated, and &lt;code&gt;updateNSView&lt;/code&gt; happens. It will set the attributed string, which in turn causes the selection to change, which adds another &lt;code&gt;setSelection&lt;/code&gt; to the queue (with the old selection value). The main queue then runs the first (correct) block to set the selection, and then the second (incorrect) block.
&lt;/p&gt;
&lt;p&gt;
	To keep the order of events correct, this means we also have to enqueue the changing of our text. That way, all events will happen in the order we expect:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;func textDidChange(_ notification: Notification) {
    let str = textView.string
    DispatchQueue.main.async {
        self.parent.text = str
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	This is tricky to find and tricky to debug. A simple rule of thumb would be that once we start enqueueing one change asynchronously, we probably need to do all of the other updates asynchronously as well.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More Issues and Gotchas&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	As mentioned, we need to check each property in &lt;code&gt;updateNSView(:context:)&lt;/code&gt; and make sure to only update the &lt;code&gt;NSView&lt;/code&gt; when it’s really needed. This relies on us being able to compare values.  Sometimes this isn’t possible. For example, when dealing with the map view, we saw that the center coordinate conversion is lossy. In the cases where we can’t read out the current value, we can cache each value that we set. Inside our coordinator, we could add a helper like this:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;private var previousValues: [String: Any] = [:]
func setIfNeeded&amp;lt;Value: Equatable&amp;gt;(value: Value, name: String, update: (NSTextView) -&amp;gt; ()) {
    if let previous = previousValues[name] as? Value, previous == value {
        return
    }
    previousValues[name] = value
    update(textView)
}   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When we set the new value, we first check whether or not we’ve previously set this value. Only if it’s different, we proceed to update the underlying platform view. In a way, this is similar to SwiftUI’s &lt;code&gt;onChange(of:)&lt;/code&gt; modifier (only run the closure when something changed).
&lt;/p&gt;
&lt;p&gt;
	Similarly, when we want to start animations in SwiftUI, we’ll need to have some kind of state, and our coordinator needs to track when that state changes and only start a new animation then. You could use a method similar to &lt;code&gt;setIfNeeded&lt;/code&gt; to achieve this.
&lt;/p&gt;
&lt;p&gt;
	Sometimes, we want to communicate events back from an NSView to SwiftUI. If the event modifies a value, we could simply modify the corresponding binding. For example, if the event would be &lt;code&gt;scrollViewDidScroll&lt;/code&gt;, we can change the &lt;code&gt;scrollPosition&lt;/code&gt; binding. However, for other events it’s more appropriate to just call a closure (this is what &lt;code&gt;Button&lt;/code&gt; does each time the user taps). Of course, this closure could have parameters as well.
&lt;/p&gt;
&lt;p&gt;
	I’m sure there are many more issues when doing this in practice, if you have any feedback or comments I’d love to hear about it.
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
	After some discussion on Mastodon, it seems like there’s one more obvious impromevent we could make. When there are multiple related events that happen in the same runloop cycle (e.g. setting the attributed string and the selection) we could also batch them up and enqueue them once. This only works if these events happen synchronously within the update method, that way our update method can create a queue, and at the end it can enqueue all those updates asynchronously as a single block. I’ve experimented with this and it seems promising.
&lt;/p&gt;
&lt;p&gt;
	If you want to learn more about SwiftUI, check out our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;.
&lt;/p&gt;
			</description>
			<pubDate>Wed, 13 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/view-representable</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/view-representable</guid>
		</item>
		<item>
			<title>Weeknotes № 36</title>
			<description>
				&lt;p&gt;
	It feels like last week was the last warm week of summer, and so as a family, we took advantage of that every afternoon and went swimming in one of the lakes nearby. Our new house is a short walk to one of those lakes, and one of my dreams since we moved here half a year ago was swimming across the lake. I’ve been swimming all my life, but never any long distances or with good technique.
&lt;/p&gt;
&lt;p&gt;
	On Wednesday I saw the calm water, hot sun and no boats so I decided on a whim that this was the day. Armed with goggles and a tow float I decided to swim across. The unknown of it was pretty scary for me (which did give me a nice speed boost). It’s a large lake, there are boats, I might cramp up or unknown other stuff might happen. In the end, it took less than ten minutes to swim across. After only two minutes my elastic watch strap came loose, so I had to change to breast stroke until I figured out I could just shove my watch all the way up to my elbow. Those ten minutes felt a lot longer than normal!
&lt;/p&gt;
&lt;p&gt;
	I swam across another time a few days later (in eight minutes), wearing a cap as well (for visibility). My last swimming lesson was thirty years ago, and the freestyle part I never learned was that, most of the time, your face is below the surface. You basically only tilt your head out of the water a bit to get in some fresh air and then continue, looking down towards the bottom. For some reason this is pretty scary to me as well, even more so in a very clear lake. But after a few more “longer” swims I’m starting to get used to it. Next season, I’d love to build up to really long swims, maybe crossing the lake length-wise.
&lt;/p&gt;
&lt;p&gt;
	Florian was away last week, I worked on the “typing recorder” app that I plan to use to record myself typing and play back in a smooth way (for presentations, workshops and videos). As part of this, I needed to do another &lt;code&gt;NSViewRepresentable&lt;/code&gt; implementation for &lt;code&gt;NSTextField&lt;/code&gt;. I had yet another one of these “Modifying state during view update” runtime warnings and decided it was time to fully understand these. I’ve written down a bunch of notes already that I hope to turn into a blog post soon.
&lt;/p&gt;
&lt;p&gt;
	We finalized the copy editing for &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;, &lt;a href=&quot;http://www.natalye.com&quot;&gt;Natalye&lt;/a&gt; went through the last bunch of edits so now it’s time to typeset everything. We’ll need to do this once for print and once for the PDF version.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 11 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-36</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-36</guid>
		</item>
		<item>
			<title>Weeknotes № 35</title>
			<description>
				&lt;p&gt;
	We finally recorded the final bits of our &lt;a href=&quot;https://talk.objc.io/episodes/S01E366-building-keyframe-animations-part-1&quot;&gt;keyframe reimplementation&lt;/a&gt;, including a Catmull-Rom implementation that turned out to be extremely simple and matches exactly what SwiftUI does. I’ve used our reimplementation in a macOS 13 app successfully.
&lt;/p&gt;
&lt;p&gt;
	We also went over the entire &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;book&lt;/a&gt; and made it ready for a final copy-editing pass. The next steps after that is to do a little bit of typesetting for the PDF version and possible a bit more for the printed version. Then we can release it!
&lt;/p&gt;
&lt;p&gt;
	I’ve been playing around with a new project that lets me record me typing code and then replay it in a smoother and animated way. This should be useful for making videos and when giving presentations (in SwiftUI).
&lt;/p&gt;
&lt;p&gt;
	Last week, &lt;a href=&quot;https://www.swiftconf.to&quot;&gt;Swift TO&lt;/a&gt; released the videos of all the presentations. I created an annotated version of my presentation &lt;a href=&quot;http://chris.eidhof.nl/presentations/day-in-the-life&quot;&gt;A Day in the Life of a SwiftUI View&lt;/a&gt;. This definitely took a few hours here and there, but hopefully it’s useful to those of you that don’t want to or can’t watch videos.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 04 Sep 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-35</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-35</guid>
		</item>
		<item>
			<title>Running Code When Your View Appears</title>
			<description>
				&lt;p&gt;
	When you’re writing SwiftUI views, you definitely don’t want to run expensive tasks in the view’s initializer, as it might get called very often. Also, since the view doesn’t have structural identity yet when the initializer runs, you can’t reliably store data. Instead, you want to load data in the view’s body before the view will be drawn on screen.
&lt;/p&gt;
&lt;p&gt;
	You can achieve this with &lt;code&gt;.task&lt;/code&gt; or &lt;code&gt;.onAppear&lt;/code&gt;. The &lt;code&gt;onAppear&lt;/code&gt; modifier has been around since the beginning. It takes a regular closure that is called whenever the view appears on screen
&lt;sup&gt;&lt;a href=&quot;#fnref1&quot; name=&quot;fnref-rev1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
. The &lt;code&gt;task&lt;/code&gt; modifier supports async/await without you having to create a manual &lt;code&gt;Task&lt;/code&gt;. The task also gets cancelled automatically when the view disappears.
&lt;/p&gt;
&lt;p&gt;
	Because &lt;code&gt;task&lt;/code&gt; can do anything that &lt;code&gt;onAppear&lt;/code&gt; can, is there still any reason to use &lt;code&gt;onAppear&lt;/code&gt;? Or can we just move to &lt;code&gt;task&lt;/code&gt;? At first, I thought the two are the same, it seems like &lt;code&gt;task&lt;/code&gt; is built on top of &lt;code&gt;onAppear&lt;/code&gt;. There is a small difference, however (which might be an essential difference depending on how you use it). Consider the following view:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;struct ContentView: View {
    @State private var color0 = Color.red
    @State private var color1 = Color.red
    var body: some View {
        VStack {
            color0
            color1
        }
        .onAppear { color0 = .green }
        .task { color1 = .green }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	When you launch this app, you can see that the topmost view in the &lt;code&gt;VStack&lt;/code&gt; never renders in red, whereas the bottom view quickly flickers red before turning green. If you can’t see it, you can use QuickTime to create a screen recording and verify it that way.
&lt;/p&gt;
&lt;blockquote&gt;
	&lt;p&gt;
		We first noticed this behavior when implementing our own version of AsyncImage. We wanted to take a cached image, but when you use &lt;code&gt;task&lt;/code&gt;, you’ll always see the placeholder.
	&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
	When you use &lt;code&gt;onAppear&lt;/code&gt; or &lt;code&gt;onPreferenceChange&lt;/code&gt; (possibly more modifiers), SwiftUI can execute your code before it even renders a single frame. Initially, the body executes, calls &lt;code&gt;onAppear&lt;/code&gt; and then runs the closure inside &lt;code&gt;onAppear&lt;/code&gt;. If this changes any state, the body is re-rendered before the view is even drawn on screen.
&lt;/p&gt;
&lt;p&gt;
	I’m not sure why task behaves differently and if the source of this “problem” is with SwiftUI or the concurrency system. I’m not sure if it’s meant to be or considered a bug, but at least, at this moment in time, it does work differently.
&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
	&lt;hr/&gt;
	&lt;ol&gt;
		&lt;li id=&quot;fnref1&quot;&gt;
			&lt;p&gt;
				The closure is called at least once when the view appears, but can also be called multiple times. For example, when the view is in a scroll view or a tab bar, the closure gets called each time the view becomes visible.
				 &lt;a href=&quot;#fnref-rev1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
&lt;/div&gt;
			</description>
			<pubDate>Thu, 31 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/swiftui-on-appear-vs-task</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/swiftui-on-appear-vs-task</guid>
		</item>
		<item>
			<title>How To Visualize The Safe Area</title>
			<description>
				&lt;p&gt;
	When we draw a SwiftUI view on screen, it only fills the safe area by default. For example, here we can see a yellow rectangle that fills the safe area, but leaves white space at the top and bottom of the screen.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;Rectangle()
    .fill(Color.yellow)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/1-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/1.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	We can change this behavior by adding the &lt;code&gt;.ignoresSafeArea&lt;/code&gt; modifier:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;Rectangle()
    .fill(Color.yellow)
    .ignoresSafeArea()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/3-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/3.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	When the layout happens, the safe area insets are passed around to all the views that do layout. Whenever a border of a view marked with &lt;code&gt;ignoresSafeArea&lt;/code&gt; touches the edge of the safe area, it will extend itself. For example, in the following view, the yellow color extends to the top but not to the bottom, as expected:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;VStack {
    Color.yellow
        .ignoresSafeArea()
    Text(&amp;quot;Hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/5-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/5.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	We can also make the safe area smaller (increase the insets) using a number of different modifiers. The &lt;code&gt;safeAreaInset&lt;/code&gt; (available since iOS 15) allows us to add to the non-safe area. The yellow color will now respect the safe area, but can also use the &lt;code&gt;ignoresSafeArea&lt;/code&gt; modifier to display beyond the safe area.
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;VStack {
    Color.yellow
    Text(&amp;quot;Hello&amp;quot;)
}
.safeAreaInset(edge: .leading) {
    Color.clear.frame(width: 20)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/7-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/7.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	Insetting a view’s safe area with another view is not the same as placing the the views next to each other. For example, when we add a bottom safe area inset to a scroll view, the scroll view will draw itself behind that inset but also lets the user scroll so that all the content is visible:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;myScrollView
    .safeAreaInset(edge: .bottom) {
        Text(&amp;quot;This is my bottom view&amp;quot;)
            .frame(height: 100)
            .frame(maxWidth: .infinity)
            .background(Material.regular)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/9-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/9.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	One of the interesting things is that we can visualize the safe area using an overlay and a geometry reader. We can add &lt;code&gt;ignoresSafeArea&lt;/code&gt; to the geometry reader. Inside the geometry reader, we get access to the size of the safe area insets as well as the safe area size itself:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;extension View {
    func visualizeSafeArea() -&amp;gt; some View {
        overlay {
            GeometryReader { proxy in
                ZStack {
                    VStack(spacing: 0) {
                        Color.yellow
                            .frame(height: proxy.safeAreaInsets.top)
                        Color.clear
                            .frame(height: proxy.size.height)
                        Color.red
                            .frame(height: proxy.safeAreaInsets.bottom)
                    }
                    HStack(spacing: 0) {
                        Color.green
                            .frame(width: proxy.safeAreaInsets.leading)
                        Color.clear
                            .frame(width: proxy.size.width)
                        Color.blue
                            .frame(width: proxy.safeAreaInsets.trailing)
                    }
                }
                .opacity(0.5)
                .ignoresSafeArea()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	Using the helper above, we can now visualize the safe area insets for any view. For example, let’s consider a gray rectangle that fills the safe area. We can see the yellow indicating the top safe area insets and the red indicating the bottom safe area insets:
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;Rectangle()
    .fill(Color.gray)
    .visualizeSafeArea()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
	&lt;picture class=&quot;swiftui&quot;&gt;
		&lt;source media=&quot;(prefers-color-scheme: dark)&quot; srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/11-dark.png 2x&quot;/&gt;
		&lt;img srcset=&quot;http://chris.eidhof.nl/post/visualize-swiftui-safe-area/11.png 2x&quot; style=&quot;width: auto;&quot;/&gt;
	&lt;/picture&gt;
&lt;/p&gt;
&lt;p&gt;
	It’s interesting to play around with this helper, applying it at different points in the view hierarchy. It helped me gain a good understanding of how the safe area behaves and how to modify it for my own needs.
&lt;/p&gt;
&lt;p&gt;
	As always, if you’re interested how SwiftUI works below the hood, check out our book &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;Thinking in SwiftUI&lt;/a&gt;. In fact, this post was inspired by &lt;a href=&quot;https://github.com/objcio/thinking-in-swiftui-qa/issues/19&quot;&gt;a question&lt;/a&gt; from Ayman that we answered in our &lt;a href=&quot;https://github.com/objcio/thinking-in-swiftui-qa&quot;&gt;weekly Q&amp;amp;A&lt;/a&gt;.
&lt;/p&gt;
			</description>
			<pubDate>Wed, 30 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/visualize-swiftui-safe-area</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/visualize-swiftui-safe-area</guid>
		</item>
		<item>
			<title>Weeknotes № 34</title>
			<description>
				&lt;p&gt;
	Last week we prepared and recorded &lt;a href=&quot;https://talk.objc.io/episodes/S01E369-cubic-bezier-keyframes-part-1&quot;&gt;more episodes&lt;/a&gt; about our SwiftUI keyframe reimplementation effort. I also worked on getting closer to the Catmull-Rom version that SwiftUI has implemented, but I’m not quite there yet. It’s close enough to be unnoticable, but I always feel like pushing that extra bit to get 100% accurate is somehow worth it when trying to understand how things work.
&lt;/p&gt;
&lt;p&gt;
	We replaced our old blender at home (it broke over a year ago), so I’ve been on a bit of a smoothie trip, making all kinds of combinations (spinach/banana/ginger is one of my favorites). I also finally made gazpacho again: almost everything (except for the stale bread) came directly from the garden. Absolutely delicious.
&lt;/p&gt;
&lt;p&gt;
	Towards the end of the week we started integrating the iOS 17 chapter of Thinking in SwiftUI into the rest of the book. This was a bit more work than expected but we have the basic contents in. Now some parts don’t flow as nicely, so that’ll be our focus for this week.
&lt;/p&gt;
&lt;p&gt;
	Yesterday I ran a 24km race again on quite difficult terrain. I wasn’t really sure how fit I am, but it turned to be much better than expected. I started off quickly and built up a gap to the guy behind me. I was afraid I overpaced myself doing that, and the gap stayed at roughly the same distance. Towards the end there was a short but steep climb where he got much closer, but I still had enough left to not let him pass.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 28 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-34</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-34</guid>
		</item>
		<item>
			<title>Weeknotes № 33</title>
			<description>
				&lt;p&gt;
	After last week’s conference in Toronto I went to NYC to get the most out of the transatlantic flight. The kind folks at iOSoho gave me a stage as well. After spending so long on preparing my talk (I didn’t track the time, but my guess is that it easily adds up to two weeks full-time) it was nice to give the same talk again to get some more mileage out of the preparation.
&lt;/p&gt;
&lt;p&gt;
	I spent the rest of my time in NYC by meeting a lot of friends, old and new. I love visiting the city, especially because of the people, the diversity and the buzz. I’ve had a lot of nice food and long walks with great people. However, in our current life situation, I think the life filled with nature, playing outside and swimming is nicer for us as a family right now (it sometimes feels like the opposite of New York). I miss things about the city, but would probably miss even more things about the countryside should we live in the city. The programmer in me wants to classify things: one should clearly be better than the other, but unfortunately, real life often doesn’t work like that. There are probably famous people who say this more eloquently, but one of the things I love about traveling is that it makes me appreciate home even more.
&lt;/p&gt;
&lt;p&gt;
	I haven’t really done much programming or research last week. One of the things I did realize (also throught conversations with other people) is that I really enjoy understanding (and then explaining) things at a really fundamental level. For me, the best way to do this seems to be by actually reimplementing the thing I’d like to understand. This also has been a recurring theme of Swift Talk over the years, not by accident.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 21 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-33</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-33</guid>
		</item>
		<item>
			<title>Weeknotes № 29-32</title>
			<description>
				&lt;p&gt;
	The last weeks we’ve mostly enjoyed our holiday (visiting the Baltic sea), spent time in the garden, and generally took it easy.
&lt;/p&gt;
&lt;p&gt;
	I finished the keyframe implementation, I think it’s almost the same as the native implementation but it works on older platforms. It’s not efficient and the code isn’t very pretty yet. While I don’t worry too much about efficiency, I would like to clean up the code before putting it out.
&lt;/p&gt;
&lt;p&gt;
	I’ve worked pretty hard on preparing the presentation that I gave last week at &lt;a href=&quot;http://swiftconf.to&quot;&gt;Swift TO&lt;/a&gt; and will give this week at &lt;a href=&quot;https://www.meetup.com/iosoho/events/295354940/&quot;&gt;iOSoho&lt;/a&gt;. There are almost 150 slides (build steps) for 30 minutes of talking (not including some of the hand-controlled animations). I don’t think I’ve ever had that many slides, and I don’t think it was too much.
&lt;/p&gt;
&lt;p&gt;
	I created the presentation using SwiftUI. This was both scary (what if it breaks on stage?) as well as really fun and productive. I was able to use all the builtin views and drawing, and a lot more nerdy stuff:
&lt;/p&gt;
&lt;p&gt;
	The presentation is a custom Mac app with two windows: one presenter window that I control and see, and a second presentation window that displays full-screen on the projector. Almost everything in the presentation is fake, to make things controllable and reliable. The simulator, the animated mouse clicks, the buttons, and the network loading.
&lt;/p&gt;
&lt;p&gt;
	I reused our (internal) diagrams library to draw and animate all kinds of tree diagrams. I used &lt;a href=&quot;https://movingparts.io/pow&quot;&gt;Pow&lt;/a&gt; for some of the animated effects. Not just transitions, but also shimmer effects in the tree diagrams to highlight specific features. I used the &lt;a href=&quot;https://talk.objc.io/episodes/S01E326-iphone-simulator-chrome-part-2&quot;&gt;iPhone simulator chrome&lt;/a&gt; to draw my views as if they were running in the simulator.
&lt;/p&gt;
&lt;p&gt;
	I dug up my old Logitech clicker, which works as if it were an external keyboard. I handled the keyboard events in SwiftUI, not only to move between slides but also to toggle specific features and trigger some animations.
&lt;/p&gt;
&lt;p&gt;
	I couldn’t get all the animations to work exactly the way I wanted to. Specifically the tree diagrams have some broken animations. I think this is due to the vertices being rendered through preferences. Likewise, I wanted to add a few more custom animations that I just didn’t have the time to implement. However, for upcoming presentations I should be able to take what I have and improve upon this, slowly working my way towards the perfect presentation.
&lt;/p&gt;
&lt;p&gt;
	Because anything can go wrong, I also spent a day implementing PDF export. This gave me a backup for when things fail as well as readable slides for other people. On recent versions of macOS, it’s now very easy to export SwiftUI views as vector PDFs. Some native views (e.g. &lt;code&gt;ProgressView&lt;/code&gt;) render as red circles with a line through them, but I could quickly work my way around that.
&lt;/p&gt;
&lt;p&gt;
	Of course, I did all of this work after I had the story and outline for my presentation done. I knew what I wanted to say, how much time I had left to prepare and made the decision to bite the bullet and use SwiftUI. It was &lt;em&gt;way&lt;/em&gt;
	 more work than doing a live-coding presentation or creating slides in Keynote, but I did enjoy it.
&lt;/p&gt;
&lt;p&gt;
	I’ve gotten some great feedback on the presentation. There were even people fixing bugs in their codebase the same day, which is always very rewarding. My goal was to help people understand my mental model of SwiftUI, and from talking to the attendees, I think I have achieved that.
&lt;/p&gt;
&lt;p&gt;
	I’m not sure whether the presentation video will be available publicly, but I’ll post the annotated slides here soon.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 14 Aug 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-32</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-32</guid>
		</item>
		<item>
			<title>Weeknotes № 28</title>
			<description>
				&lt;p&gt;
	Last week we put the finishing touches to the animation chapter, and recorded a bunch of episodes to cover the summer break. I worked a bit on my talk as well.
&lt;/p&gt;
&lt;p&gt;
	For our keyframe reimplementation, we also wanted to have cubic bezier timing curves. This was interesting to implement: sampling a cubic bezier curve is actually really simple, I was basically able to take &lt;a href=&quot;https://en.wikipedia.org/wiki/Bézier_curve#Cubic_Bézier_curves&quot;&gt;Wikipedia’s algorithm&lt;/a&gt; and just write it down in Swift. The algorithm is a function from &lt;code&gt;t&lt;/code&gt; to a point (you can actually use &lt;code&gt;VectorArithmetic&lt;/code&gt; instead of a point, which I did). After plotting everything, I realized that the &lt;code&gt;t&lt;/code&gt; isn’t used as the time value. Instead, if you use a &lt;code&gt;CGPoint&lt;/code&gt;, the &lt;code&gt;x&lt;/code&gt; value is the time, and the &lt;code&gt;y&lt;/code&gt; value the progress. in other words, the &lt;code&gt;t&lt;/code&gt; is used to sample the result, but not as the time or value.
&lt;/p&gt;
&lt;p&gt;
	This makes a lot of sense, but took me a while to figure out. To provide an efficient implementation, we need to then first find a &lt;code&gt;t&lt;/code&gt; for a given time (in other words, find &lt;code&gt;t&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;). There seem to be a number of efficient ways to do this &lt;a href=&quot;https://github.com/gre/bezier-easing/tree/master&quot;&gt;this&lt;/a&gt; and &lt;a href=&quot;https://github.com/WebKit/WebKit/blob/main/Source/WebCore/platform/graphics/UnitBezier.h&quot;&gt;this&lt;/a&gt; seems to be helpful. Once we have the correct &lt;code&gt;t&lt;/code&gt; we can get &lt;code&gt;y&lt;/code&gt; as well.
&lt;/p&gt;
&lt;p&gt;
	When you have multiple cubic bezier keyframes after each other, the implementation uses Catmull-Rom to interpolate between the keyframes. I also managed to implement this (on top of quadratic bezier curves), getting the exact same timing curve. Hopefully we can get this to Swift Talk sometime soon!
&lt;/p&gt;
&lt;p&gt;
	The summer holiday has started here, we had family visiting and will be going on a trip of our own. So next week there almost certainly won’t be any weeknotes.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 17 Jul 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-28</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-28</guid>
		</item>
		<item>
			<title>Weeknotes № 27</title>
			<description>
				&lt;p&gt;
	We spent most of last week getting the animation chapter ready for our Thinking in SwiftUI prerelease. Of all the chapters in our book this had the most additions for iOS 17. Phase animations, keyframe animations, completion handlers, custom animation curves, new transition APIs and custom keys for transactions.
&lt;/p&gt;
&lt;p&gt;
	Most of these APIs work as expected, but it took us a while longer to understand keyframes (especially since they still have some bugs that will hopefully be fixed soon). However, once we did figure them it turned out that they are pretty simple: they just animate a single (often compound) value over time, in a system that’s completely separate from regular SwiftUI animations. To understand it better, we also spent a day reimplementing the keyframe API. While our implementation doesn’t do cubic keyframes (arguably the most important keyframes) and doesn’t have the builder syntax, it really helped us understand how keyframe animations work.
&lt;/p&gt;
&lt;p&gt;
	In the house, I spent some time plastering defects in our wall. These happened during the final construction phase. The problem with loam (clay) walls is that they are a little less robust, on the other hand, the advantage is that they’re very easy to repair.
&lt;/p&gt;
&lt;p&gt;
	Running-wise, I’ve done some consistent high mileage, and am now ready to move to the next phase of marathon preparation: adding in some more speedwork. Doing a lot of slow running has been fun and I feel I have gotten fitter, now it’s time to get a bit faster as well.
&lt;/p&gt;
&lt;p&gt;
	I think it will always remain a bit of a challenge to be a Dutch person in Germany. It’s often the little things, for example, I just don’t use the car that often. When I walk to day care with my daughter, people often seem to feel sorry about that and offer a ride. Likewise, I have the feeling many drivers don’t really understand what it’s like to be a pedestrian or cyclist, creating dangerous situations (I’m pretty sure most of them don’t do it on purpose). I don’t really see any way to change this, and at the same time, I refuse to give up walking and cycling because of this.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 10 Jul 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-27</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-27</guid>
		</item>
		<item>
			<title>Weeknotes № 26</title>
			<description>
				&lt;p&gt;
	We were busy last week getting the layout chapter out, which is probably the chapter I’m most proud of. There’s still a lot more we could say about SwiftUI’s layout behavior, but I think it’s long enough already. We put a lot of effort into the explanations, I especially like the alignment explanations. We also prepared and recorded two more episodes.
&lt;/p&gt;
&lt;p&gt;
	I started working on my talk for the upcoming &lt;a href=&quot;https://www.swiftconf.to&quot;&gt;Swift TO&lt;/a&gt; conference. Really looking forward to that. I made a little presentation helper for SwiftUI so I can use that to give my presentation.
&lt;/p&gt;
&lt;p&gt;
	At home, I dug up most of the front garden. There were all kinds of weeds, large stones, large metal rods and other stuff. It feels like the previous owners haven’t really maintained it during the last few years, so we wanted a clean start.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 03 Jul 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-26</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-26</guid>
		</item>
		<item>
			<title>Weeknotes № 25</title>
			<description>
				&lt;p&gt;
	Last week, we had the post-launch week of our book, which is always fun. It’s nice to see the first feedback, which has been good so far. We also released a new chapter on state and binding. This one already has a bunch of (hopefully) helpful custom diagrams in there that show how the state system works. The chapter itself focuses on doing state using the pre-iOS17 way, and has pointers to the iOS 17 chapter (in which we explain the key differences and how to use the new state system). We also did our &lt;a href=&quot;https://www.youtube.com/watch?v=H4sSC7scvRw&quot;&gt;second Q&amp;amp;A livestream&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	We also recorded some episodes in which we reimplement a simplified version of the new observation framework in SwiftUI. It turns out this is not that hard to do (although as always, tricky to get just right).
&lt;/p&gt;
&lt;p&gt;
	I spent a morning and half an afternoon doing home improvement, mostly working on the final section of drywall (there’s one corner which wasn’t finished yet). Running also went well, I feel like I recovered very quickly from the marathon. I did take it quite easy the first few days of the week, which always helps.
&lt;/p&gt;
&lt;p&gt;
	In the garden things are growing well. We’re starting to see some tomatoes appear, have strawberries and raspberries, and the cucumber is now producing really well too. The edamame plants I sowed are also still alive. I’ve never grown edamame before, so it’s definitely an experiment that can fail.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 25 Jun 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-25</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-25</guid>
		</item>
		<item>
			<title>Weeknotes № 24</title>
			<description>
				&lt;p&gt;
	We went over the chapters of our book and tried to make an inventory of what we need to add. Most significantly, - the state chapter needs to describe the new way that object observing works, and the animations chapter needs a number of additions.
&lt;/p&gt;
&lt;p&gt;
	We then prepared everything for the launch. This is a bit of a tedious manual process (updating all the website pages, the bundles, all the items on Gumroad, etc.). On Friday we launched the &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui&quot;&gt;prerelease of Thinking in SwiftUI&lt;/a&gt;. We also did a &lt;a href=&quot;https://www.youtube.com/watch?v=pYgAd-LF-UE&quot;&gt;live Q&amp;amp;A&lt;/a&gt; which was really fun. We plan to do these weekly so please &lt;a href=&quot;https://github.com/objcio/thinking-in-swiftui-qa/&quot;&gt;send in your questions&lt;/a&gt;. Here’s the &lt;a href=&quot;https://www.youtube.com/watch?v=H4sSC7scvRw&quot;&gt;Q&amp;amp;A for this Friday&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	On Saturday I ran my first marathon in about a year. I have not trained as much (although I have been ramping up my mileage over the last month and a half) and I was very glad to see that I was only four minutes slower than last year (same course, but this year the weather was not as hot). I thought my shape was a lot worse, this is a good starting point to build off of. Although I did try to stay reasonably fit during the house renovation phase, I know I lost a lot of speed and endurance. Building these up again is very simple for me, but no so easy: when I consistently run a lot (more than 140k/week) over a long period of time (a year or longer) I get very fit.
&lt;/p&gt;
&lt;p&gt;
	I’m thinking of structuring my upcoming training similar to &lt;a href=&quot;https://www.howtoskate.se&quot;&gt;Nils van der Poel&lt;/a&gt;. Although his event is quite different (a speed-skating 10k lasts less 13 minutes whereas a fast marathon lasts almost three hours). I wonder if I should do even more aerobic training and less threshold than he describes.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 18 Jun 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-24</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-24</guid>
		</item>
		<item>
			<title>Weeknotes № 23</title>
			<description>
				&lt;p&gt;
	Last week was WWDC week. Hard to miss, the Vision Pro was announced. I’m excited and worried about that device. I especially didn’t like the dad wearing the goggles to take videos of his kids. I already worry about myself (and others) using their phones and other devices too much when kids are around. You’re there but not really there. To me, this feels like an amazing device to use when I’m at home while everyone else is sleeping.
&lt;/p&gt;
&lt;p&gt;
	A whole bunch of new SwiftUI things got announced. Looks like some really solid improvements. I think the Metal shaders are going to be a lot of fun (&lt;a href=&quot;https://mastodon.social/@dlx/110515723356297247&quot;&gt;Robb is already making cool stuff&lt;/a&gt;). The animation and state changes are very welcome, but will also require to rewrite major parts of our (almost finished) book. What makes this extra tricky is that of course, these APIs might still change until September.
&lt;/p&gt;
&lt;p&gt;
	For the book, we went through and identified most of the parts that will need to change (we’ll blog about this very soon). We went ahead and drew our book’s cover in SwiftUI (the cover changes with each edition). We then also generated the hero image (for &lt;a href=&quot;https://www.objc.io/books/thinking-in-swiftui/&quot;&gt;the book’s page&lt;/a&gt;) in SwiftUI, as we couldn’t open the Sketch file anymore (we basically only use Sketch whenever we need to update that image). The hero image actually uses the generated PDF with the “live” book:
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/thinking-in-swiftui-hero-original.png&quot; title/&gt;&lt;/p&gt;
&lt;p&gt;
	We’ll be releasing the book this week, keep an eye on &lt;a href=&quot;https://www.objc.io/blog&quot;&gt;our blog&lt;/a&gt; and mailing list to keep updated.
&lt;/p&gt;
&lt;p&gt;
	The weather has been amazing here and I went swimming in the lake with the kids almost every single day, which has been really fun for all of us.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 12 Jun 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-23</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-23</guid>
		</item>
		<item>
			<title>Weeknotes № 22</title>
			<description>
				&lt;p&gt;
	I modified our &lt;a href=&quot;https://github.com/objcio/attributed-string-builder/&quot;&gt;attributed-string-builder&lt;/a&gt; to accept modifiers that can be applied to SwiftUI environment. For example, this lets us modify the environment for all embeds inside an &lt;code&gt;AttributedStringConvertible&lt;/code&gt;. So far, the library has been really useful, and we’ve gotten really far with the rendering. For the full book, it’s becoming a bit slow (a few seconds to render), but compared to our previous LaTeX/Pandoc setup it’s blazingly fast. The flexibility and control we get from it is pretty amazing. I know you can have that same (and more) control in LaTeX, but because we write Swift every single day this has way less friction for us.
&lt;/p&gt;
&lt;p&gt;
	We visualized more things, abstracted some of the visualizations away (when similar diagrams use the same abstraction we can be sure they render in the same way, and don’t have subtle errors). We also started working towards ordering a proof copy, with an increased paper size and printed using color instead of grayscale. We’ll have to see how all the text renders there. The first two chapters are now completely done with copy-editing, which means we can do the final typesetting there!
&lt;/p&gt;
&lt;p&gt;
	We recorded two more Swift Talk episodes last week, both on our Git reimplementation. I think with a bit of effort this could actually be turned into a usable dependency-free Git implementation, although getting it secure and safe would probably be a major effort.
&lt;/p&gt;
&lt;p&gt;
	I picked up my running a bit over the last weeks. I finally feel like I have energy for that again (was heavily blocked by the move). I’m slow compared to last year, but only focusing on building out my endurance. I can maintain last year’s marathon pace maybe for one or two kilometers. However, I’m trying to keep a &lt;a href=&quot;https://fs.blog/carol-dweck-mindset/&quot;&gt;growth mindset&lt;/a&gt; and improve every day. The weather has been really nice here, and it’s been amazing to dip in the lake after a run. Also, we finally moved into our actual bedrooms. The flooring was only finished on Friday so we had to improvise a bit until then.
&lt;/p&gt;
			</description>
			<pubDate>Mon, 05 Jun 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-22</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-22</guid>
		</item>
		<item>
			<title>Weeknotes № 21</title>
			<description>
				&lt;p&gt;
	We prepared and recorded episodes that reimplement the core data structures of Git in Swift (without any third-party dependencies). The model of Git is really simple — I think it’s beautiful. In the episodes we recorded everything is read-only, but I managed to get writing to work as well. The tricky part is that objects in git are stored with zlib compression, which requires both a (static) binary header as well as a checksum. I spent quite some time getting the checksum right — but at least the end result is not a lot of code.
&lt;/p&gt;
&lt;p&gt;
	We also continued working on all the diagrams, mostly focusing on animations and transitions this week. For example, this accompanies a section about implementing a custom animatable (shake) modifier:
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/2023-05-29-shake.png&quot; title/&gt;&lt;/p&gt;
&lt;p&gt;
	I spent a lot of time with the kids and in the garden. We improved our watering setup (although I hope to get a better rainwater system soon) and I did a whole bunch of odd jobs that are nice to cross off the list.
&lt;/p&gt;
&lt;p&gt;
	Now that we moved in, I can really tell the difference in energy levels, especially when running. In hindsight, it kind of felt like I could only perform at 60% of my normal capacity (in life and in running). Now, I feel like I can do proper training again, even though I’m much slower than a year ago. But with time and patience I think I can get back towards running some good times again.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 28 May 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-21</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-21</guid>
		</item>
		<item>
			<title>Weeknotes № 20</title>
			<description>
				&lt;p&gt;
	We added a whole lot more diagrams to the book. One thing we struggled with is how to visually separate certain parts, and how to relate them to the text. One of the things we are now able to do is color our text inline (or apply any other attributes). Our Markdown renderer now uses a custom type for string interpolation that lets us embed any other type that converts to attributed strings.
&lt;/p&gt;
&lt;p&gt;
	In &lt;a href=&quot;https://m.objc.io/@chris/110383108374505754&quot;&gt;this post&lt;/a&gt; you can see an example. The code is in our book repository, but I think we can move the Markdown-related infrastructure to our &lt;a href=&quot;https://github.com/objcio/attributed-string-builder&quot;&gt;attributed-string-builder&lt;/a&gt; repository.
&lt;/p&gt;
&lt;p&gt;
	On Friday, our fridge arrived. We managed fine without one, but life is much easier with a functional fridge. I also cooked a meal where almost all ingredients came from the garden, except the rice and egg (a rice bowl with spinach, radish, fresh salad and herbs). We have already used up all the radishes we planted, a lot of the spinach and some of the salad. Even though I already built four raised beds, I think I need to build at least a few more this year. Luckily, these are pretty quick to put together (for now, I just use scrap wood and don’t make them very tall).
&lt;/p&gt;
&lt;p&gt;
	I went for my first swim in the lake that’s across the street. Pretty cold, but really nice. In other water-related news, I also did a whole bunch of stuff in the garden, and I started the plumbing for our garden. I put all the lines above ground for now, to make sure there are no leaks and because we plan to build a terrace anyway.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 21 May 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-20</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-20</guid>
		</item>
		<item>
			<title>Weeknotes № 19</title>
			<description>
				&lt;p&gt;
	We spent last week iterating on the book, mostly drawing diagrams. Because our understanding of SwiftUI has gotten much better since the previous release, we also have much better explanations and much better visuals. We also had to change some things in the underlying infrastructure, but that all worked out. Can’t wait to get this ready.
&lt;/p&gt;
&lt;p&gt;
	For a side project, I spent half a day researching how to sync data using CloudKit. It seems to be pretty easy. Last time I tried that, I had a hard time configuring things, and understanding how the pieces fit together, but it went without problems this time.
&lt;/p&gt;
&lt;p&gt;
	Before we moved in, we started planting a bunch of things in raised beds, and I built two more raised beds last week. We sowed most things ourselves, and bought some small plants as well. We harvested spinach, radish, salat and a number of herbs. It is such a luxury to walk outside into the garden and directly harvest what we need. It also makes me appreciate how much effort goes into this: even with a few large raised beds we would not even come close to growing what we would need to be self-sufficient.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chris.eidhof.nl/images/2023-05-14-garden.jpg&quot; title/&gt;&lt;/p&gt;
&lt;p&gt;
	Most of our kitchen arrived, which definitely helps in making the new house liveable. The main thing missing is the fridge, which is challenging but fine (we have a small portable cooler that holds the essentials for a family of four). Hopefully the fridge gets here soon.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 14 May 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-19</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-19</guid>
		</item>
		<item>
			<title>Weeknotes № 18</title>
			<description>
				&lt;p&gt;
	For our book, I added support to draw nicer diagrams (with overlays on the arrows placed in exactly the right spot). I also changed the syntax highlighting so that we can generate custom attributed strings for certain parts. You can see both parts in action in &lt;a href=&quot;https://m.objc.io/@chris/110304502914075277&quot;&gt;this post&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;
	We also finally moved into our new house! It’s not finished yet, so we had to already move between the two floors twice, but by next week we’ll (hopefully) have a finished kitchen, finished bathrooms and a ground floor that’s completely done.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 07 May 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-18</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-18</guid>
		</item>
		<item>
			<title>Weeknotes № 17</title>
			<description>
				&lt;p&gt;
	We spent a lot of time working on laying out our book, and are getting much closer now. Even though we were “80%” done already, getting all the details right takes a lot of time and tweaking:
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;p&gt;
			We added internal links to the book
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We added warnings for widows and orphans
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We added support for print margins (i.e. margins that differ per page)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We added support to supress headers on title pages and empty pages (the header shows the chapter name and page number)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We added support for state to our attributed string builder library, this threads state through the rendering (useful for e.g. footnotes or numbering things)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We added a PDF outline to the book (the “table of contents” you see in Preview)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We tweaked all the small details (spacing, line height, list rendering, etc.)
		&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;p&gt;
			We spent a long time going back and forth on different styles for rendering our diagrams. The view tree diagrams that we want to show have code, a preview and a diagram. Getting these all on a single page with a good layout wasn’t easy at all.
		&lt;/p&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
	I think we’re very close now to the output that we want. The main thing left is styling the diagrams further, not just the view tree diagrams but also render trees, layout trees, and so on.
&lt;/p&gt;
&lt;p&gt;
	Here’s a sample page showing the current state:
&lt;/p&gt;
&lt;img src=&quot;http://chris.eidhof.nl/images/tis-page.png&quot; style=&quot;width: 216&quot;&gt;

&lt;p&gt;
	We spent a lot of time with the family while over in The Netherlands, and for the first time in half a year, I ran more than 100kms this week. I’m looking forward to build that mileage out again.
&lt;/p&gt;
			</description>
			<pubDate>Sun, 30 Apr 2023 00:00:00 +0200</pubDate>
			<link>http://chris.eidhof.nl/post/2023-17</link>
			<guid isPermaLink="true">http://chris.eidhof.nl/post/2023-17</guid>
		</item>
	</channel>
</rss>